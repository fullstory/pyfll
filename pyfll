#!/usr/bin/python3 -tt
# -*- coding: utf-8 -*-

__author__    = 'Kel Modderman'
__copyright__ = '(C) 2008-2024 Kel Modderman <kelvmod@gmail.com>'
__license__   = 'GPLv2 or any later version'

from configobj import ConfigObj
from io import open
from subprocess import *
import apt_pkg
import apt
import atexit
import datetime
import fileinput
import functools
import glob
import logging
import optparse
import os
import sys
import shutil
import signal
import stat
import tempfile
import time

def restore_sigpipe():
    """Convenience function so that subprocess may be executed with
    SIGPIPE restored to default (http://bugs.python.org/issue1652)."""
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)


class FllLocalesError(Exception):
    """
    An FllError class for use by FllLocales.
    """
    pass


class FllLocales(object):
    """
    A class which provides the ability to determine lists of locale specific
    Debian packages using it's detect_locale_packages method.

    Arguments:
    cache    - an apt_pkg cache object
    packages - a list or dict of package names which are installed, or are
               going to be installed. Locale specific packages are selected
               for packages in this data structure.
    map      - a dict which maps package names with a list of package prefixes
               from which the locale string pattern matching can be used
               to match locale support packages. The prefered input for map is:
               ConfigObj('data/fll-locales-pkg-map').
    """
    def __init__(self, cache, packages, map):
        self.loc_pkgs_set = set()
        for pkg in cache.packages:
            if not pkg.version_list:
                continue
            if pkg.name not in packages:
                continue
            for loc_pkg in list(map.keys()):
                if pkg.name == loc_pkg:
                    loc_pkg_prefix_list = map.get(loc_pkg)
                    for loc_pkg_prefix in loc_pkg_prefix_list:
                        self.loc_pkgs_set.add(loc_pkg_prefix)
                    break

        self.loc_pkgs_list_dict = dict()
        for loc_pkg in self.loc_pkgs_set:
            self.loc_pkgs_list_dict[loc_pkg] = list()
        for pkg in cache.packages:
            if not pkg.version_list:
                continue
            for loc_pkg in self.loc_pkgs_set:
                if pkg.name.startswith(loc_pkg + '-'):
                    self.loc_pkgs_list_dict[loc_pkg].append(pkg.name)

    def __compute_locale_loc_suf_list(self, locale):
        """
        Compute a list of locale package name suffixes. The sequence of
        suffixes are in preferential order, the lowest index being most
        preferential.

        This is a very private method, used by detect_locale_packages.

        Arguments:
        locale - a locale string (eg. en_AU, pt_PT etc.)
        """
        loc_suf_list = list()
        try:
            ll, cc = locale.lower().split('_')
        except ValueError as e:
            raise FllLocalesError(e)
        loc_suf_list.append(f'{ll}-{cc}')
        loc_suf_list.append(f'{ll}{cc}')
        loc_suf_list.append(ll)

        if ll != 'en':
            loc_suf_list.append('i18n')

        return loc_suf_list

    def detect_locale_packages(self, locale):
        """
        Process the data structures created at FllLocales instantiation and
        return a list of package names which are the likely best candidates
        for the locale string given as argument.

        Arguments:
        locale - a locale string (eg. en_AU, pt_PT etc.)
        """
        suffixes = self.__compute_locale_loc_suf_list(locale)

        loc_pkg_dict = dict()
        for pkg in self.loc_pkgs_set:
            loc_pkgs_list = self.loc_pkgs_list_dict.get(pkg)
            if not loc_pkgs_list:
                continue
            if pkg not in loc_pkg_dict:
                loc_pkg_dict[pkg] = dict()
            for loc_pkg in loc_pkgs_list:
                for idx, suf in enumerate(suffixes):
                    if loc_pkg == '-'.join([pkg, suf]):
                       loc_pkg_dict[pkg][idx] = loc_pkg

        packages = list()
        for pkg in self.loc_pkgs_set:
            pkg_candidates = loc_pkg_dict.get(pkg)
            if not pkg_candidates:
                continue
            best = min(pkg_candidates)
            packages.append(pkg_candidates[best])

        return packages


class FllError(Exception):
    '''A generic error handler that does nothing.'''
    pass


class FLLBuilder(object):
    env = {'LANGUAGE': 'C', 'LC_ALL': 'C', 'LANG' : 'C', 'HOME': '/root',
           'PATH': '/usr/sbin:/usr/bin:/sbin:/bin', 'SHELL': '/bin/bash',
           'DEBIAN_FRONTEND': 'noninteractive', 'DEBIAN_PRIORITY': 'critical',
           'DEBCONF_NOWARNINGS': 'yes'}

    diverts = ['/usr/sbin/policy-rc.d',
               '/usr/sbin/modprobe',
               '/usr/sbin/insmod',
               '/usr/sbin/update-grub',
               '/usr/sbin/update-initramfs']


    def __init__(self, options):
        '''Accept options dict, setup logging.'''
        self.opts = options
        self.conf = None
        self.temp = None

        self.log = logging.getLogger('log')
        self.log.setLevel(logging.DEBUG)

        self.time = time.perf_counter()
        self.date = datetime.datetime.now(datetime.UTC)
        self.uuid = self.date.strftime('%Y-%m-%d-%H-%M-%S-00')
        self.timestamp = self.date.strftime('%Y%m%d%H%M')

    def __filterList(self, alist, dup_warn = True):
        '''Return a list containing no duplicate items given a list that
        may have duplicate items.'''

        items = dict()
        for item in alist:
            if item in items and dup_warn:
                self.log.debug(f'duplicate: {item}')
            else:
                items[item] = True

        blist = list(items.keys())
        blist.sort()

        return blist


    def __lines2list(self, lines):
        '''Return a list of stripped strings given a group of line
        separated strings'''
        return [s.strip() for s in lines.splitlines()
                if s.strip() and not s.lstrip().startswith('#')]


    def __isexecutable(self, file):
        '''Return True is file is executable, False otherwise.'''
        try:
            mode = os.stat(file)[stat.ST_MODE]
        except OSError:
            return False

        if stat.S_ISREG(mode) and mode & stat.S_IXUSR:
            return True
        else:
            return False


    def __prepDir(self, dirname):
        '''Set up working directories.'''
        if not os.path.isdir(dirname):
            try:
                os.makedirs(dirname)
                os.chown(dirname, self.opts.u, self.opts.g)
            except:
                self.log.exception(f'failed to create directory: {dirname}')
                raise FllError

        return os.path.realpath(dirname)


    def __initLogger(self, lvl):
        '''Set up the logger.'''
        fmt = logging.Formatter('%(asctime)s %(levelname)-5s - %(message)s')
        out = logging.StreamHandler()
        out.setFormatter(fmt)
        out.setLevel(lvl)
        self.log.addHandler(out)


    def __initLogFile(self, log_filename):
        '''Set up a log file.'''
        log_filename = os.path.realpath(log_filename)
        dirname = os.path.dirname(log_filename)
        self.__prepDir(dirname)

        try:
            fmt = logging.Formatter('%(asctime)s %(levelname)-5s ' +
                                     '%(message)s')
            logfile = logging.FileHandler(filename = log_filename, mode = 'w')
            logfile.setFormatter(fmt)
            logfile.setLevel(logging.DEBUG)
            self.log.addHandler(logfile)
            os.chown(log_filename, self.opts.u, self.opts.g)
        except:
            self.log.exception(f'failed to setup logfile: {log_filename}')
            raise FllError


    def checkOpts(self):
        '''Check and provide default class options.'''
        if self.opts.d:
            self.__initLogger(logging.DEBUG)
        else:
            self.__initLogger(logging.INFO)

        if self.opts.l:
            self.__initLogFile(self.opts.l)

        if self.opts.c:
            if os.path.isfile(self.opts.c):
                self.opts.c = os.path.realpath(self.opts.c)
            else:
                self.log.critical(f'configuration file does not exist: {self.opts.c}')
                raise FllError
        else:
            self.log.critical('no config file specified on command line')
            raise FllError

        if self.opts.s:
            if not os.path.isdir(self.opts.s):
                self.log.critical(f'share directory not exist: {self.opts.s}')
                raise FllError

        self.opts.s = os.path.realpath(self.opts.s)

        if self.opts.o:
            self.opts.o = self.__prepDir(self.opts.o)

        if self.opts.b:
            self.opts.b = self.__prepDir(self.opts.b)



    def _processDefaults(self, defaults):
        '''Form a distro-defaults data structure to be written to
        /etc/default/distro of each chroot, and used for release name.'''
        for key in ['FLL_DISTRO_NAME', 'FLL_IMAGE_DIR', 'FLL_IMAGE_FILE',
                    'FLL_MEDIA_NAME', 'FLL_MOUNTPOINT', 'FLL_LIVE_USER',
                    'FLL_LIVE_USER_GROUPS', 'FLL_GFXBOOT_THEME']:
            if not defaults.get(key):
                self.log.critical(f'{key} is required in "distro" section of config file')
                raise FllError

        for key in ['FLL_DISTRO_NAME', 'FLL_IMAGE_DIR', 'FLL_IMAGE_FILE',
                    'FLL_LIVE_USER', 'FLL_DISTRO_CODENAME_SAFE',
                    'FLL_DISTRO_CODENAME_REV_SAFE']:
            if not defaults.get(key):
                continue
            if not defaults[key].isalnum():
                self.log.critical(f'{key} must be alphanumeric: {defaults[key]}')
                raise FllError
            elif defaults[key].find(' ') >= 0:
                self.log.critical(f'{key} must not contain whitespace: {defaults[key]}')
                raise FllError

        version = defaults.get('FLL_DISTRO_VERSION')
        if version and version != 'snapshot':
            if not defaults.get('FLL_DISTRO_CODENAME_SAFE'):
                self.log.critical("'FLL_DISTRO_VERSION' is set, but " +
                                  "'FLL_DISTRO_CODENAME_SAFE' is not")
                raise FllError

            for key in ['FLL_DISTRO_CODENAME', 'FLL_DISTRO_CODENAME_REV']:
                safe = key + '_SAFE'
                if defaults.get(safe) and not defaults.get(key):
                    defaults[key] = defaults[safe]
        else:
            defaults['FLL_DISTRO_VERSION'] = 'snapshot'


    def _getDistroImageFile(self, arch):
        '''Return image file that compressed chroot will be archived to.'''
        image_file = self.conf['distro']['FLL_IMAGE_FILE']
        if arch == 'i386':
            image_file += '.686'
        else:
            image_file += '.%s' % arch

        self.log.debug('image_file: %s' % image_file)
        return image_file


    def _getDistroStamp(self):
        '''Return a string suitable for the distro stamp file.'''
        defaults = self.conf['distro']
        stamp = ' '.join([defaults['FLL_DISTRO_NAME'], defaults['FLL_DISTRO_VERSION']])
        if defaults.get('FLL_DISTRO_VERSION') == 'snapshot':
            stamp += ' - %s' % self.conf['packages']['profile']
        else:
            if defaults.get('FLL_DISTRO_CODENAME_REV'):
                stamp += ' - %s' % defaults['FLL_DISTRO_CODENAME']
                stamp += ' %s -' % defaults['FLL_DISTRO_CODENAME_REV']
            else:
                stamp += ' %s -' % defaults['FLL_DISTRO_CODENAME']

            stamp += ' %s' % self.conf['packages']['profile']

        stamp += ' - (%s)' % self.timestamp

        self.log.debug('stamp: %s' % stamp)
        return stamp


    def _getDistroMediaName(self):
        '''Return a string suitable for the distro stamp file.'''
        defaults = self.conf['distro']
        name = '-'.join([defaults['FLL_DISTRO_NAME'], defaults['FLL_DISTRO_VERSION']])
        if defaults.get('FLL_DISTRO_VERSION') == 'snapshot':
            name += '-%s' % self.conf['packages']['profile']
        else:
            if defaults.get('FLL_DISTRO_CODENAME_REV'):
                name += '-%s-%s' % (defaults['FLL_DISTRO_CODENAME_SAFE'],
                                    defaults['FLL_DISTRO_CODENAME_REV_SAFE'])
            else:
                name += '-%s' % defaults['FLL_DISTRO_CODENAME_SAFE']

            name += '-%s' % self.conf['packages']['profile']
            name += '-%s' % self.conf['sourcedistro']['codename']

        name += '-' + '-'.join(list(self.conf['archs'].keys()))
        name += '-%s' % self.timestamp

        self.log.debug(f'name: {name}')
        return name


    def _processConf(self):
        '''Process configuration options.'''
        arch = ''
        if self.opts.a:
            arch = self.opts.a
        elif not self.conf.get('archs'):
            arch = Popen(['dpkg', '--print-architecture'], preexec_fn=restore_sigpipe,
                              stdout=PIPE).communicate()[0].decode().rstrip()

        if len(arch):
            self.log.debug(f'arch: {arch}')
            if arch not in list(self.conf['archs'].keys()):
                self.conf['archs'] = {arch: dict()}
            else:
                for arch2 in list(self.conf['archs'].keys()):
                    if arch != arch2:
                        del self.conf['archs'][arch2]

        for arch in list(self.conf['archs'].keys()):
            if 'linux' not in self.conf['archs'][arch]:
                if arch == 'i386':
                    cpu = '486'
                else:
                    cpu = arch

                linux = cpu

                self.conf['archs'][arch].setdefault('linux', [ linux ])
            else:
                linux = self.conf['archs'][arch]['linux']
                if isinstance(linux, str):
                    self.conf['archs'][arch]['linux'] = [ linux ]
                elif not isinstance(linux, list):
                    self.log.critical(f'invalid linux for arch {arch} in config')
                    raise FllError

        if len(list(self.conf['repos'].keys())) < 1:
            self.log.critical('no apt repos were specified in build config')
            raise FllError

        if 'sourcedistro' not in self.conf or \
           'name' not in self.conf['sourcedistro']:
            self.opts.N = 'debian'
            self.opts.C = 'sid'
        else:
            self.opts.N = self.conf['sourcedistro']['name']
            if 'codename' not in self.conf['sourcedistro']:
                self.log.critical('codename undefined in distro section of build config')
                raise FllError
            else:
                self.opts.C = self.conf['sourcedistro']['codename']
                
        if self.opts.N not in self.conf['repos']:
            self.log.critical(f'{self.opts.N} repo not configured in build config')
            raise FllError

        for repo in list(self.conf['repos'].keys()):
            if self.conf['repos'][repo].get('trivial'):
                words = ['label', 'uri']
            elif self.conf['repos'][repo].get('sources_uri'):
                words = []
            else:
                words = ['label', 'uri', 'suite', 'components']

            for word in words:
                if word not in self.conf['repos'][repo]:
                    self.log.critical(f'"{word}" must be defined for apt repo "{repo}"')
                    raise FllError

        if self.opts.p:
            self.conf['packages']['profile'] = self.opts.p
        elif 'profile' not in self.conf['packages']:
            self.conf['packages']['profile'] = 'kde-lite'
        self.log.debug('profile: %s' % self.conf['packages']['profile'])

        if 'i18n' not in self.conf['packages'] or \
           not self.__lines2list(self.conf['packages']['i18n']):
            self.conf['packages']['i18n'] = 'en_US'
        i18n = self.__lines2list(self.conf['packages']['i18n'])
        self.log.debug('i18n: %s' % ' '.join(i18n))

        if 'hashkey' not in self.conf['options']:
            self.log.info('no key for signing ISO hashes!')
            self.opts.k = None
        else:
            self.opts.k = self.conf['options'].get('hashkey')
            self.log.debug(f'using key {self.opts.k} for signing')

        if not 'options' in self.conf:
            self.conf['options'] = dict()

        if self.conf['options'].get('build_dir'):
            if not self.opts.b:
                dirname = self.conf['options']['build_dir']
                self.opts.b = self.__prepDir(dirname)
        else:
            if not self.opts.b:
                self.opts.b = self.__prepDir(os.getcwd())

        if self.conf['options'].get('output_dir'):
            if not self.opts.o:
                dirname = self.conf['options']['output_dir']
                self.opts.o = self.__prepDir(dirname)
        else:
            if not self.opts.o:
                self.opts.o = self.__prepDir(os.getcwd())

        if self.conf['options'].get('build_log'):
            if not self.opts.l:
                self.opts.l = self.conf['options']['build_log']
                self.__initLogFile(self.opts.l)

        if self.conf['options'].get('http_proxy'):
            self.env['http_proxy'] = self.conf['options']['http_proxy']

        if self.conf['options'].get('ftp_proxy'):
            self.env['ftp_proxy'] = self.conf['options']['ftp_proxy']

        self.conf['options'].setdefault('apt_preferences', None)
        self.conf['options'].setdefault('apt_recommends', 'no')
        self.conf['options'].setdefault('media_include', None)

        if 'distro' in self.conf:
                self._processDefaults(self.conf['distro'])
                self.log.debug('distro-defaults:')
                for key, value in list(self.conf['distro'].items()):
                    self.log.debug(f'{key}="{value}"')
                self.log.debug('testing stamp/name:')
                self._getDistroStamp()
                self._getDistroMediaName()
        else:
            self.log.critical('distro section not found in build config')
            raise FllError


    def parseConf(self):
        '''Parse build configuration file and return it in a dict.'''
        self.log.info('reading configuration file...')

        self.conf = ConfigObj(self.opts.c)
        self._processConf()


    def _processPkgProfile(self, arch, profile, profile_dir):
        '''Return a dict, arch string as key and package, debconf and postinst
        lists.'''
        pkgs = {'debconf': [], 'packages': [], 'postinst': []}

        linux_meta = ['linux-image', 'linux-headers']
        for kvers in self.conf['archs'][arch]['linux']:
            pkgs['packages'].extend(['-'.join([l, kvers]) for l in linux_meta])

        pname = os.path.basename(profile)
        self.log.debug(f'processing package profile for {arch}: {pname}')

        pfile = ConfigObj(profile)

        if 'desc' in pfile:
            for line in self.__lines2list(pfile['desc']):
                self.log.debug(f'  {line}')

        if 'debconf' in pfile:
            self.log.debug('debconf:')
            for debconf in self.__lines2list(pfile['debconf']):
                pkgs['debconf'].append(debconf)
                self.log.debug(f'  {debconf}')

        if 'debconf' in self.conf['packages']:
            self.log.debug('debconf (config):')
            for debconf in self.__lines2list(self.conf['packages']['debconf']):
                pkgs['debconf'].append(debconf)
                self.log.debug(f'  {debconf}')

        if 'packages' in pfile:
            self.log.debug('packages:')
            for pkg in self.__lines2list(pfile['packages']):
                pkgs['packages'].append(pkg)
                self.log.debug(f'  {pkg}')

        if 'packages' in self.conf['packages']:
            self.log.debug('packages (config):')
            for pkg in self.__lines2list(self.conf['packages']['packages']):
                pkgs['packages'].append(pkg)
                self.log.debug(f'  {pkg}')

        if arch in pfile:
            self.log.debug(f'packages ({arch}):')
            for pkg in self.__lines2list(pfile[arch]):
                pkgs['packages'].append(pkg)
                self.log.debug(f'  {pkg}')

        deps = []
        if 'deps' in pfile:
            self.log.debug('deps:')
            for dep in self.__lines2list(pfile['deps']):
                deps.append(dep)
                self.log.debug(f'  {dep}')

        if 'deps' in self.conf['packages']:
            self.log.debug('deps (config):')
            for dep in self.__lines2list(self.conf['packages']['deps']):
                deps.append(dep)
                self.log.debug(f'  {dep}')

        if os.path.isfile(profile + '.postinst'):
            self.log.debug(f'registering postinst script: {profile}.postinst')
            pkgs['postinst'].append(profile + '.postinst')

        self.log.debug('---')

        for dep in deps:
            depfile = os.path.join(profile_dir, 'deps', dep)

            if not os.path.isfile(depfile):
                self.log.critical(f'no such dep file: {depfile}')
                raise FllError

            dname = os.path.basename(depfile)
            self.log.debug(f'processing dependency file: {dname}')

            dfile = ConfigObj(depfile)

            if 'desc' in dfile:
                for line in self.__lines2list(dfile['desc']):
                    self.log.debug(f'  {line}')

            if 'debconf' in dfile:
                self.log.debug('debconf:')
                for debconf in self.__lines2list(dfile['debconf']):
                    pkgs['debconf'].append(debconf)
                    self.log.debug(f'  {debconf}')

            if 'packages' in dfile:
                self.log.debug('packages:')
                for pkg in self.__lines2list(dfile['packages']):
                    pkgs['packages'].append(pkg)
                    self.log.debug(f'  {pkg}')

            if arch in dfile:
                self.log.debug(f'packages ({arch}):')
                for pkg in self.__lines2list(dfile[arch]):
                    pkgs['packages'].append(pkg)
                    self.log.debug(f'  {pkg}')

            if os.path.isfile(depfile + '.postinst'):
                self.log.debug(f'registering postinst script: {depfile}.postinst')
                pkgs['postinst'].append(depfile + '.postinst')

            self.log.debug('---')

        self.log.debug(f'package summary for {arch}:')
        pkgs['packages'].sort()
        for pkg in pkgs['packages']:
            self.log.debug(f'  {pkg}')

        self.log.debug(f'debconf summary for {arch}:')
        pkgs['debconf'].sort()
        for debconf in pkgs['debconf']:
            self.log.debug(f'  {debconf}')

        pkgs['packages'] = self.__filterList(pkgs['packages'])

        return pkgs


    def parsePkgProfile(self):
        '''Parse packages profile file(s).'''
        self.log.info('processing package profile (%s)...' %
                      self.conf['packages']['profile'])

        profiles_dir = os.path.join(self.opts.s, 'profiles')
        profile = os.path.join(profiles_dir, self.conf['packages']['profile'])

        if not os.path.isfile(profile):
            self.log.critical(f'no such package profile: {profile}')
            raise FllError

        self.pkgs = dict()
        for arch in list(self.conf['archs'].keys()):
            self.pkgs[arch] = self._processPkgProfile(arch, profile, profiles_dir)
            try:
                self.pkgs[arch]['packages'] += \
                    self.__lines2list(self.conf['packages'][arch])
            except KeyError:
                pass


    def _getDebconfList(self, arch):
        '''Return debconf list for arch. Dynamically generate locales
        debconf configuration based on i18n configuration in flk.conf.'''
        i18n_list = self.__lines2list(self.conf['packages']['i18n'])
        if len(i18n_list) == 0:
            i18n_list = 'en_US'
        i18n_debconf = 'locales locales/locales_to_be_generated multiselect '
        for i18n in i18n_list:
            i18n_debconf += f'{i18n}.UTF-8 UTF-8,'
        i18n_debconf = i18n_debconf.rstrip(',')
        self.pkgs[arch]['debconf'].append(i18n_debconf)

        return self.pkgs[arch]['debconf']


    def _getPackageList(self, arch):
        '''Return package list for arch.'''
        return self.pkgs[arch]['packages']


    def _getPostinstList(self, arch):
        '''Return postinst list for arch.'''
        return self.pkgs[arch]['postinst']


    def stageBuildArea(self):
        '''Prepare temporary directory for chroots and result staging area.'''
        self.log.debug('preparing build area...')

        self.temp = tempfile.mkdtemp(prefix = 'fll_', dir = self.opts.b)
        os.chown(self.temp, self.opts.u, self.opts.g)

        atexit.register(self.cleanup)

        stage = os.path.join(self.temp, 'staging')
        os.mkdir(stage)
        os.mkdir(os.path.join(stage, 'boot'))
        os.mkdir(os.path.join(stage, self.conf['distro']['FLL_IMAGE_DIR']))

        media_include = self.conf['options'].get('media_include')
        if media_include and os.path.isdir(media_include):
            try:
                target_dirpath = os.path.join(stage, os.path.basename(media_include))
                shutil.copytree(media_include, target_dirpath, dirs_exist_ok=True,
                                ignore=shutil.ignore_patterns('.git*'))
            except:
                self.log.exception(f'problem copying media_include data to staging dir: {media_include}')
                raise FllError


    def _mount(self, chroot):
        '''Mount virtual filesystems in a chroot.'''
        virtfs = {'devpts': 'dev/pts', 'proc': 'proc'}

        for v in list(virtfs.items()):
            cmd = ['mount', '-t', v[0], 'fll-' + v[0],
                   os.path.join(chroot, v[1])]

            retv = call(cmd, preexec_fn=restore_sigpipe)
            if retv != 0:
                self.log.critical(f'failed to mount chroot {v[0]}')
                raise FllError


    def _umount(self, chrootdir):
        '''Umount any mount points in a chroot.'''
        umount_list = []
        try:
            for line in open('/proc/mounts'):
                (dev, mnt, fs, options, d, p) = line.split()
                if mnt.startswith(chrootdir):
                    umount_list.append(mnt)
        except IOError:
            self.log.exception('failed to open /proc/mounts')
            raise FllError

        umount_list.sort(key=len)
        umount_list.reverse()

        for mpoint in umount_list:
            retv = call(['umount', mpoint], preexec_fn=restore_sigpipe)
            if retv != 0:
                self.log.critical(f'umount failed for: {mpoint}')
                raise FllError


    def _nuke(self, dirname):
        '''Nuke directory tree.'''
        if os.path.isdir(dirname):
            self.log.debug(f'nuking directory: {dirname}')
            try:
                shutil.rmtree(dirname)
            except:
                self.log.exception(f'unable to remove {dirname}')
                raise FllError
        else:
            self.log.debug(f'directory does not exist: {dirname}')


    def _nukeChroot(self, arch):
        '''Convenience function to nuke chroot given by arch name.'''
        if not self.opts.P:
            self.log.info(f'nuking chroot: {arch}')
            chroot = os.path.join(self.temp, arch)
            self._umount(chroot)
            self._nuke(chroot)


    def cleanup(self):
        '''Clean up the build area after taking care that all build chroots
        have been taken care of.'''
        self.log.info('cleaning up...')

        for arch in list(self.conf['archs'].keys()):
            dirname = os.path.join(self.temp, arch)
            if os.path.isdir(dirname):
                self.log.debug(f'cleaning up chroot: {arch}')
                self._umount(dirname)
                if not self.opts.P:
                    self._nuke(dirname)

        if not self.opts.P:
            self._nuke(self.temp)


    def __execLogged(self, cmd, check_returncode):
        '''Execute a command logging all output. Output sent to the console is
        buffered until the command has finished execution.'''
        command_line = ' '.join(cmd)
        self.log.debug(command_line)

        try:
            c = Popen(cmd, stdout = PIPE, stderr = STDOUT, env = self.env,
                      close_fds = True, preexec_fn=restore_sigpipe)
            cout = c.communicate()[0]
            retv = c.returncode
        except KeyboardInterrupt:
            raise FllError
        except:
            self.log.exception(f'problem executing command: {command_line}')
            raise FllError

        for line in cout.splitlines():
            if self.opts.q:
                self.log.debug(line.rstrip())
            else:
                self.log.info(line.rstrip())

        if retv != 0 and check_returncode:
            self.log.critical(f'command failed with return value: {c.returncode}')
            raise FllError


    def __exec(self, cmd, check_returncode):
        '''Execute subprocess without buffering output in a pipe.'''
        command_line = ' '.join(cmd)
        self.log.debug(command_line)

        try:
            if self.opts.q:
                retv = call(cmd, stdout = open(os.devnull, 'w'),
                            stderr = STDOUT, env = self.env,
                            close_fds = True, preexec_fn=restore_sigpipe)
            else:
                retv = call(cmd, env = self.env, close_fds = True,
                            preexec_fn=restore_sigpipe)
        except KeyboardInterrupt:
            raise FllError
        except:
            self.log.exception(f'problem executing command: {command_line}')
            raise FllError

        if retv != 0 and check_returncode:
            self.log.critical(f'command failed with return value: {retv}')
            raise FllError


    def _execCmd(self, cmd, check_returncode = True):
        '''Convenience wrapper for subprocess execution.'''
        if self.opts.l:
            self.__execLogged(cmd, check_returncode)
        else:
            self.__exec(cmd, check_returncode)


    def _execInChroot(self, arch, args, check_returncode = True):
        '''Run command in a chroot.'''
        chroot = os.path.join(self.temp, arch)
        cmd = ['chroot', chroot]
        cmd.extend(args)

        self._mount(chroot)

        if self.opts.l:
            self.__execLogged(cmd, check_returncode)
        else:
            self.__exec(cmd, check_returncode)

        self._umount(chroot)


    def _aptGetInstall(self, arch, pkgs, download_only = False):
        '''An apt-get install wrapper. Automatic installation of recommended
        packages defaults to disabled.'''
        aptget = ['apt-get', '--yes']

        if download_only:
            aptget.append('--download-only')
        if self.conf['options']['apt_recommends'] == 'no':
            aptget.extend(['-o', 'APT::Install-Recommends=0'])
        if self.opts.d:
            aptget.extend(['-o', 'APT::Get::Show-Versions=1'])

        aptget.append('install')
        aptget.extend(pkgs)

        self._execInChroot(arch, aptget)


    def __cdebBootStrap(self, arch, dirname, mirror, codename):
        '''Bootstrap a debian system with cdebootstrap.'''
        cmd = ['cdebootstrap', '--arch=%s' % arch,
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--flavour=minimal', codename, dirname, mirror]

        if self.opts.d:
            cmd.append('--debug')
        elif self.opts.v:
            cmd.append('--verbose')

        self._execCmd(cmd)

        cmd = 'dpkg --purge cdebootstrap-helper-rc.d'
        self._execInChroot(arch, cmd.split())


    def __debBootStrap(self, arch, dirname, mirror, codename):
        '''Bootstrap a debian system with debootstrap.'''
        cmd = ['debootstrap', f'--arch={arch}',
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--variant=minbase', '--merged-usr', codename, dirname, mirror]

        if self.opts.d or self.opts.v:
            cmd.insert(1, '--verbose')

        self._execCmd(cmd)


    def __mmdebBootStrap(self, arch, dirname, mirror, codename):
        '''Bootstrap a debian system with mmdebstrap.'''
        cmd = ['mmdebstrap', '--architectures=%s' % arch,
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--variant=minbase', '--mode=root', '--format=directory',
               '--hook-dir=/usr/share/mmdebstrap/hooks/merged-usr', codename,
               dirname, mirror]

        if self.opts.d or self.opts.v:
            cmd.insert(1, '--verbose')

        self._execCmd(cmd)


    def _bootStrap(self, arch):
        '''Bootstrap a debian system with cdebootstrap.'''
        distro = self.opts.N
        debian = self.conf['repos'][distro]
        codename = self.opts.C
        if debian.get('cached'):
            mirror = debian['cached']
        else:
            mirror = debian['uri']

        dirname = os.path.join(self.temp, arch)

        self.log.info(f'bootstrapping {distro} {codename} {arch}...')

        bootstrapper = self.conf['options'].get('bootstrapper')
        if bootstrapper == 'mmdebstrap':
            self.__mmdebBootStrap(arch, dirname, mirror, codename)
        elif bootstrapper == 'debootstrap':
            self.__debBootStrap(arch, dirname, mirror, codename)
        else:
            self.__cdebBootStrap(arch, dirname, mirror, codename)

        shutil.copy('/etc/hosts', os.path.join(dirname, 'etc'))
        shutil.copy('/etc/resolv.conf', os.path.join(dirname, 'etc'))
        os.mkdir(os.path.join(dirname, 'disks'), 0o755)


    def _writeAptLists(self, arch, cached = False, src_uri = False):
        '''Write apt source lists to /etc/apt/sources.list.d/*.'''
        chroot = os.path.join(self.temp, arch)
        for r in self.conf['repos'].keys():
            repo = self.conf['repos'][r]
            cached_uri = repo.get('cached')
            sources_uri = repo.get('sources_uri')
            if sources_uri:
                cmd = ['wget', '--quiet', sources_uri, '-O']
                cmd.append(os.path.join(chroot, 'etc/apt/sources.list.d',
                                        os.path.basename(sources_uri)))
                self._execCmd(cmd)

                if cached and cached_uri:
                    cmd = ['sed', '-i', f's#^URIs: .*#URIs: {cached_uri}#']
                    cmd.append(os.path.join(chroot, 'etc/apt/sources.list.d',
                                            os.path.basename(sources_uri)))
                    self._execCmd(cmd)
                continue

            sources_file = os.path.join(chroot, 'etc/apt/sources.list.d',
                                        repo['label'] + '.sources')

            self.log.debug("creating %s" % sources_file)
            sources_file_fh = None
            try:
                sources_file_fh = open(sources_file, 'w')
                if src_uri or not self.opts.B:
                    sources_file_fh.write('Types: deb deb-src\n')
                else:
                    sources_file_fh.write('Types: deb\n')
                if cached and cached_uri:
                    sources_file_fh.write(f'URIs: {cached_uri}\n')
                else:
                    sources_file_fh.write(f'URIs: {repo['uri']}\n')
                sources_file_fh.write(f'Suites: {repo['suite']}\n')
                sources_file_fh.write(f'Components: {repo['components']}\n')
                if repo.get('keyring'):
                    sources_file_fh.write(f'Signed-by: /usr/share/keyrings/{repo['keyring']}.gpg\n')
                else:
                    sources_file_fh.write(f'Signed-by: /usr/share/keyrings/debian-archive-keyring.gpg\n')
            except IOError:
                self.log.exception('failed to open %s' % sources_file)
                raise FllError
            finally:
                if sources_file_fh:
                    sources_file_fh.close()


    def _primeApt(self, arch):
        '''Prepare apt for work in each build chroot. Fetch all required gpg
        keys and initialize apt_pkg config.'''
        self.log.info('preparing apt in %s chroot...' % arch)
        chroot = os.path.join(self.temp, arch)

        apt_preferences = self.conf['options']['apt_preferences']
        if apt_preferences:
            self.log.info(f'importing apt preferences file: {apt_preferences}')
            try:
                shutil.copy(apt_preferences, os.path.join(chroot, 'etc/apt/'))
            except IOError:
                self.log.error(f'failed to import apt preferences: {apt_preferences}')
                raise FllError

        self.log.debug(f'removing sources.list from chroot: {arch}')
        sources_list = os.path.join(chroot, 'etc/apt/sources.list')
        if os.path.isfile(sources_list):
            os.unlink(sources_list)

        self._writeAptLists(arch, cached = True, src_uri = True)

        keyrings = list()
        for r in self.conf['repos'].keys():
            repo = self.conf['repos'][r]
            keyring = repo.get('keyring')
            if keyring:
                keyrings.append(keyring)

        if len(keyrings) > 0:
            self._execInChroot(arch, 'apt-get -o Acquire::Languages=none --allow-insecure-repositories update'.split())
            cmd = 'apt-get --allow-unauthenticated --yes install'.split()
            cmd.extend(keyrings)
            self._execInChroot(arch, cmd)

        self._execInChroot(arch, 'apt-get -o Acquire::Languages=none update'.split())
        # Upgrade any essential packages from sources not available
        # during bootstrap phase.
        self._execInChroot(arch, 'apt-get dist-upgrade -y'.split())

        apt_pkg.init_config()
        apt_pkg.config.set('RootDir', chroot)
        apt_pkg.config.set('APT::Architecture', arch)
        apt_pkg.init_system()


    def _dpkgAddDivert(self, arch):
        '''Divert some facilities and replace temporaily with /bin/true (or
        some other more appropiate facility.'''
        chroot = os.path.join(self.temp, arch)
        for divert in self.diverts:
            self.log.debug("diverting %s" % divert)
            cmd = 'dpkg-divert --add --local --divert ' + divert + '.REAL --rename '
            cmd += divert
            self._execInChroot(arch, cmd.split())

            if divert == '/usr/sbin/policy-rc.d':
                self._writeFile(arch, divert)
                os.chmod(os.path.join(chroot, divert.lstrip('/')), 0o755)
            else:
                os.symlink('/bin/true', os.path.join(chroot, divert.lstrip('/')))


    def _dpkgUnDivert(self, arch):
        '''Undivert facilities diverted by self._dpkgAddDivert().'''
        chroot = os.path.join(self.temp, arch)
        for divert in self.diverts:
            self.log.debug(f'undoing diversion: {divert}')
            os.unlink(os.path.join(chroot, divert.lstrip('/')))
            cmd = 'dpkg-divert --remove --rename ' + divert
            self._execInChroot(arch, cmd.split())


    def _writeFile(self, arch, filename):
        '''Write a file in a chroot. Templates for common files included
        below.'''
        chroot = os.path.join(self.temp, arch)

        f = None
        fn = None
        mode = 0o644
        try:
            fn = os.path.join(chroot, filename.lstrip('/'))
            if os.path.isfile(fn):
                mode = None
            if not os.path.exists(os.path.dirname(fn)):
                try:
                    os.makedirs(os.path.dirname(fn), 0o755)
                except OSError as exc:
                    if exc.errno != errno.EEXIST:
                        raise
            f = open(fn, 'w')
            self.log.debug(f'writing file: {filename}')
            if filename == '/etc/default/distro':
                defaults = list(self.conf['distro'].keys())
                defaults.sort()
                for key in defaults:
                    if key.startswith('FLL_DISTRO_CODENAME'):
                        continue
                    elif key == 'FLL_MOUNTPOINT':
                        f.write('%s="%s"\n' % (key, self.conf['distro'][key]))
                        test = '$([ -d "$%s" ] && echo live' % key
                        test += ' || echo installed)'
                        f.write('%s="%s"\n' % ('FLL_DISTRO_MODE', test))
                    elif key == 'FLL_IMAGE_FILE':
                        image_file = self._getDistroImageFile(arch)
                        f.write('%s="%s"\n' % (key, image_file))
                        f.write('%s="$%s/$%s"\n' % ('FLL_IMAGE_LOCATION',
                                                    'FLL_IMAGE_DIR', key))
                    else:
                        f.write('%s="%s"\n' % (key, self.conf['distro'][key]))
            elif filename == '/etc/fstab':
                f.write('# /etc/fstab: static file system information\n')
            elif filename == '/etc/hostname':
                hostname = self.conf['distro']['FLL_DISTRO_NAME']
                f.write(hostname + '\n')
            elif filename == '/etc/hosts':
                hostname = self.conf['distro']['FLL_DISTRO_NAME']
                f.write('127.0.0.1\tlocalhost\n')
                f.write('127.0.0.1\t' + hostname + '\n\n')
                f.write('# Below lines are for IPv6 capable hosts\n')
                f.write('::1     ip6-localhost ip6-loopback\n')
                f.write('fe00::0 ip6-localnet\n')
                f.write('ff00::0 ip6-mcastprefix\n')
                f.write('ff02::1 ip6-allnodes\n')
                f.write('ff02::2 ip6-allrouters\n')
                f.write('ff02::3 ip6-allhosts\n')
            elif filename == '/usr/sbin/policy-rc.d':
                f.write('#!/bin/sh\n')
                f.write('echo "$0 denied action: $1 $2" >&2\n')
                f.write('exit 101\n')
            elif filename == '/tmp/iso_uuid':
                f.write(self.uuid)
                self.conf['distro']['FLL_UUID'] = self.uuid
        except IOError:
            self.log.exception(f'failed to open file for writing: {filename}')
            raise FllError
        finally:
            if f:
                f.close()
                if mode:
                    os.chmod(fn, mode)


    def _defaultConffiles(self, arch):
        '''Initial creation of conffiles required in chroot.'''
        self._writeFile(arch, '/etc/fstab')
        self._writeFile(arch, '/etc/hostname')
        self._writeFile(arch, '/tmp/iso_uuid')


    def _distroDefaults(self, arch):
        '''Write the /etc/default/distro file.'''
        self._writeFile(arch, '/etc/default/distro')


    def _finalConffiles(self, arch):
        '''Final editing of conffiles in chroot.'''
        chroot = os.path.join(self.temp, arch)

        distro_version = '%s-version' % \
                         self.conf['distro']['FLL_DISTRO_NAME'].lower()
        distro_version = os.path.join(chroot, 'etc', distro_version)

        self.log.debug(f'stamping distro version: {distro_version}')
        f = None
        try:
            f = open(distro_version, 'w')
            f.write(self._getDistroStamp())
        except IOError:
            self.log.exception(f'failed to open file for writing: {distro_version}')
            raise FllError
        finally:
            if f:
                f.close()
                os.chmod(distro_version, 0o444)

        self._writeFile(arch, '/etc/hosts')
        self._writeFile(arch, '/etc/motd.tail')

        self.log.debug('writing final apt sources.list(s)')
        self._writeAptLists(arch)

        if os.path.isfile(os.path.join(chroot, 'etc/resolv.conf')) and \
           not os.path.islink(os.path.join(chroot, 'etc/resolv.conf')):
            # networkd+resolved so setup symlink and disable fallback DNS
            try:
                os.unlink(os.path.join(chroot, 'etc/resolv.conf'))
                os.symlink('../run/systemd/resolve/stub-resolv.conf', os.path.join(chroot, 'etc/resolv.conf'))
                with open(os.path.join(chroot, 'etc/systemd/resolved.conf'), 'a') as f:
                    f.write('DNS=\n')
            except IOError:
                self.log.exception('failed to setup resolv.conf and resolved.conf')
                raise FllError

        if os.path.isfile(os.path.join(chroot, 'etc/.resolv.conf.systemd-resolved.bak')):
            try:
                os.unlink(os.path.join(chroot, 'etc/.resolv.conf.systemd-resolved.bak'))
            except IOError:
                self.log.exception('failed to delete .resolv.conf.systemd-resolved.bak')
                raise FllError

        if 'home' in self.conf:
            self.log.info('copying systemd-homed keys to %s chroot...' % arch)
            try:
                os.makedirs(os.path.join(chroot, 'var/lib/systemd/home/'))
                pubkey = self.conf['home'].get('pubkey')
                shutil.copy(pubkey, os.path.join(chroot, 'var/lib/systemd/home/'))
                privkey = self.conf['home'].get('privkey')
                if privkey:
                    shutil.copy(privkey, os.path.join(chroot, 'var/lib/systemd/home/'))
            except FileNotFoundError:
                self.log.exception('home configuration invalid')
                raise FllError

        boot_theme = self.conf['options'].get('boot_theme', 'bgrt')
        self.log.info(f'setting plymouth theme: {boot_theme}')
        self._execInChroot(arch, ['plymouth-set-default-theme', boot_theme])


    def _makeInitramfs(self, arch):
        '''Generate the initramfs if update-initramfs was diverted'''
        if '/usr/sbin/update-initramfs' in self.diverts and not self.opts.D:
            chroot = os.path.join(self.temp, arch)
            kvers = self._detectLinuxVersion(chroot)
            for kernel in kvers:
                cmd = 'update-initramfs -c -k %s' % kernel
                if self.opts.v:
                    cmd += ' -v'
                self._execInChroot(arch, cmd.split())


    def _preseedDebconf(self, arch):
        '''Preseed debconf with values read from package lists.'''
        chroot = os.path.join(self.temp, arch)
        debconf_list = self._getDebconfList(arch)

        if debconf_list:
            self.log.info(f'preseeding debconf in chroot: {arch}')
            debconf = None
            try:
                debconf = open(os.path.join(chroot, 'tmp',
                                            'fll_debconf_selections'), 'w')
                debconf.writelines([f'{d}\n' for d in debconf_list])
            except IOError:
                self.log.exception('failed to open file for writing: %s' %
                                   '/tmp/fll_debconf_selections')
                raise FllError
            finally:
                if debconf:
                    debconf.close()

            cmd = 'debconf-set-selections '
            if self.opts.v:
                cmd += '--verbose '
            cmd += '/tmp/fll_debconf_selections'

            self._execInChroot(arch, cmd.split())


    def _detectLinuxVersion(self, chroot):
        '''Return version string of a singularly installed linux-image.'''
        kvers = [f[f.find('-')+1:] for f in
                 os.listdir(os.path.join(chroot, 'boot'))
                 if f.startswith('vmlinuz-') or f.startswith('vmlinux-')]
        if self.opts.D:
            arch = chroot[chroot.rfind('/')+1:]
            kvers = [f[len('linux-image-'):] for f in
                     self.pkgs[arch]['install']
                     if f.startswith('linux-image-')]

        if len(kvers) > 0:
            kvers.sort(key=functools.cmp_to_key(apt_pkg.version_compare))
            kvers.reverse()
            return kvers

        self.log.critical('failed to detect linux version installed in chroot')
        raise FllError


    def _detectLocalePkgs(self, i18n, wanted, cache):
        '''Provide automated detection for extra i18n packages.'''
        self.log.info(f'detecting i18n packages for locales: {' '.join(i18n)}')

        locales_pkg_map_file = os.path.join(self.opts.s, 'data', 'locales-pkg-map')
        locales_pkg_map = ConfigObj(locales_pkg_map_file)
        self.log.debug('locales_pkg_map:')
        self.log.debug(locales_pkg_map)

        fll_locales = FllLocales(cache, wanted, locales_pkg_map)
        i18n_list = []
        for locale in sorted(i18n):
            try:
                loc_pkg_list = fll_locales.detect_locale_packages(locale)
            except FllLocalesError:
                print_error(f'Failed to parse locale string: {locale}')
            else:
                i18n_list.extend(loc_pkg_list)

        self.log.debug('i18n_list:')
        self.log.debug(i18n_list)
        return i18n_list


    def _detectRecommendedPkgs(self, wanted, cache):
        '''Provide automated detection for packages in recommends whitelist.'''
        if self.conf['options']['apt_recommends'] == 'yes':
            return []

        self.log.info('detecting whitelisted recommended packages...')
        rec_module = ConfigObj(os.path.join(self.opts.s, 'packages',
                                            'packages.d', 'recommends'))
        try:
            rec_dict = dict([(p, True) for p in
                             self.__lines2list(rec_module['packages'])])
        except KeyError:
            self.log.debug('rec_dict:')
            return []

        self.log.debug('rec_dict:')
        self.log.debug(rec_dict)

        rec_list = []
        for p in wanted.keys():
            if not p in rec_dict:
                continue
            package = cache[p]
            current = package.current_ver
            if not current:
                versions = package.version_list
                if not versions:
                    continue
                version = versions[0]
                for other_version in versions:
                    if apt_pkg.version_compare(version.ver_str,
                                               other_version.ver_str) < 0:
                        version = other_version
                current = version

            depends = current.depends_list
            list = depends.get('Recommends', [])
            for dependency in list:
                depdone = 0
                for deppart in dependency:
                    if depdone > 0:
                        continue
                    name = deppart.target_pkg.name
                    if name in wanted.keys():
                        depdone = 1
                        continue
                if depdone == 0:
                    name = dependency[0].target_pkg.name
                    dep = cache[name]
                    if dep.current_ver:
                        continue
                    rec_list.append(dep.name)

        self.log.debug('rec_list:')
        self.log.debug(rec_list)
        return rec_list


    def __getSourcePkg(self, pkg, depcache, records):
        '''Get the source package name of a given package.'''
        version = depcache.get_candidate_ver(pkg)

        if not version:
            return None
        file, index = version.file_list.pop(0)
        records.lookup((file, index))

        srcpkg = pkg.name
        srcver = version.ver_str
        if records.source_pkg != "":
            srcpkg = records.source_pkg

        if records.source_ver != "":
            srcver = records.source_ver

        return [srcpkg,srcver]

    def _collectManifest(self, arch):
        '''Collect package and source package URI information from each
        chroot.'''
        chroot = os.path.join(self.temp, arch)
        self.log.info(f'collecting package manifest for {arch}...')

        cache = apt_pkg.Cache(apt.progress.base.OpProgress())
        records = apt_pkg.PackageRecords(cache)
        depcache = apt_pkg.DepCache(cache)

        manifest = dict([(p.name, p.current_ver.ver_str)
                         for p in cache.packages if p.current_ver
                         and not p.name.startswith('cdebootstrap-helper')])
        if 'install' in self.pkgs[arch]:
            manifest.update(self.pkgs[arch]['install'])
        if 'i18n' in self.pkgs[arch]:
            manifest.update(self.pkgs[arch]['i18n'])
        if 'apt' in self.pkgs[arch]:
            manifest.update(self.pkgs[arch]['apt'])
        self.pkgs[arch]['manifest'] = manifest

        if self.opts.B:
            return

        self.log.info(f'querying source package URIs for {arch}...')

        packages = list(manifest.keys())
        packages.sort()
        srcpkg_seen = dict()
        uris = []
        for pkg in packages:
            for kernel in self._detectLinuxVersion(chroot):
                if pkg.endswith('-modules-' + kernel):
                    pkg = pkg[:pkg.find('-modules-' + kernel)]
                    pkg += '-source'

            if pkg.startswith('cdebootstrap-helper'):
                continue

            srcpv = self.__getSourcePkg(cache[pkg], depcache, records)
            srcpkg=srcpv[0]
            srcver=srcpv[1]
            if not srcpkg:
                self.log.critical(f'failed to lookup srcpkg name for {pkg}')
                raise FllError
            self.log.debug(f'{pkg} -> {srcpkg}')

            if srcpkg in srcpkg_seen:
                self.log.debug(f'already processed {srcpkg}, skipping...')
                continue
            else:
                srcpkg_seen[srcpkg] = True

            try:
                u = []
                sources = apt_pkg.SourceRecords()
                sources.restart()
                while sources.lookup(srcpkg):
                    if sources.version == srcver:
                        u.extend([sources.index.archive_uri(sources.files[f][2])
                                for f in range(len(sources.files))])
                self.log.debug(u)
                uris.extend(u)
            except (apt_pkg.Error, SystemError) as e:
                self.log.critical(f'failed to query source uris for {srcpkg}: {e}')
                raise FllError

        uris.sort()
        self.pkgs[arch]['source'] = uris


    def _installPkgs(self, arch, codename):
        '''Install packages.'''
        cache = apt_pkg.Cache(apt.progress.base.OpProgress())
        if cache.ver_file_count < 200:
            self.log.info(f'installPkgs cache had {cache.ver_file_count}')
            cache = apt_pkg.Cache(apt.progress.base.OpProgress())
            self.log.info(f'installPkgs cache has {cache.ver_file_count}')

        pkgs_base = [pkg.name for pkg in cache.packages if pkg.current_ver]
        pkgs_want = self.__filterList(pkgs_base + self._getPackageList(arch))
        pkgs_dict = dict([(pkg, True) for pkg in pkgs_want])
        pkgs_want = self.__filterList(list(pkgs_dict.keys()) +
                                      self._detectRecommendedPkgs(pkgs_dict, cache))
        pkgs_dict = dict([(pkg, True) for pkg in pkgs_want])
        i18n_list = self.__lines2list(self.conf['packages']['i18n'])
        pkgs_want = self.__filterList(list(pkgs_dict.keys()) +
                                      self._detectLocalePkgs(i18n_list, pkgs_dict, cache))
        pkgs_dict = dict([(pkg, True) for pkg in pkgs_want])
        pkgs_had = list()

        if not self.opts.D:
            self.log.info(f'installing packages in chroot: {arch}')
            self._aptGetInstall(arch, pkgs_want)


    def _postInst(self, arch):
        '''Run package module postinst scripts in a chroot.'''
        if self.opts.D:
            return
        chroot = os.path.join(self.temp, arch)

        self.log.info(f'performing post-install tasks in chroot: {arch}')

        # reset /etc/resolv.conf (systemd-resolved clobbered our settings)
        os.unlink(os.path.join(chroot, 'etc/resolv.conf'))
        shutil.copy('/etc/resolv.conf', os.path.join(chroot, 'etc'))

        for script in self._getPostinstList(arch):
            sname = os.path.basename(script)
            try:
                shutil.copy(script, os.path.join(chroot, 'tmp'))
                os.chmod(os.path.join(chroot, 'tmp', sname), 0o755)
            except:
                self.log.exception(f'error preparing postinst script: {sname}')
                raise FllError

            cmd = f'/tmp/{sname} postinst'
            self._execInChroot(arch, cmd.split())
            os.unlink(os.path.join(chroot, 'tmp', sname))


    def _zerologs(self, arch, dirname, filenames):
        '''Truncate all log files.'''
        chroot = os.path.join(self.temp, arch)
        chrootdir = dirname.partition(chroot)[2]

        for f in filenames:
            if not os.path.isfile(os.path.join(dirname, f)):
                continue
            self._writeFile(arch, os.path.join(chrootdir, f))


    def _cleanChroot(self, arch):
        '''Remove unwanted content from a chroot.'''
        self.log.info(f'purging unwanted content from chroot: {arch}')
        chroot = os.path.join(self.temp, arch)

        cmd = 'dpkg --purge fll-live-initramfs'
        self._execInChroot(arch, cmd.split())
        self._execInChroot(arch, 'apt-get clean'.split())
        self._execInChroot(arch, 'dpkg --clear-avail'.split())

        for dirpath, dirnames, files in os.walk(os.path.join(chroot, 'var/log')):
            self._zerologs(arch, dirpath, files)


    def _chrootSquashfs(self, arch):
        '''Make squashfs filesystem image of chroot.'''
        self.log.info(f'creating squashfs filesystem of chroot: {arch}')
        chroot = os.path.join(self.temp, arch)

        image_file = self._getDistroImageFile(arch)
        if self.opts.D:
            cmd = ['touch', image_file]
            self._execInChroot(arch, cmd)
            return

        cmd = ['mksquashfs', '.', image_file, '-noappend']

        exclude_file = os.path.join(self.opts.s, 'data', 'fll_sqfs_exclusion')
        shutil.copy(exclude_file, os.path.join(chroot, 'tmp'))
        cmd.extend(['-wildcards', '-ef', '/tmp/fll_sqfs_exclusion'])

        # set compression algorithm for squashfs-tools >= 4.1
        squashfs_comp = self.conf['options'].get('squashfs_comp')
        if squashfs_comp in ['gzip', 'lz4', 'lzo', 'xz', 'zstd']:
            self.log.info(f'using squashfs({squashfs_comp})...')
            cmd.extend(['-comp', squashfs_comp])
            if squashfs_comp == 'xz':
                if arch == 'amd64' or arch == 'i386':
                    cmd.extend(['-Xbcj', 'x86'])
        
        if self.opts.l or self.opts.q:
            cmd.append('-no-progress')

        # can only be last argument
        cmd.extend(['-e', image_file])

        self._execInChroot(arch, cmd)


    def _stageArch(self, arch):
        '''Stage files for an arch for final genisofs.'''
        self.log.info('staging live %s media...' % arch)
        chroot = os.path.join(self.temp, arch)
        boot_dir = os.path.join(self.temp, 'staging', 'boot')

        image_file = os.path.join(chroot, self._getDistroImageFile(arch))
        image_dir = os.path.join(self.temp, 'staging',
                                 self.conf['distro']['FLL_IMAGE_DIR'])
        try:
            os.chmod(image_file, 0o644)
            shutil.move(image_file, image_dir)
        except IOError:
            self.log.exception('failed to move squashfs image to staging dir')
            raise FllError

        if self.opts.D:
            return

        kvers = self._detectLinuxVersion(chroot)
        for kernel in kvers:
            initrd = os.path.join(chroot, 'boot', f'initrd.img-{kernel}')
            if os.path.isfile(initrd):
                self.log.debug(f'copying {initrd} to staging dir')
                shutil.copy(initrd, boot_dir)
            else:
                self.log.critical('could not find initramfs image to ' +
                                  'copy to staging dir.')
                raise FllError
            
            images = glob.glob(os.path.join(chroot, 'boot', f'vmlinu*-{kernel}'))
            if len(images) == 1:
                self.log.debug(f'copying {images[0]} to staging dir')
                shutil.copy(images[0], boot_dir)
            else:
                self.log.critical('could not find linux kernel image to ' +
                                  'copy to staging dir.')
                raise FllError

        if os.path.isdir(os.path.join(chroot, 'usr/lib/grub')):
            data_dir = os.path.join(self.opts.s, 'data')
            grub_dir = os.path.join(boot_dir, 'grub')
            if not os.path.isdir(grub_dir):
                os.makedirs(grub_dir, 0o755)
            if not os.path.isfile(os.path.join(grub_dir, 'grub.cfg')):
              shutil.copy(os.path.join(self.opts.s, 'data/grub.cfg'), grub_dir)
              shutil.copy(os.path.join(chroot, 'usr/share/grub/unicode.pf2'), grub_dir)
              shutil.copytree(os.path.join(self.opts.s, 'data/locales'), os.path.join(grub_dir, 'locales'))
              shutil.copytree(os.path.join(self.opts.s, 'data/tz'), os.path.join(grub_dir, 'tz'))
              theme_dir = f'themes/{self.conf['distro']['FLL_GFXBOOT_THEME']}'
              if os.path.isfile(os.path.join(chroot, f'usr/share/grub/{theme_dir}/theme.txt')):
                  shutil.copytree(os.path.join(chroot, f'usr/share/grub/{theme_dir}'), os.path.join(grub_dir, theme_dir))

            gfile_dir = glob.glob(os.path.join(chroot, 'usr/lib/grub/*-pc'))[0]

            grub2_modules = glob.glob(os.path.join(gfile_dir, '*.mod'))
            if len(grub2_modules) > 0:
                gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                          if f.endswith('.mod') or f.endswith('.img')
                          or f.endswith('.lst')]
                gfiles.append(os.path.join(chroot, 'tmp/grub_eltorito'))
            else:
                gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                          if f.startswith('stage2') or f.startswith('iso9660')]

            if len(gfiles) > 0:
                self.log.debug('copying grub stage files to boot dir')
                grub_dir = os.path.join(boot_dir, 'grub', 'i386-pc')
                if not os.path.isdir(grub_dir):
                    os.makedirs(grub_dir, 0o755)
            else:
                self.log.exception('grub stage files not found')
                raise FllError

            for file in gfiles:
                try:
                    shutil.copy(file, grub_dir)
                except IOError:
                    self.log.exception('failed to copy grub file to staging dir')
                    raise FllError

            # efi
            efitypes = { 'x86_64-efi':'bootx64','i386-efi':'bootia32' }
            have_efi = False
            for efitype in (list(efitypes.keys())):
                gfile_dir = os.path.join(chroot, f'usr/lib/grub/{efitype}')
                if os.path.isdir(gfile_dir):
                    have_efi = True
                    gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                            if f.endswith('.mod') or f.endswith('.lst')]
                    gfiles.append(os.path.join(chroot,'/usr/share/grub/unicode.pf2'))
                    if len(gfiles) > 0:
                        self.log.debug(f'copying grub {efitype} stage files to boot dir')
                        grub_dir = os.path.join(boot_dir, 'grub', efitype)
                        if not os.path.isdir(grub_dir):
                            os.makedirs(grub_dir, 0o755)
                    for file in gfiles:
                        try:
                            shutil.copy(file, grub_dir)
                        except IOError:
                            self.log.exception('failed to copy grub efi file to staging dir')
                            raise FllError
                    efi_dir = os.path.join(self.temp, 'staging/efi/boot')
                    if not os.path.isdir(efi_dir):
                        os.makedirs(efi_dir, 0o755)
                    try:
                        shutil.copy(os.path.join(chroot, f'tmp/efi/boot/{efitypes[efitype]}.efi'), efi_dir)
                    except IOError:
                        self.log.exception(f'failed to copy efi {efitype} boot files to staging dir')
                        raise FllError
            if have_efi and not os.path.isfile(os.path.join(self.temp, 'staging', 'efi.img')):
                try:
                    cmd = [ 'mformat', '-C', '-f', '2880', '-L', '16', '-i', '/tmp/efi.img', '::' ]
                    self._execInChroot(arch, cmd)
                    cmd = [ 'mcopy', '-s', '-i', '/tmp/efi.img', '/tmp/efi_img/efi', '::/' ]
                    self._execInChroot(arch, cmd)
                    shutil.copy(os.path.join(chroot, 'tmp/efi.img'), os.path.join(self.temp, 'staging'))
                    shutil.copy(os.path.join(chroot, 'tmp/iso_uuid'), os.path.join(self.temp, 'staging'))
                    uuid_dir = os.path.join(chroot, 'tmp/uuid')
                    ufiles = [os.path.join(uuid_dir, f) for f in os.listdir(uuid_dir)]
                    for file in ufiles:
                        shutil.copy(file, os.path.join(boot_dir, 'grub'))
                except IOError:
                    self.log.exception('failed to create efi.img')
                    raise FllError

        memtest = os.path.join(chroot, 'boot', 'memtest86+.bin')
        memtest_out = os.path.join(boot_dir, 'memtest')
        if os.path.isfile(memtest):
            self.log.debug('copying memtest86+ to boot dir')
            try:
                shutil.copy(memtest, memtest_out)
            except IOError:
                self.log.exception('failed to copy memtest86+ to staging dir')
                raise FllError


    def _writeGrubCfg(self, stage_dir, boot_dir, grub_dir, kvers,
                      timeout, cmdline):
        '''Write grub.cfg for live media.'''
        self.log.info('writing grub.cfg for live media')

        grubcfg = open(os.path.join(grub_dir, 'kernels.cfg'), 'w')
        distro = self.conf['distro']['FLL_DISTRO_NAME']
        
        kcount = { '686': 0, 'amd': 0, 'pae': 0, '486': 0, 'ppc': 0 }
        for kernel in kvers:
            cpu = kernel[kernel.rfind('-') + 1:]
            vmlinuz = f'vmlinuz-{kernel}'
            initrd = f'initrd.img-{kernel}'

            for filename in [vmlinuz, initrd]:
                if not os.path.isfile(os.path.join(boot_dir, filename)):
                    self.log.critical(f'{filename} was not found in {boot_dir}')
                    raise FllError

            if cpu[0:3] == 'amd':
              grubcfg.write('if cpuid -l; then\n')
            grubcfg.write('havekernel="Y"\n')
            grubcfg.write('title=""\n')
            grubcfg.write('for kopt in %s $kopts boot=fll %s; do\n' % (vmlinuz[8:], cmdline))
            grubcfg.write(' if [ -n "$title" ] ; then\n')
            grubcfg.write('  title="$title $kopt";\n')
            grubcfg.write(' else\n')
            grubcfg.write('  title="$kopt";\n')
            grubcfg.write(' fi;\n')
            grubcfg.write('done\n')
            grubcfg.write('menuentry --class=%s.%s \"$title\" {' % (distro, cpu))
            grubcfg.write('# set arguments above with the editor\n')
            grubcfg.write('linux /boot/vmlinuz-$@\n')
            grubcfg.write('initrd /boot/%s\n' % initrd)
            grubcfg.write('}\n')
            if cpu[0:3] == 'amd':
              grubcfg.write('fi\n')
            kcount[cpu[0:3]] = kcount[cpu[0:3]] + 1
        grubcfg.write('if [ "${havekernel}" != "Y" ]; then\n')
        grubcfg.write('  menuentry --class=find.none "NO SUITABLE KERNELS AVAILABLE" {echo $@')
        grubcfg.write('  echo "There are no kernels suitable for this machine available."\n')
        grubcfg.write('  echo ""\n')
        grubcfg.write('  if ! cpuid -l; then\n')
        grubcfg.write('    echo "This machine is NOT 64bit capable."\n')
        grubcfg.write('    for kk in /boot/vmlinu*.*86; do\n')
        grubcfg.write('      if [ "$kk" != "/boot/vmlinu*.*86" ]; then\n')
        grubcfg.write('        have32="true"\n')
        grubcfg.write('      fi\n')
        grubcfg.write('    done\n')
        grubcfg.write('    if [ "${have32}" != "true" ]; then\n')
        grubcfg.write('      echo "There are no 32bit kernels available"\n')
        grubcfg.write('      echo "It appears you are trying to boot a 64bit release on a 32bit machine"\n')
        grubcfg.write('      echo "This cannot work!"\n')
        grubcfg.write('    fi\n')
        grubcfg.write('  fi\n')
        grubcfg.write('  echo "Press Escape to return to the main menu"\n')
        grubcfg.write('  sleep --interruptible 9999\n')
        grubcfg.write('  menu_reload\n')
        grubcfg.write('  }\n')
        grubcfg.write('fi\n')

        grubcfg.close()
        
        self.log.debug('writing loopback.cfg for live media')
        grubcfg = open(os.path.join(grub_dir, 'loopback.cfg'), 'w')
        grubcfg.write('source /boot/grub/grub.cfg\n')
        grubcfg.close()
        
        self.log.debug('writing variable.cfg for live media')
        grubcfg = open(os.path.join(grub_dir, 'variable.cfg'), 'w')
        grub_theme = f'grub/themes/{self.conf['distro']['FLL_GFXBOOT_THEME']}/theme.txt'
        if os.path.isfile(os.path.join(boot_dir, grub_theme)):
            grubcfg.write(f'grub_theme=/boot/{grub_theme}\n')
        grubcfg.write(f'timeout={timeout}\n')
        grubcfg.close()


    def _configBootKvers(self,stage_dir):
        kvers = self._detectLinuxVersion(stage_dir)
        if len(kvers) < 1:
            self.log.critical('failed to find linux kernel image to include in boot conf')
            raise FllError
        return kvers

    def _configBootTimeout(self):
        timeout = self.conf['options'].get('boot_timeout')
        if not timeout:
            timeout = '-1'
        return timeout

    def _configBootCmdline(self):
        cmdline =  self.conf['options'].get('boot_cmdline')
        if not cmdline:
            cmdline = 'systemd.show_status=1 quiet splash'
        return cmdline

    def configureGrub(self):
        '''Write final GRUB configuration for live media.'''
        stage_dir = os.path.join(self.temp, 'staging')
        boot_dir = os.path.join(stage_dir, 'boot')
        grub_dir = os.path.join(boot_dir, 'grub')

        if not os.path.isdir(grub_dir):
            return
        self.log.debug('writing grub config for live media')

        kvers = self._configBootKvers(stage_dir)
        timeout = self._configBootTimeout()
        cmdline =  self._configBootCmdline()

        self._writeGrubCfg(stage_dir, boot_dir, grub_dir, kvers,
                           timeout, cmdline)


    def __md5sum(self, filename):
        '''Calculate md5sum of a file and return it.'''
        return apt_pkg.Hashes(open(filename, 'rb')).hashes.find('MD5Sum').hashvalue

    def __hashsums(self, filename):
        '''Calculate hashsums of a file and return it.'''
        hashsums = apt_pkg.Hashes(open(filename, 'rb')).hashes
        return hashsums.find('MD5Sum').hashvalue, hashsums.find('SHA256').hashvalue, \
            hashsums.find('SHA512').hashvalue


    def _md5sums(self, base, dirpath, filenames):
        '''Function given to os.path.walk of self.writeMd5Sums().'''
        for f in filenames:
            filepath = os.path.join(dirpath, f)
            filename = filepath.partition(base)[2].lstrip('/')

            if not os.path.isfile(filepath) or f == 'md5sums':
                continue
            if dirpath.endswith('grub') and f.find('stage') >= 0:
                continue
            if f.find('grub_eltorito') >= 0:
                continue
            if f.find('iso_uuid') >= 0:
                continue

            md5sums = None
            try:
                md5sums = open(os.path.join(base, 'md5sums'), 'a')
                md5sums.write(f'{self.__md5sum(filepath)} *{filename}\n')
            except IOError:
                self.log.exception('failed to write md5sums file')
                raise FllError
            finally:
                if md5sums:
                    md5sums.close()


    def writeMd5Sums(self):
        '''Calculate md5sums of major release contents.'''
        self.log.info('calculating md5sums of live media...')
        stage = os.path.join(self.temp, 'staging')
        for dirpath, dirnames, filenames in os.walk(stage):
            self._md5sums(stage, dirpath, filenames)

    def _signFile(self, filename):
        '''Sign a file with hashkey if available.'''
        if self.opts.k:
            self.log.info(f'signing file: {filename}')
            cmd = ['gpg', '-s', '--default-key']
            cmd.append(self.opts.k)
            cmd.append(filename)
            self._execCmd(cmd)
        else:
            self.log.info(f'not signing file (no key given): {filename}')

    def __archManifest(self, arch):
        '''Write manifest information to file.'''
        pkgs = list(self.pkgs[arch]['manifest'].keys())
        pkgs.sort(key=len)
        maxlen = len(pkgs[-1])
        pkgs.sort()

        return [f'{pkg.ljust(maxlen)} {self.pkgs[arch]['manifest'][pkg]}\n'
                for pkg in pkgs]


    def _writeManifests(self, filename):
        '''Write package manifest lists.'''
        archs = list(self.conf['archs'].keys())
        for arch in archs:
            manifest_name = f'{filename}.{arch}.manifest'

            manifest_file = os.path.join(self.opts.o, manifest_name)

            manifest = None
            try:
                manifest = open(manifest_file, 'w')
                manifest.writelines(self.__archManifest(arch))
            except IOError:
                self.log.exception(f'failed to write file: {manifest_file}')
                raise FllError
            finally:
                if manifest:
                    manifest.close()
                    os.chown(manifest_file, self.opts.u, self.opts.g)


    def _writeSources(self, filename):
        '''Write source URI lists.'''
        sources_list = []
        archs = list(self.conf['archs'].keys())
        for arch in archs:
            sources_list.extend(self.pkgs[arch]['source'])
        sources_list = self.__filterList(sources_list, dup_warn = False)

        sources_name = filename + '.sources'
        sources_file = os.path.join(self.opts.o, sources_name)

        sources = None
        try:
            sources = open(sources_file, 'w')
            sources.writelines([f'{s}\n' for s in sources_list])
        except IOError:
            self.log.exception(f'failed to write filename: {sources_file}')
            raise FllError
        finally:
            if sources:
                sources.close()
                os.chown(sources_file, self.opts.u, self.opts.g)

        cached = dict()
        for r in self.conf['repos']:
            if self.conf['repos'][r].get('cached'):
                cached_uri = self.conf['repos'][r]['cached']
                uri = self.conf['repos'][r]['uri']
                cached[cached_uri.rstrip('/')] = uri.rstrip('/')

        if len(list(cached.keys())) > 0:
            os.rename(sources_file, sources_file + '-cached')
        else:
            return

        sources = None
        try:
            sources = open(sources_file, 'w')
            for s in sources_list:
                for c in list(cached.keys()):
                    if s.startswith(c):
                        s = s.replace(c, cached[c], 1)
                        break
                sources.write('%s\n' % s)
        except IOError:
            self.log.exception('failed to write filename: %s' % sources_file)
            raise FllError
        finally:
            if sources:
                sources.close()
                os.chown(sources_file, self.opts.u, self.opts.g)


    def genLiveMedia(self):
        '''Generate live media iso image.'''
        stage = os.path.join(self.temp, 'staging')

        distro_name = self.conf['distro']['FLL_DISTRO_NAME']
        fll_image_dir = self.conf['distro']['FLL_IMAGE_DIR']
        fll_image_file = self.conf['distro']['FLL_IMAGE_FILE']

        iso_name = self._getDistroMediaName() + '.iso'

        iso_file = os.path.join(self.opts.o, iso_name)
        md5_file = iso_file + '.md5'
        sha256_file = iso_file + '.sha256'
        sha512_file = iso_file + '.sha512'

        xorriso_cmd = 'xorriso -report_about HINT -as mkisofs -graft-points  -pad -l'
        gpthybrid_cmd = os.path.join(self.opts.s, 'gpthybrid')

        if self.opts.v:
            xorriso_cmd += ' -v'
            gpthybrid_cmd += ' --verbose'

        if os.path.isdir(os.path.join(stage, 'boot/grub')):
            xorriso_cmd += ' -no-emul-boot -boot-load-size 4 -boot-info-table'
            gpthybrid_cmd += f' --label {self.uuid} --iso {iso_file}'
            if os.path.isfile(os.path.join(stage,
                                           'boot/grub/i386-pc/grub_eltorito')):
                xorriso_cmd += ' -b boot/grub/i386-pc/grub_eltorito --grub2-boot-info'
                xorriso_cmd += f' --grub2-mbr {os.path.join(stage, 'boot/grub/i386-pc/boot_hybrid.img')}'
                for arch in list(self.conf['archs'].keys()):
                    if os.path.isfile(os.path.join(stage, fll_image_dir,
                                                   self._getDistroImageFile(arch))):
                        gpthybrid_cmd += f' {os.path.join(fll_image_dir, self._getDistroImageFile(arch))}'
            else:
                self.log.critical('failed to find grub El Torito image file')
                raise FllError
        else:
            self.log.critical('grub is required to boot live media')
            raise FllError

        xorriso_cmd += f' --modification-date={self.uuid.replace("-","")}'
        if os.path.isfile(os.path.join(stage, 'efi.img')):
            xorriso_cmd += ' --efi-boot efi.img -efi-boot-part --efi-boot-image'
            gpthybrid_cmd += ' efi.img'

        xorriso_cmd += f' --protective-msdos-label -V {distro_name[:32]}'
        if os.path.isdir(os.path.join(stage, 'boot')):
            xorriso_cmd += ' --sort-weight 0 / --sort-weight 1 /boot'
            if os.path.isdir(os.path.join(stage, 'boot/grub')):
                xorriso_cmd += ' --sort-weight 2 /boot/grub'
        xorriso_cmd += ' -x iso_uuid -x genisoimage.sort'
        xorriso_cmd += f' -o {iso_file} {stage}'

        self.log.info('generating iso image of live media...')
        self._execCmd(xorriso_cmd.split())

        self.log.info('converting to hybrid iso...')
        self._execCmd(gpthybrid_cmd.split())

        os.chown(iso_file, self.opts.u, self.opts.g)

        self.log.info('calculating hashsums of live media iso image...')
        md5 = None
        sha256 = None
        sha512 = None
        try:
            md5 = open(md5_file, 'w')
            sha256 = open(sha256_file, 'w')
            sha512 = open(sha512_file, 'w')
            md5sum, sha256sum, sha512sum = self.__hashsums(iso_file)
            md5.write("%s *%s\n" % (md5sum, os.path.basename(iso_file)))
            sha256.write("%s *%s\n" % (sha256sum, os.path.basename(iso_file)))
            sha512.write("%s *%s\n" % (sha512sum, os.path.basename(iso_file)))
        except IOError:
            self.log.exception('failed to write hashsums files')
            raise FllError
        finally:
            if md5:
                md5.close()
                os.chown(md5_file, self.opts.u, self.opts.g)
                if self.opts.k:
                    self.log.info('signing md5 hash...')
                    self._signFile(md5_file)
                    os.chown(md5_file + '.gpg', self.opts.u, self.opts.g)
            if sha256:
                sha256.close()
                os.chown(sha256_file, self.opts.u, self.opts.g)
                if self.opts.k:
                    self.log.info('signing sha256 hash...')
                    self._signFile(sha256_file)
                    os.chown(sha256_file + '.gpg', self.opts.u, self.opts.g)
            if sha512:
                sha512.close()
                os.chown(sha512_file, self.opts.u, self.opts.g)
                if self.opts.k:
                    self.log.info('signing sha512 hash...')
                    self._signFile(sha512_file)
                    os.chown(sha512_file + '.gpg', self.opts.u, self.opts.g)

        self._writeManifests(os.path.splitext(iso_file)[0])
        if not self.opts.B:
            self._writeSources(os.path.splitext(iso_file)[0])

        for f in glob.glob('%s*' % os.path.splitext(iso_file)[0]):
            self.log.info(f)

        if self.opts.U:
            self._execCmd(["update-grub"])


    def buildChroots(self):
        '''Main loop to call all chroot building functions.'''
        archs = list(self.conf['archs'].keys())
        codename = self.opts.C
        for arch in archs:
            self._bootStrap(arch)
            self._dpkgAddDivert(arch)
            self._defaultConffiles(arch)
            self._distroDefaults(arch)
            self._preseedDebconf(arch)
            self._primeApt(arch)
            self._installPkgs(arch, codename)
            self._postInst(arch)
            self._collectManifest(arch)
            self._finalConffiles(arch)
            self._dpkgUnDivert(arch)
            self._makeInitramfs(arch)
            self._cleanChroot(arch)
            self._chrootSquashfs(arch)
            self._stageArch(arch)
            self._nukeChroot(arch)


    def main(self):
        '''Main loop.'''
        self.checkOpts()
        self.parseConf()
        self.parsePkgProfile()
        self.stageBuildArea()

        if self.opts.n:
            sys.exit(0)

        self.buildChroots()
        self.configureGrub()
        self.writeMd5Sums()
        self.genLiveMedia()

        duration = int(time.perf_counter() - self.time)
        m, s = divmod(duration, 60)
        self.log.info(f'build duration was {m:d} minutes and {s:02d} seconds')


if __name__ == '__main__':
    cli = optparse.OptionParser(usage = 'fll -c <config file> [-b <directory> ' +
                              '-o <directory> -l <file>] [-BdDpqv]')

    cli.add_option('-a', '--arch', dest = 'a', action = 'store',
                   type = 'string', metavar = '<arch>',
                   help = 'Build architecture, overrides config file.')

    cli.add_option('-b', '--build', dest = 'b', action = 'store',
                   type = 'string', metavar = '<directory>',
                   help = 'Build directory. A large amount of free space ' +
                   'is required.')

    cli.add_option('-B', '--binary', dest = 'B', action = 'store_true',
                   help = 'Do binary build only. Disable generation of ' +
                   'URI lists. Default: %default')

    cli.add_option('-c', '--config', dest = 'c', action = 'store',
                   type = 'string', metavar = '<config file>',
                   help = 'Configuration file. This option may be used ' +
                   'more than once to process multiple configurations. ' +
                   'A configuration file must be specified.')

    cli.add_option('-d', '--debug', dest = 'd', action = 'store_true',
                   help = 'Enable debug mode. Extra output will be ' +
                   'to assist in development. Default: %default')

    cli.add_option('-D', '--dummy', dest = 'D', action = 'store_true',
                   help = 'Enable dummy mode. Download only ' +
                   'and no squashfs. Default: %default')

    cli.add_option('-g', '--gid', dest = 'g', action = 'store',
                   type = 'int', metavar = '<group id>',
                   help = optparse.SUPPRESS_HELP)

    cli.add_option('-k', '--hashkey', dest = 'k', action = 'store',
                   type = 'string', metavar = '<key id>', help = 'Set key ' +
                   'to sign MD5 and SHA256 hashes of the generated ISOs.')

    cli.add_option('-l', '--log', dest = 'l', action = 'store',
                   type = 'string', metavar = '<file>',
                   help = 'Log debug output to file. Note that when ' +
                   'logging is enabled, output to the console is buffered.')

    cli.add_option('-n', '--non-root', dest = 'n', action = 'store_true',
                   help = optparse.SUPPRESS_HELP)

    cli.add_option('-o', '--output', dest = 'o', action = 'store',
                   type = 'string', metavar = '<directory>',
                   help = 'Output directory, where the product of this ' +
                   'program will be generated.')

    cli.add_option('-p', '--profile', dest = 'p', action = 'store',
                   type = 'string', metavar = '<profile>',
                   help = 'Package profile, overrides config file.')

    cli.add_option('-P', '--preserve', dest = 'P', action = 'store_true',
                   help = 'Preserve build directory. Disable automatic ' +
                   'cleanup of the build area at exit.')

    cli.add_option('-q', '--quiet', dest = 'q', action = 'store_true',
                   help = 'Enable quiet mode. Only high priority messages ' +
                   'will be generated.')

    cli.add_option('-s', '--share', dest = 's', action = 'store',
                   type = 'string', metavar = '<directory>',
                   help = optparse.SUPPRESS_HELP)

    cli.add_option('-u', '--uid', dest = 'u', action = 'store',
                   type = 'int', metavar = '<user id>',
                   help = optparse.SUPPRESS_HELP)

    cli.add_option('-U', '--update-grub', dest = 'U', action = 'store_true',
                   help = 'Execute update-grub after generating iso media.')

    cli.add_option('-v', '--verbose', dest = 'v', action = 'store_true',
                   help = 'Enable verbose mode. All messages will be ' +
                   'generated, such as announcing current operation.')

    cli.set_defaults(b = None, B = False, d = False, D = False, g = os.getgid(),
                     k = None, l = None, n = False, o = None, p = None,
                     P = False, q = False, s = None, u = os.getuid(), v = False)

    options = cli.parse_args()[0]

    try:
        fll = FLLBuilder(options)
        fll.main()
    except KeyboardInterrupt:
        pass
    except FllError:
        sys.exit(1)
