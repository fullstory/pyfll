#!/usr/bin/python3 -tt
# -*- coding: utf-8 -*-

__author__    = 'Kel Modderman'
__copyright__ = '(C) 2008-2024 Kel Modderman <kelvmod@gmail.com>'
__license__   = 'GPLv2 or any later version'

from configobj import ConfigObj
from io import open
from subprocess import *
import apt_pkg
import apt
import atexit
import datetime
import fileinput
import functools
import glob
import logging
import optparse
import os
import sys
import shutil
import signal
import stat
import tempfile

def restore_sigpipe():
    """Convenience function so that subprocess may be executed with
    SIGPIPE restored to default (http://bugs.python.org/issue1652)."""
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)

FLL_LOCALE_DEFAULTS = {
    'be': 'be_BY',
    'cs': 'cs_CZ',
    'da': 'da_DK',
    'en': 'en_US',
    'el': 'el_GR',
    'ga': 'ga_IE',
    'he': 'he_IL',
    'ja': 'ja_JP',
    'ko': 'ko_KR',
    'nb': 'nb_NO',
    'nn': 'nn_NO',
    'pt': 'pt_BR',
    'sl': 'sl_SI',
    'zh': 'zh_CN'
}


class FllLocalesError(Exception):
    """
    An FllError class for use by FllLocales.
    """
    pass


class FllLocales(object):
    """
    A class which provides the ability to determine lists of locale specific
    Debian packages using it's detect_locale_packages method.

    Arguments:
    cache    - an apt_pkg cache object
    packages - a list or dict of package names which are installed, or are
               going to be installed. Locale specific packages are selected
               for packages in this data structure.
    map      - a dict which maps package names with a list of package prefixes
               from which the locale string pattern matching can be used
               to match locale support packages. The prefered input for map is:
               ConfigObj('data/fll-locales-pkg-map').
    """
    def __init__(self, cache, packages, map):
        self.loc_pkgs_set = set()
        for pkg in cache.packages:
            if not pkg.version_list:
                continue
            if pkg.name not in packages:
                continue
            for loc_pkg in list(map.keys()):
                if pkg.name == loc_pkg:
                    loc_pkg_prefix_list = map.get(loc_pkg)
                    for loc_pkg_prefix in loc_pkg_prefix_list:
                        self.loc_pkgs_set.add(loc_pkg_prefix)
                    break

        self.loc_pkgs_list_dict = dict()
        for loc_pkg in self.loc_pkgs_set:
            self.loc_pkgs_list_dict[loc_pkg] = list()
        for pkg in cache.packages:
            if not pkg.version_list:
                continue
            for loc_pkg in self.loc_pkgs_set:
                if pkg.name.startswith(loc_pkg + '-'):
                    self.loc_pkgs_list_dict[loc_pkg].append(pkg.name)

    def __compute_locale_loc_suf_list(self, locale):
        """
        Compute a list of locale package name suffixes. The sequence of
        suffixes are in preferential order, the lowest index being most
        preferential.

        This is a very private method, used by detect_locale_packages.

        Arguments:
        locale - a locale string (eg. en_AU, pt_PT etc.)
        """
        loc_suf_list = list()
        try:
            ll, cc = locale.lower().split('_')
        except ValueError as e:
            raise FllLocalesError(e)
        loc_suf_list.append(ll + '-' + cc)
        loc_suf_list.append(ll + cc)
        loc_suf_list.append(ll)

        default = FLL_LOCALE_DEFAULTS.get(ll)
        if default and default != locale:
            try:
                ll, cc = default.lower().split('_')
            except ValueError as e:
                raise FllLocalesError(e)
            loc_suf_list.append(ll + '-' + cc)
            loc_suf_list.append(ll + cc)
        else:
            loc_suf_list.append(ll + '-' + ll)
            loc_suf_list.append(ll + ll)

        if ll != 'en':
            loc_suf_list.append('i18n')

        return loc_suf_list

    def detect_locale_packages(self, locale):
        """
        Process the data structures created at FllLocales instantiation and
        return a list of package names which are the likely best candidates
        for the locale string given as argument.

        Arguments:
        locale - a locale string (eg. en_AU, pt_PT etc.)
        """
        suffixes = self.__compute_locale_loc_suf_list(locale)

        loc_pkg_dict = dict()
        for pkg in self.loc_pkgs_set:
            loc_pkgs_list = self.loc_pkgs_list_dict.get(pkg)
            if not loc_pkgs_list:
                continue
            if pkg not in loc_pkg_dict:
                loc_pkg_dict[pkg] = dict()
            for loc_pkg in loc_pkgs_list:
                for idx, suf in enumerate(suffixes):
                    if loc_pkg == '-'.join([pkg, suf]):
                       loc_pkg_dict[pkg][idx] = loc_pkg

        packages = list()
        for pkg in self.loc_pkgs_set:
            pkg_candidates = loc_pkg_dict.get(pkg)
            if not pkg_candidates:
                continue
            best = min(pkg_candidates)
            packages.append(pkg_candidates[best])

        return packages


class FllError(Exception):
    '''A generic error handler that does nothing.'''
    pass


class FLLBuilder(object):
    env = {'LANGUAGE': 'C', 'LC_ALL': 'C', 'LANG' : 'C', 'HOME': '/root',
           'PATH': '/usr/sbin:/usr/bin:/sbin:/bin', 'SHELL': '/bin/bash',
           'DEBIAN_FRONTEND': 'noninteractive', 'DEBIAN_PRIORITY': 'critical',
           'DEBCONF_NOWARNINGS': 'yes'}

    diverts = ['/usr/sbin/policy-rc.d',
               '/usr/sbin/modprobe',
               '/usr/sbin/insmod',
               '/usr/sbin/update-grub',
               '/usr/sbin/update-initramfs']


    def __init__(self, options):
        '''Accept options dict, setup logging.'''
        self.opts = options
        self.conf = None
        self.temp = None

        self.log = logging.getLogger('log')
        self.log.setLevel(logging.DEBUG)

        self.time = datetime.datetime.now(datetime.UTC)
        self.uuid = self.time.strftime('%Y-%m-%d-%H-%M-%S-00')
        self.timestamp = self.time.strftime('%Y%m%d%H%M')

    def __filterList(self, alist, dup_warn = True):
        '''Return a list containing no duplicate items given a list that
        may have duplicate items.'''

        d = dict()
        for l in alist:
            if l in d and dup_warn:
                self.log.debug('duplicate: %s' % l)
            else:
                d[l] = True

        blist = list(d.keys())
        blist.sort()

        return blist


    def __lines2list(self, lines):
        '''Return a list of stripped strings given a group of line
        separated strings'''
        return [s.strip() for s in lines.splitlines()
                if s.strip() and not s.lstrip().startswith('#')]


    def __isexecutable(self, file):
        '''Return True is file is executable, False otherwise.'''
        try:
            mode = os.stat(file)[stat.ST_MODE]
        except OSError:
            return False

        if stat.S_ISREG(mode) and mode & stat.S_IXUSR:
            return True
        else:
            return False


    def __prepDir(self, dir):
        '''Set up working directories.'''
        if not os.path.isdir(dir):
            try:
                os.makedirs(dir)
                os.chown(dir, self.opts.u, self.opts.g)
            except:
                self.log.exception('failed to create dir: %s' % dir)
                raise FllError

        return os.path.realpath(dir)


    def __initLogger(self, lvl):
        '''Set up the logger.'''
        fmt = logging.Formatter('%(asctime)s %(levelname)-5s - %(message)s')
        out = logging.StreamHandler()
        out.setFormatter(fmt)
        out.setLevel(lvl)
        self.log.addHandler(out)


    def __initLogFile(self, file):
        '''Set up a log file.'''
        file = os.path.realpath(file)
        dir = os.path.dirname(file)
        self.__prepDir(dir)

        try:
            fmt = logging.Formatter('%(asctime)s %(levelname)-5s ' +
                                     '%(message)s')
            logfile = logging.FileHandler(filename = file, mode = 'w')
            logfile.setFormatter(fmt)
            logfile.setLevel(logging.DEBUG)
            self.log.addHandler(logfile)
            os.chown(file, self.opts.u, self.opts.g)
        except:
            self.log.exception('failed to setup logfile')
            raise FllError


    def checkOpts(self):
        '''Check and provide default class options.'''
        if self.opts.d:
            self.__initLogger(logging.DEBUG)
        else:
            self.__initLogger(logging.INFO)

        if self.opts.l:
            self.__initLogFile(self.opts.l)

        if self.opts.c:
            if os.path.isfile(self.opts.c):
                self.opts.c = os.path.realpath(self.opts.c)
            else:
                self.log.critical('configuration file does not exist: %s' %
                                  self.opts.c)
                raise FllError
        else:
            self.log.critical('no config file specified on command line')
            raise FllError

        if self.opts.s:
            if not os.path.isdir(self.opts.s):
                self.log.critical('share directory not exist: %s' %
                                  self.opts.s)
                raise FllError

        self.opts.s = os.path.realpath(self.opts.s)

        if self.opts.o:
            self.opts.o = self.__prepDir(self.opts.o)

        if self.opts.b:
            self.opts.b = self.__prepDir(self.opts.b)



    def _processDefaults(self, d):
        '''Form a distro-defaults data structure to be written to
        /etc/default/distro of each chroot, and used for release name.'''
        for k in ['FLL_DISTRO_NAME', 'FLL_IMAGE_DIR', 'FLL_IMAGE_FILE',
                  'FLL_MEDIA_NAME', 'FLL_MOUNTPOINT', 'FLL_LIVE_USER',
                  'FLL_LIVE_USER_GROUPS', 'FLL_GFXBOOT_THEME']:
            if not d.get(k):
                self.log.critical("%s' is required in 'distro' section " % k +
                                  "of build conf")
                raise FllError

        for k in ['FLL_DISTRO_NAME', 'FLL_IMAGE_DIR', 'FLL_IMAGE_FILE',
                  'FLL_LIVE_USER', 'FLL_DISTRO_CODENAME_SAFE',
                  'FLL_DISTRO_CODENAME_REV_SAFE']:
            if not d.get(k):
                continue
            if not d[k].isalnum():
                self.log.critical("'%s' is not alphanumeric: %s" % (k, d[k]))
                raise FllError
            elif d[k].find(' ') >= 0:
                self.log.critical("'%s' contains whitespace: %s" % (k, d[k]))
                raise FllError

        version = d.get('FLL_DISTRO_VERSION')
        if version and version != 'snapshot':
            if not d.get('FLL_DISTRO_CODENAME_SAFE'):
                self.log.critical("'FLL_DISTRO_VERSION' is set, but " +
                                  "'FLL_DISTRO_CODENAME_SAFE' is not")
                raise FllError

            for k in ['FLL_DISTRO_CODENAME', 'FLL_DISTRO_CODENAME_REV']:
                safe = k + '_SAFE'
                if d.get(safe) and not d.get(k):
                    d[k] = d[safe]
        else:
            d['FLL_DISTRO_VERSION'] = 'snapshot'


    def _getDistroImageFile(self, arch):
        '''Return image file that compressed chroot will be archived to.'''
        image_file = self.conf['distro']['FLL_IMAGE_FILE']
        if arch == 'i386':
            image_file += '.686'
        else:
            image_file += '.%s' % arch

        self.log.debug('image_file: %s' % image_file)
        return image_file


    def _getDistroStamp(self):
        '''Return a string suitable for the distro stamp file.'''
        d = self.conf['distro']
        stamp = ' '.join([d['FLL_DISTRO_NAME'], d['FLL_DISTRO_VERSION']])
        if d.get('FLL_DISTRO_VERSION') == 'snapshot':
            stamp += ' - %s' % self.conf['packages']['profile']
        else:
            if d.get('FLL_DISTRO_CODENAME_REV'):
                stamp += ' - %s' % d['FLL_DISTRO_CODENAME']
                stamp += ' %s -' % d['FLL_DISTRO_CODENAME_REV']
            else:
                stamp += ' %s -' % d['FLL_DISTRO_CODENAME']

            stamp += ' %s' % self.conf['packages']['profile']

        stamp += ' - (%s)' % self.timestamp

        self.log.debug('stamp: %s' % stamp)
        return stamp


    def _getDistroMediaName(self):
        '''Return a string suitable for the distro stamp file.'''
        d = self.conf['distro']
        name = '-'.join([d['FLL_DISTRO_NAME'], d['FLL_DISTRO_VERSION']])
        if d.get('FLL_DISTRO_VERSION') == 'snapshot':
            name += '-%s' % self.conf['packages']['profile']
        else:
            if d.get('FLL_DISTRO_CODENAME_REV'):
                name += '-%s-%s' % (d['FLL_DISTRO_CODENAME_SAFE'],
                                    d['FLL_DISTRO_CODENAME_REV_SAFE'])
            else:
                name += '-%s' % d['FLL_DISTRO_CODENAME_SAFE']

            name += '-%s' % self.conf['packages']['profile']

        name += '-' + '-'.join(list(self.conf['archs'].keys()))
        name += '-%s' % self.timestamp

        self.log.debug('name: %s' % name)
        return name


    def _processConf(self):
        '''Process configuration options.'''
        arch = ''
        if self.opts.a:
            arch = self.opts.a
        elif not self.conf.get('archs'):
            arch = Popen(['dpkg', '--print-architecture'], preexec_fn=restore_sigpipe,
                              stdout=PIPE).communicate()[0].decode().rstrip()

        if len(arch):
            self.log.debug('arch: %s' % arch)
            if arch not in list(self.conf['archs'].keys()):
                self.conf['archs'] = {arch: dict()}
            else:
                for arch2 in list(self.conf['archs'].keys()):
                    if arch != arch2:
                        del self.conf['archs'][arch2]

        for arch in list(self.conf['archs'].keys()):
            if 'linux' not in self.conf['archs'][arch]:
                if arch == 'i386':
                    cpu = '486'
                else:
                    cpu = arch

                linux = cpu

                self.conf['archs'][arch].setdefault('linux', [ linux ])
            else:
                linux = self.conf['archs'][arch]['linux']
                if isinstance(linux, str):
                    self.conf['archs'][arch]['linux'] = [ linux ]
                elif not isinstance(linux, list):
                    self.log.critical('invalid linux for arch %s in config'
                                      % arch)
                    raise FllError
            for linux in self.conf['archs'][arch]['linux']:
                self.log.debug("linux (%s): %s" %
                               (arch, self.conf['archs'][arch]['linux']))

        if len(list(self.conf['repos'].keys())) < 1:
            self.log.critical('no apt repos were specified in build config')
            raise FllError

        if 'sourcedistro' not in self.conf or \
           'name' not in self.conf['sourcedistro']:
            self.opts.N = 'debian'
            self.opts.C = 'sid'
        else:
            self.opts.N = self.conf['sourcedistro']['name']
            if 'codename' not in self.conf['sourcedistro']:
                self.log.critical('codename undefined in distro section of build config')
                raise FllError
            else:
                self.opts.C = self.conf['sourcedistro']['codename']
                
        if self.opts.N not in self.conf['repos']:
            self.log.critical('%s repo not configured in build config' % self.opts.N)
            raise FllError

        for repo in list(self.conf['repos'].keys()):
            if self.conf['repos'][repo].get('trivial'):
                words = ['label', 'uri']
            elif self.conf['repos'][repo].get('sources_uri'):
                words = []
            else:
                words = ['label', 'uri', 'suite', 'components']

            for word in words:
                if word not in self.conf['repos'][repo]:
                    self.log.critical("no '%s' for apt repo '%s'" %
                                     (word, repo))
                    raise FllError

        if self.opts.p:
            self.conf['packages']['profile'] = self.opts.p
        elif 'profile' not in self.conf['packages']:
            self.conf['packages']['profile'] = 'kde-lite'
        self.log.debug('profile: %s' % self.conf['packages']['profile'])

        if 'i18n' not in self.conf['packages'] or \
           not self.__lines2list(self.conf['packages']['i18n']):
            self.conf['packages']['i18n'] = 'en_US'
        i18n = self.__lines2list(self.conf['packages']['i18n'])
        self.log.debug('i18n: %s' % ' '.join(i18n))

        if 'hashkey' not in self.conf['options']:
            self.log.info('No key for signing ISO hashes!')
            self.opts.k = None
        else:
            self.opts.k = self.conf['options'].get('hashkey')
            self.log.debug('Using key %s for signing.' % self.opts.k)

        if not 'options' in self.conf:
            self.conf['options'] = dict()

        if self.conf['options'].get('build_dir'):
            if not self.opts.b:
                dir = self.conf['options']['build_dir']
                self.opts.b = self.__prepDir(dir)
        else:
            if not self.opts.b:
                self.opts.b = self.__prepDir(os.getcwd())

        if self.conf['options'].get('output_dir'):
            if not self.opts.o:
                dir = self.conf['options']['output_dir']
                self.opts.o = self.__prepDir(dir)
        else:
            if not self.opts.o:
                self.opts.o = self.__prepDir(os.getcwd())

        if self.conf['options'].get('build_log'):
            if not self.opts.l:
                self.opts.l = self.conf['options']['build_log']
                self.__initLogFile(self.opts.l)

        if self.conf['options'].get('http_proxy'):
            self.env['http_proxy'] = self.conf['options']['http_proxy']

        if self.conf['options'].get('ftp_proxy'):
            self.env['ftp_proxy'] = self.conf['options']['ftp_proxy']

        self.conf['options'].setdefault('apt_preferences', None)
        self.conf['options'].setdefault('apt_recommends', 'no')
        self.conf['options'].setdefault('media_include', None)

        if 'distro' in self.conf:
                self._processDefaults(self.conf['distro'])
                self.log.debug('distro-defaults:')
                for k, v in list(self.conf['distro'].items()):
                    self.log.debug('%s="%s"' % (k, v))
                self.log.debug('testing stamp/name:')
                self._getDistroStamp()
                self._getDistroMediaName()
        else:
            self.log.critical('distro section not found in build config')
            raise FllError


    def parseConf(self):
        '''Parse build configuration file and return it in a dict.'''
        self.log.info('reading configuration file...')

        self.conf = ConfigObj(self.opts.c)
        self._processConf()


    def _processPkgProfile(self, arch, profile, dir):
        '''Return a dict, arch string as key and package, debconf and postinst
        lists.'''
        pkgs = {'debconf': [], 'packages': [], 'postinst': []}

        linux_meta = ['linux-image', 'linux-headers']
        for kvers in self.conf['archs'][arch]['linux']:
            pkgs['packages'].extend(['-'.join([l, kvers]) for l in linux_meta])

        pname = os.path.basename(profile)
        self.log.debug('processing package profile for %s: %s' % (arch, pname))

        pfile = ConfigObj(profile)

        if 'desc' in pfile:
            for l in self.__lines2list(pfile['desc']):
                self.log.debug('  %s' % l)

        if 'debconf' in pfile:
            self.log.debug('debconf:')
            for d in self.__lines2list(pfile['debconf']):
                pkgs['debconf'].append(d)
                self.log.debug('  %s', d)

        if 'debconf' in self.conf['packages']:
            self.log.debug('debconf (config):')
            for d in self.__lines2list(self.conf['packages']['debconf']):
                pkgs['debconf'].append(d)
                self.log.debug('  %s' % d)

        if 'packages' in pfile:
            self.log.debug('packages:')
            for p in self.__lines2list(pfile['packages']):
                pkgs['packages'].append(p)
                self.log.debug('  %s' % p)

        if 'packages' in self.conf['packages']:
            self.log.debug('packages (config):')
            for p in self.__lines2list(self.conf['packages']['packages']):
                pkgs['packages'].append(p)
                self.log.debug('  %s' % p)

        if arch in pfile:
            self.log.debug('packages (%s):' % arch)
            for p in self.__lines2list(pfile[arch]):
                pkgs['packages'].append(p)
                self.log.debug('  %s' % p)

        deps = []
        if 'deps' in pfile:
            self.log.debug('deps:')
            for dep in self.__lines2list(pfile['deps']):
                deps.append(dep)
                self.log.debug('  %s' % dep)

        if 'deps' in self.conf['packages']:
            self.log.debug('deps (config):')
            for dep in self.__lines2list(self.conf['packages']['deps']):
                deps.append(dep)
                self.log.debug('  %s' % dep)

        if os.path.isfile(profile + '.postinst'):
            self.log.debug('registering postinst script')
            pkgs['postinst'].append(profile + '.postinst')

        self.log.debug('---')

        for dep in deps:
            depfile = os.path.join(dir, 'packages.d', dep)

            if not os.path.isfile(depfile):
                self.log.critical('no such dep file: %s' % depfile)
                raise FllError

            dname = os.path.basename(depfile)
            self.log.debug('processing dependency file: %s' % dname)

            dfile = ConfigObj(depfile)

            if 'desc' in dfile:
                for l in self.__lines2list(dfile['desc']):
                    self.log.debug('  %s' % l)

            if 'debconf' in dfile:
                self.log.debug('debconf:')
                for d in self.__lines2list(dfile['debconf']):
                    pkgs['debconf'].append(d)
                    self.log.debug('  %s' % d)

            if 'packages' in dfile:
                self.log.debug('packages:')
                for p in self.__lines2list(dfile['packages']):
                    pkgs['packages'].append(p)
                    self.log.debug('  %s' % p)

            if arch in dfile:
                self.log.debug('packages (%s):' % arch)
                for p in self.__lines2list(dfile[arch]):
                    pkgs['packages'].append(p)
                    self.log.debug('  %s' % p)

            if os.path.isfile(depfile + '.postinst'):
                self.log.debug('registering postinst script')
                pkgs['postinst'].append(depfile + '.postinst')

            self.log.debug('---')

        self.log.debug('package summary for %s:' % arch)
        pkgs['packages'].sort()
        for p in pkgs['packages']:
            self.log.debug('  %s' % p)

        self.log.debug('debconf summary for %s:' % arch)
        pkgs['debconf'].sort()
        for d in pkgs['debconf']:
            self.log.debug('  %s' % d)

        pkgs['packages'] = self.__filterList(pkgs['packages'])

        return pkgs


    def parsePkgProfile(self):
        '''Parse packages profile file(s).'''
        self.log.info('processing package profile (%s)...' %
                      self.conf['packages']['profile'])

        dir = os.path.join(self.opts.s, 'packages')
        file = os.path.join(dir, self.conf['packages']['profile'])

        if not os.path.isfile(file):
            self.log.critical('no such package profile file: %s' % file)
            raise FllError

        self.pkgs = dict()
        for arch in list(self.conf['archs'].keys()):
            self.pkgs[arch] = self._processPkgProfile(arch, file, dir)
            try:
                self.pkgs[arch]['packages'] += \
                    self.__lines2list(self.conf['packages'][arch])
            except KeyError:
                pass


    def _getDebconfList(self, arch):
        '''Return debconf list for arch. Dynamically generate locales
        debconf configuration based on i18n configuration in flk.conf.'''
        i18n_list = self.__lines2list(self.conf['packages']['i18n'])
        if len(i18n_list) == 0:
            i18n_list = 'en_US'
        i18n_debconf = 'locales locales/locales_to_be_generated multiselect'
        for i18n in i18n_list:
            i18n_debconf += ' %s.UTF-8 UTF-8,' % i18n
        i18n_debconf = i18n_debconf.rstrip(',')
        self.pkgs[arch]['debconf'].append(i18n_debconf)

        return self.pkgs[arch]['debconf']


    def _getPackageList(self, arch):
        '''Return package list for arch.'''
        return self.pkgs[arch]['packages']


    def _getPostinstList(self, arch):
        '''Return postinst list for arch.'''
        return self.pkgs[arch]['postinst']


    def stageBuildArea(self):
        '''Prepare temporary directory for chroots and result staging area.'''
        self.log.debug('preparing build area...')

        self.temp = tempfile.mkdtemp(prefix = 'fll_', dir = self.opts.b)
        os.chown(self.temp, self.opts.u, self.opts.g)

        atexit.register(self.cleanup)

        stage = os.path.join(self.temp, 'staging')
        os.mkdir(stage)
        os.mkdir(os.path.join(stage, 'boot'))
        os.mkdir(os.path.join(stage, self.conf['distro']['FLL_IMAGE_DIR']))

        media_include = self.conf['options'].get('media_include')
        if media_include and os.path.isdir(media_include):
            try:
                target_dirpath = os.path.join(stage, os.path.basename(media_include))
                shutil.copytree(media_include, target_dirpath, dirs_exist_ok=True,
                                ignore=shutil.ignore_patterns('.git*'))
            except:
                self.log.exception('problem copying media_include ' +
                                    'contents to staging dir')
                raise FllError


    def _mount(self, chroot):
        '''Mount virtual filesystems in a chroot.'''
        virtfs = {'devpts': 'dev/pts', 'proc': 'proc'}

        for v in list(virtfs.items()):
            cmd = ['mount', '-t', v[0], 'fll-' + v[0],
                   os.path.join(chroot, v[1])]

            retv = call(cmd, preexec_fn=restore_sigpipe)
            if retv != 0:
                self.log.critical('failed to mount chroot %s' % v[0])
                raise FllError


    def _umount(self, chrootdir):
        '''Umount any mount points in a chroot.'''
        umount_list = []
        try:
            for line in open('/proc/mounts'):
                (dev, mnt, fs, options, d, p) = line.split()
                if mnt.startswith(chrootdir):
                    umount_list.append(mnt)
        except IOError:
            self.log.exception('failed to open /proc/mounts')
            raise FllError

        umount_list.sort(key=len)
        umount_list.reverse()

        for mpoint in umount_list:
            retv = call(['umount', mpoint], preexec_fn=restore_sigpipe)
            if retv != 0:
                self.log.critical('umount failed for: %s' % mpoint)
                raise FllError


    def _nuke(self, dir):
        '''Nuke directory tree.'''
        if os.path.isdir(dir):
            self.log.debug('nuking directory: %s' % dir)
            try:
                shutil.rmtree(dir)
            except:
                self.log.exception('unable to remove %s' % dir)
                raise FllError
        else:
            self.log.debug('not nuking directory (does not exist): %s' % dir)


    def _nukeChroot(self, arch):
        '''Convenience function to nuke chroot given by arch name.'''
        if not self.opts.P:
            self.log.info('nuking %s chroot...' % arch)
            chroot = os.path.join(self.temp, arch)
            self._umount(chroot)
            self._nuke(chroot)


    def cleanup(self):
        '''Clean up the build area after taking care that all build chroots
        have been taken care of.'''
        self.log.info('cleaning up...')

        for arch in list(self.conf['archs'].keys()):
            dir = os.path.join(self.temp, arch)
            if os.path.isdir(dir):
                self.log.debug('cleaning up %s chroot...' % arch)
                self._umount(dir)
                if not self.opts.P:
                    self._nuke(dir)

        if not self.opts.P:
            self._nuke(self.temp)


    def __execLogged(self, cmd, check_returncode):
        '''Execute a command logging all output. Output sent to the console is
        buffered until the command has finished execution.'''
        self.log.debug(' '.join(cmd))

        try:
            c = Popen(cmd, stdout = PIPE, stderr = STDOUT, env = self.env,
                      close_fds = True, preexec_fn=restore_sigpipe)
            cout = c.communicate()[0]
            retv = c.returncode
        except KeyboardInterrupt:
            raise FllError
        except:
            self.log.exception('problem executing command: %s' % ' '.join(cmd))
            raise FllError

        for line in cout.splitlines():
            if self.opts.q:
                self.log.debug(line.rstrip())
            else:
                self.log.info(line.rstrip())

        if retv != 0 and check_returncode:
            self.log.critical('command failed with return value: %d' %
                              c.returncode)
            raise FllError


    def __exec(self, cmd, check_returncode):
        '''Execute subprocess without buffering output in a pipe.'''
        self.log.debug(' '.join(cmd))

        try:
            if self.opts.q:
                retv = call(cmd, stdout = open(os.devnull, 'w'),
                            stderr = STDOUT, env = self.env,
                            close_fds = True, preexec_fn=restore_sigpipe)
            else:
                retv = call(cmd, env = self.env, close_fds = True,
                            preexec_fn=restore_sigpipe)
        except KeyboardInterrupt:
            raise FllError
        except:
            self.log.exception('problem executing command: %s' % ' '.join(cmd))
            raise FllError

        if retv != 0 and check_returncode:
            self.log.critical('command failed with return value: %d' % retv)
            raise FllError


    def _execCmd(self, cmd, check_returncode = True):
        '''Convenience wrapper for subprocess execution.'''
        if self.opts.l:
            self.__execLogged(cmd, check_returncode)
        else:
            self.__exec(cmd, check_returncode)


    def _execInChroot(self, arch, args, check_returncode = True):
        '''Run command in a chroot.'''
        chroot = os.path.join(self.temp, arch)
        cmd = ['chroot', chroot]
        cmd.extend(args)

        self._mount(chroot)

        if self.opts.l:
            self.__execLogged(cmd, check_returncode)
        else:
            self.__exec(cmd, check_returncode)

        self._umount(chroot)


    def _aptGetInstall(self, arch, pkgs, download_only = False):
        '''An apt-get install wrapper. Automatic installation of recommended
        packages defaults to disabled.'''
        aptget = ['apt-get', '--yes']

        if download_only:
            aptget.append('--download-only')
        if self.conf['options']['apt_recommends'] == 'no':
            aptget.extend(['-o', 'APT::Install-Recommends=0'])
        if self.opts.d:
            aptget.extend(['-o', 'APT::Get::Show-Versions=1'])

        aptget.append('install')
        aptget.extend(pkgs)

        self._execInChroot(arch, aptget)


    def __cdebBootStrap(self, arch, dir, mirror, codename):
        '''Bootstrap a debian system with cdebootstrap.'''
        cmd = ['cdebootstrap', '--arch=%s' % arch,
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--flavour=minimal', codename, dir, mirror]

        if self.opts.d:
            cmd.append('--debug')
        elif self.opts.v:
            cmd.append('--verbose')

        self._execCmd(cmd)

        cmd = 'dpkg --purge cdebootstrap-helper-rc.d'
        self._execInChroot(arch, cmd.split())


    def __debBootStrap(self, arch, dir, mirror, codename):
        '''Bootstrap a debian system with debootstrap.'''
        cmd = ['debootstrap', '--arch=%s' % arch,
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--variant=minbase', '--merged-usr', codename, dir, mirror]

        if self.opts.d or self.opts.v:
            cmd.insert(1, '--verbose')

        self._execCmd(cmd)


    def __mmdebBootStrap(self, arch, dir, mirror, codename):
        '''Bootstrap a debian system with mmdebstrap.'''
        cmd = ['mmdebstrap', '--architectures=%s' % arch,
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--variant=minbase', '--mode=root', '--format=directory',
               '--hook-dir=/usr/share/mmdebstrap/hooks/merged-usr', codename, dir, mirror]

        if self.opts.d or self.opts.v:
            cmd.insert(1, '--verbose')

        self._execCmd(cmd)


    def _bootStrap(self, arch):
        '''Bootstrap a debian system with cdebootstrap.'''
        distro = self.opts.N
        debian = self.conf['repos'][distro]
        codename = self.opts.C
        if debian.get('cached'):
            mirror = debian['cached']
        else:
            mirror = debian['uri']

        dir = os.path.join(self.temp, arch)

        self.log.info('bootstrapping %s %s %s...' % (distro,codename,arch))

        bootstrapper = self.conf['options'].get('bootstrapper')
        if bootstrapper == 'mmdebstrap':
            self.__mmdebBootStrap(arch, dir, mirror, codename)
        elif bootstrapper == 'debootstrap':
            self.__debBootStrap(arch, dir, mirror, codename)
        else:
            self.__cdebBootStrap(arch, dir, mirror, codename)

        shutil.copy('/etc/hosts', os.path.join(dir, 'etc'))
        shutil.copy('/etc/resolv.conf', os.path.join(dir, 'etc'))
        os.mkdir(os.path.join(dir, 'disks'), 0o755)


    def _writeAptLists(self, arch, cached = False, src_uri = False):
        '''Write apt source lists to /etc/apt/sources.list.d/*.'''
        chroot = os.path.join(self.temp, arch)
        for r in self.conf['repos'].keys():
            repo = self.conf['repos'][r]
            sources_uri = repo.get('sources_uri')
            if sources_uri:
                cmd = ['wget', '--quiet', sources_uri, '-O']
                cmd.append(os.path.join(chroot, 'etc/apt/sources.list.d',
                                        os.path.basename(sources_uri)))
                self._execCmd(cmd)

                cached_uri = repo.get('cached_uri')
                if cached and cached_uri:
                    cmd = ['sed', '-i', 's#^URIs: .*#URIs: %s#' % cached_uri]
                    cmd.append(os.path.join(chroot, 'etc/apt/sources.list.d',
                                            os.path.basename(sources_uri)))
                    self._execCmd(cmd)
                continue

            sources_list = os.path.join(chroot, 'etc/apt/sources.list.d',
                                        repo['label'] + '.list')

            if os.path.isfile(os.path.join(chroot, 'etc/apt/sources.list')):
                s = None
                try:
                    s = open(os.path.join(chroot, 'etc/apt/sources.list'), 'a')
                    s.write('#   %-74s#\n' % sources_list.partition(chroot)[2])
                except IOError:
                    self.log.exception('failed to open /etc/apt/sources.list')
                    raise FllError
                finally:
                    if s:
                        s.close()

            self.log.debug("creating %s" % sources_list)

            line = []
            if cached and repo.get('cached'):
                line.append(repo['cached'])
            else:
                line.append(repo['uri'])

            if repo.get('trivial'):
                line.append('./')
            else:
                line.append(repo['suite'])
                line.append(repo['components'])

            line.append("\n")

            l = ' '.join(line)
            self.log.debug('%s: %s', repo, l.rstrip())

            sources_list_fh = None
            try:
                sources_list_fh = open(sources_list, 'w')
                sources_list_fh.write('deb ' + l)
                if not src_uri or self.opts.B:
                    sources_list_fh.write('#deb-src ' + l)
                else:
                    sources_list_fh.write('deb-src ' + l)
            except IOError:
                self.log.exception('failed to open %s' % sources_list)
                raise FllError
            finally:
                if sources_list_fh:
                    sources_list_fh.close()


    def _primeApt(self, arch):
        '''Prepare apt for work in each build chroot. Fetch all required gpg
        keys and initialize apt_pkg config.'''
        self.log.info('preparing apt in %s chroot...' % arch)
        chroot = os.path.join(self.temp, arch)

        apt_preferences = self.conf['options']['apt_preferences']
        if apt_preferences:
            self.log.info('importing apt preferences file')
            try:
                shutil.copy(apt_preferences, os.path.join(chroot, 'etc/apt/'))
            except IOError:
                self.log.error('apt preferences file failed to copy: %s' %
                               apt_preferences)
                raise FllError

        self.log.debug('removing sources.list from %s chroot' % arch)
        sources_list = os.path.join(chroot, 'etc/apt/sources.list')
        if os.path.isfile(sources_list):
            os.unlink(sources_list)

        self._writeAptLists(arch, cached = True, src_uri = True)

        keyrings = list()
        for r in self.conf['repos'].keys():
            repo = self.conf['repos'][r]
            keyring = repo.get('keyring')
            if keyring:
                keyrings.append(keyring)

        if len(keyrings) > 0:
            self._execInChroot(arch, 'apt-get -o Acquire::Languages=none --allow-insecure-repositories update'.split())
            cmd = 'apt-get --allow-unauthenticated --yes install'.split()
            cmd.extend(keyrings)
            self._execInChroot(arch, cmd)

        self._execInChroot(arch, 'apt-get -o Acquire::Languages=none update'.split())
        # Upgrade any essential packages from sources not available
        # during bootstrap phase.
        self._execInChroot(arch, 'apt-get dist-upgrade -y'.split())

        apt_pkg.init_config()
        apt_pkg.config.set('RootDir', chroot)
        apt_pkg.config.set('APT::Architecture', arch)
        apt_pkg.init_system()


    def _dpkgAddDivert(self, arch):
        '''Divert some facilities and replace temporaily with /bin/true (or
        some other more appropiate facility.'''
        chroot = os.path.join(self.temp, arch)
        for d in self.diverts:
            self.log.debug("diverting %s" % d)
            cmd = 'dpkg-divert --add --local --divert ' + d + '.REAL --rename '
            cmd += d
            self._execInChroot(arch, cmd.split())

            if d == '/usr/sbin/policy-rc.d':
                self._writeFile(arch, d)
                os.chmod(os.path.join(chroot, d.lstrip('/')), 0o755)
            else:
                os.symlink('/bin/true', os.path.join(chroot, d.lstrip('/')))


    def _dpkgUnDivert(self, arch):
        '''Undivert facilities diverted by self._dpkgAddDivert().'''
        chroot = os.path.join(self.temp, arch)
        for d in self.diverts:
            self.log.debug("undoing diversion: %s" % d)
            os.unlink(os.path.join(chroot, d.lstrip('/')))
            cmd = 'dpkg-divert --remove --rename ' + d
            self._execInChroot(arch, cmd.split())


    def _writeFile(self, arch, file):
        '''Write a file in a chroot. Templates for common files included
        below.'''
        chroot = os.path.join(self.temp, arch)

        f = None
        fn = None
        mode = 0o644
        try:
            fn = os.path.join(chroot, file.lstrip('/'))
            if os.path.isfile(fn):
                mode = None
            if not os.path.exists(os.path.dirname(fn)):
                try:
                    os.makedirs(os.path.dirname(fn), 0o755)
                except OSError as exc:
                    if exc.errno != errno.EEXIST:
                        raise
            f = open(fn, 'w')
            self.log.debug('writing file: %s' % file)
            if file == '/etc/default/distro':
                d = list(self.conf['distro'].keys())
                d.sort()
                for k in d:
                    if k.startswith('FLL_DISTRO_CODENAME'):
                        continue
                    elif k == 'FLL_MOUNTPOINT':
                        f.write('%s="%s"\n' % (k, self.conf['distro'][k]))
                        test = '$([ -d "$%s" ] && echo live' % k
                        test += ' || echo installed)'
                        f.write('%s="%s"\n' % ('FLL_DISTRO_MODE', test))
                    elif k == 'FLL_IMAGE_FILE':
                        image_file = self._getDistroImageFile(arch)
                        f.write('%s="%s"\n' % (k, image_file))
                        f.write('%s="$%s/$%s"\n' % ('FLL_IMAGE_LOCATION',
                                                    'FLL_IMAGE_DIR', k))
                    else:
                        f.write('%s="%s"\n' % (k, self.conf['distro'][k]))
            elif file == '/etc/fstab':
                f.write('# /etc/fstab: static file system information\n')
            elif file == '/etc/hostname':
                hostname = self.conf['distro']['FLL_DISTRO_NAME']
                f.write(hostname + '\n')
            elif file == '/etc/hosts':
                hostname = self.conf['distro']['FLL_DISTRO_NAME']
                f.write('127.0.0.1\tlocalhost\n')
                f.write('127.0.0.1\t' + hostname + '\n\n')
                f.write('# Below lines are for IPv6 capable hosts\n')
                f.write('::1     ip6-localhost ip6-loopback\n')
                f.write('fe00::0 ip6-localnet\n')
                f.write('ff00::0 ip6-mcastprefix\n')
                f.write('ff02::1 ip6-allnodes\n')
                f.write('ff02::2 ip6-allrouters\n')
                f.write('ff02::3 ip6-allhosts\n')
            elif file == '/usr/sbin/policy-rc.d':
                f.write('#!/bin/sh\n')
                f.write('echo "$0 denied action: $1 $2" >&2\n')
                f.write('exit 101\n')
            elif file == '/tmp/iso_uuid':
                f.write(self.uuid)
                self.conf['distro']['FLL_UUID'] = self.uuid
        except IOError:
            self.log.exception('failed to open file for writing: %s' % file)
            raise FllError
        finally:
            if f:
                f.close()
                if mode:
                    os.chmod(fn, mode)


    def _defaultEtc(self, arch):
        '''Initial creation of conffiles required in chroot.'''
        self._writeFile(arch, '/etc/fstab')
        self._writeFile(arch, '/etc/hostname')
        self._writeFile(arch, '/tmp/iso_uuid')


    def _distroDefaultEtc(self, arch):
        '''Write the /etc/default/distro file.'''
        self._writeFile(arch, '/etc/default/distro')


    def _finalEtc(self, arch):
        '''Final editing of conffiles in chroot.'''
        chroot = os.path.join(self.temp, arch)

        distro_version = '%s-version' % \
                         self.conf['distro']['FLL_DISTRO_NAME'].lower()
        distro_version = os.path.join(chroot, 'etc', distro_version)

        self.log.debug('stamping distro version: %s' % distro_version)
        f = None
        try:
            f = open(distro_version, 'w')
            f.write(self._getDistroStamp())
        except IOError:
            self.log.exception('failed to open file for writing: %s' %
                               distro_version)
            raise FllError
        finally:
            if f:
                f.close()
                os.chmod(distro_version, 0o444)

        self._writeFile(arch, '/etc/hosts')
        self._writeFile(arch, '/etc/motd.tail')

        self.log.debug('writing final apt sources.list(s)')
        self._writeAptLists(arch)

        if os.path.isfile(os.path.join(chroot, 'etc/resolv.conf')) and \
           not os.path.islink(os.path.join(chroot, 'etc/resolv.conf')):
            # networkd+resolved so setup symlink and disable fallback DNS
            try:
                os.unlink(os.path.join(chroot, 'etc/resolv.conf'))
                os.symlink('../run/systemd/resolve/stub-resolv.conf', os.path.join(chroot, 'etc/resolv.conf'))
                with open(os.path.join(chroot, 'etc/systemd/resolved.conf'), 'a') as f:
                    f.write('DNS=\n')
            except IOError:
                self.log.exception('failed to setup resolv.conf and resolved.conf')

        if os.path.isfile(os.path.join(chroot, 'etc/.resolv.conf.systemd-resolved.bak')):
            try:
                os.unlink(os.path.join(chroot, 'etc/.resolv.conf.systemd-resolved.bak'))
            except IOError:
                self.log.exception('failed to delete .resolv.conf.systemd-resolved.bak')


    def _makeInitramfs(self, arch):
        '''Generate the initramfs if update-initramfs was diverted'''
        if '/usr/sbin/update-initramfs' in self.diverts and not self.opts.D:
            chroot = os.path.join(self.temp, arch)
            kvers = self._detectLinuxVersion(chroot)
            for k in kvers:
                cmd = 'update-initramfs -c -k %s' % k
                if self.opts.v:
                    cmd += ' -v'
                self._execInChroot(arch, cmd.split())


    def _preseedDebconf(self, arch):
        '''Preseed debconf with values read from package lists.'''
        chroot = os.path.join(self.temp, arch)
        debconf_list = self._getDebconfList(arch)

        if debconf_list:
            self.log.info('preseeding debconf in %s chroot...' % arch)
            debconf = None
            try:
                debconf = open(os.path.join(chroot, 'tmp',
                                            'fll_debconf_selections'), 'w')
                debconf.writelines([d + '\n' for d in debconf_list])
            except IOError:
                self.log.exception('failed to open file for writing: %s' %
                                   '/tmp/fll_debconf_selections')
                raise FllError
            finally:
                if debconf:
                    debconf.close()

            cmd = 'debconf-set-selections '
            if self.opts.v:
                cmd += '--verbose '
            cmd += '/tmp/fll_debconf_selections'

            self._execInChroot(arch, cmd.split())


    def _detectLinuxVersion(self, chroot):
        '''Return version string of a singularly installed linux-image.'''
        kvers = [f[f.find('-')+1:] for f in
                 os.listdir(os.path.join(chroot, 'boot'))
                 if f.startswith('vmlinuz-') or f.startswith('vmlinux-')]
        if self.opts.D:
            arch = chroot[chroot.rfind('/')+1:]
            kvers = [f[len('linux-image-'):] for f in
                     self.pkgs[arch]['install']
                     if f.startswith('linux-image-')]

        if len(kvers) > 0:
            kvers.sort(key=functools.cmp_to_key(apt_pkg.version_compare))
            kvers.reverse()
            return kvers

        self.log.critical('failed to detect linux version installed in chroot')
        raise FllError


    def _detectLocalePkgs(self, i18n, wanted, cache):
        '''Provide automated detection for extra i18n packages.'''
        self.log.info('detecting i18n packages for %s...' % ' '.join(i18n))

        i18n_module = ConfigObj('/usr/share/fll/data/locales-pkg-map')
        self.log.debug('i18n_module:')
        self.log.debug(i18n_module)

        fll_locales = FllLocales(cache, wanted, i18n_module)
        i18n_list = []
        for locale in sorted(i18n):
            try:
                loc_pkg_list = fll_locales.detect_locale_packages(locale)
            except FllLocalesError:
                print_error('Failed to parse locale string: %s' % locale)
            else:
                i18n_list.extend(loc_pkg_list)

        self.log.debug('i18n_list:')
        self.log.debug(i18n_list)
        return i18n_list


    def _detectRecommendedPkgs(self, wanted, cache):
        '''Provide automated detection for packages in recommends whitelist.'''
        if self.conf['options']['apt_recommends'] == 'yes':
            return []

        self.log.info('detecting whitelisted recommended packages...')
        rec_module = ConfigObj(os.path.join(self.opts.s, 'packages',
                                            'packages.d', 'recommends'))
        try:
            rec_dict = dict([(p, True) for p in
                             self.__lines2list(rec_module['packages'])])
        except KeyError:
            self.log.debug('rec_dict:')
            return []

        self.log.debug('rec_dict:')
        self.log.debug(rec_dict)

        rec_list = []
        for p in wanted.keys():
            if not p in rec_dict:
                continue
            package = cache[p]
            current = package.current_ver
            if not current:
                versions = package.version_list
                if not versions:
                    continue
                version = versions[0]
                for other_version in versions:
                    if apt_pkg.version_compare(version.ver_str,
                                               other_version.ver_str) < 0:
                        version = other_version
                current = version

            depends = current.depends_list
            list = depends.get('Recommends', [])
            for dependency in list:
                depdone = 0
                for deppart in dependency:
                    if depdone > 0:
                        continue
                    name = deppart.target_pkg.name
                    if name in wanted.keys():
                        depdone = 1
                        continue
                if depdone == 0:
                    name = dependency[0].target_pkg.name
                    dep = cache[name]
                    if dep.current_ver:
                        continue
                    rec_list.append(dep.name)

        self.log.debug('rec_list:')
        self.log.debug(rec_list)
        return rec_list


    def __getSourcePkg(self, pkg, depcache, records):
        '''Get the source package name of a given package.'''
        version = depcache.get_candidate_ver(pkg)

        if not version:
            return None
        file, index = version.file_list.pop(0)
        records.lookup((file, index))

        srcpkg = pkg.name
        srcver = version.ver_str
        if records.source_pkg != "":
            srcpkg = records.source_pkg

        if records.source_ver != "":
            srcver = records.source_ver

        return [srcpkg,srcver]

    def _collectManifest(self, arch):
        '''Collect package and source package URI information from each
        chroot.'''
        chroot = os.path.join(self.temp, arch)
        self.log.info('collecting package manifest for %s...' % arch)

        cache = apt_pkg.Cache(apt.progress.base.OpProgress())
        records = apt_pkg.PackageRecords(cache)
        depcache = apt_pkg.DepCache(cache)

        manifest = dict([(p.name, p.current_ver.ver_str)
                         for p in cache.packages if p.current_ver
                         and not p.name.startswith('cdebootstrap-helper')])
        if 'install' in self.pkgs[arch]:
            manifest.update(self.pkgs[arch]['install'])
        if 'langpack' in self.pkgs[arch]:
            manifest.update(self.pkgs[arch]['langpack'])
        if 'extras' in self.pkgs[arch]:
            manifest.update(self.pkgs[arch]['extras'])
        self.pkgs[arch]['manifest'] = manifest

        if self.opts.B:
            return

        self.log.info('querying source package URIs for %s...' % arch)

        packages = list(manifest.keys())
        packages.sort()
        srcpkg_seen = dict()
        uris = []
        for p in packages:
            for k in self._detectLinuxVersion(chroot):
                if p.endswith('-modules-' + k):
                    p = p[:p.find('-modules-' + k)]
                    p += '-source'

            if p.startswith('cdebootstrap-helper'):
                continue

            srcpv = self.__getSourcePkg(cache[p], depcache, records)
            srcpkg=srcpv[0]
            srcver=srcpv[1]
            if not srcpkg:
                self.log.critical('failed to lookup srcpkg name for %s' % p)
                raise FllError
            self.log.debug('%s -> %s' % (p, srcpkg))

            if srcpkg in srcpkg_seen:
                self.log.debug('already processed %s, skipping...' % srcpkg)
                continue
            else:
                srcpkg_seen[srcpkg] = True

            u = []
            sources = apt_pkg.SourceRecords()
            sources.restart()
            while sources.lookup(srcpkg):
                if sources.version == srcver:
                    u.extend([sources.index.archive_uri(sources.files[f][2])
                              for f in range(len(sources.files))])
            if len(u) > 0:
                self.log.debug(u)
                uris.extend(u)
            else:
                self.log.critical('failed to query source uris for %s' % srcpkg)
                raise FllError

        uris.sort()
        self.pkgs[arch]['source'] = uris


    def _installPkgs(self, arch, codename):
        '''Install packages.'''
        cache = apt_pkg.Cache(apt.progress.base.OpProgress())
        if cache.ver_file_count < 200:
            self.log.info('installPkgs cache had %s' % cache.ver_file_count)
            cache = apt_pkg.Cache(apt.progress.base.OpProgress())
            self.log.info('installPkgs cache has %s' % cache.ver_file_count)

        i18n_list = self.__lines2list(self.conf['packages']['i18n'])
        pkgs_base = [p.name for p in cache.packages if p.current_ver]
        pkgs_want = self.__filterList(pkgs_base + self._getPackageList(arch))
        pkgs_dict = dict([(p, True) for p in pkgs_want])
        pkgs_want = self.__filterList(list(pkgs_dict.keys())
                                      + self._detectLocalePkgs(i18n_list, pkgs_dict, cache)
                                      + self._detectRecommendedPkgs(pkgs_dict, cache))
        pkgs_had = list()

        if self.opts.D:
            self.pkgs[arch]['install'] = dict()

        self.log.info('downloading packages in %s chroot...' % arch)
        # re-runs detect*Pkgs using what will now be installed
        # repeat until nothing was added
        while len(pkgs_want) > len(pkgs_had):
            self.log.debug('%i new in package list for this run'
                          % (len(pkgs_want)-len(pkgs_had)))
            pkgs_had = list()
            pkgs_had.extend(pkgs_want)
            self._aptGetInstall(arch, self.__filterList(pkgs_want),
                                download_only = True)

            chroot = os.path.join(self.temp, arch)
            aptcache = os.path.join(chroot, 'var/cache/apt/archives/*.deb')
            for debfile in glob.glob(aptcache):
                pkg, vers, extra = debfile.split('/')[-1].split('_')
                # big dict given below to detect*Pkgs
                pkgs_dict[pkg] = True
                if self.opts.D:
                    # create dict with package name = version to extend manifest
                    self.pkgs[arch]['install'][pkg] = vers.replace('%3a', ':')

            for pkg in ( self._detectLocalePkgs(i18n_list, pkgs_dict, cache) 
                       + self._detectRecommendedPkgs(pkgs_dict, cache) ):
                if pkg not in pkgs_want:
                    pkgs_want.append(pkg)
                    self.log.debug('%s now added to wanted packages had %i now %i' % (pkg,len(pkgs_had),len(pkgs_want)))

        if not self.opts.D:
            self.log.info('installing packages in %s chroot...' % arch)
            self._aptGetInstall(arch, pkgs_want)

        # reset /etc/resolv.conf (systemd-resolved clobbered our settings)
        os.unlink(os.path.join(chroot, 'etc/resolv.conf'))
        shutil.copy('/etc/resolv.conf', os.path.join(chroot, 'etc'))

        # Fetch extra debs if appropriate and reprepro them
        extra_pkgs = ['grub2-fll-portable-efi']
        self.pkgs[arch]['extras'] = dict()
        self._execInChroot(arch, ['apt-get', 'clean'])
        for pkg in extra_pkgs:
            self._aptGetInstall(arch, [pkg], download_only = True)
        # Generate a basic reprepro conf/distributions.
        extras_path = os.path.join(self.temp, arch, 'fll', 'extras')
        extras_conf = os.path.join(extras_path, 'conf')
        if not os.path.isdir(extras_conf):
            os.makedirs(extras_conf)
            extras_dist = os.path.join(extras_path, 'conf', 'distributions')
            rconf = None
            try:
                rconf = open(extras_dist, "w")
                rconf.write('Codename: %s\n' % codename)
                rconf.write('Architectures: ')
                for a in list(self.conf['archs'].keys()):
                    rconf.write(''.join([a,' ']))
                rconf.write('\n')
                rconf.write('Components: main\n')
                rconf.write('Description: extra packages\n')
            except IOError:
                self.log.exception('error preparing reprepro for extras')
                raise FllError
            finally:
                if rconf:
                    rconf.close()

        # Find all the debs and includedeb them.
        chroot = os.path.join(self.temp, arch)
        aptcache = os.path.join(chroot, 'var/cache/apt/archives/*.deb')
        for debfile in glob.glob(aptcache):
            if not self.opts.D:
                self._execCmd(['reprepro', '-Vb', extras_path, 'includedeb', codename,
                                debfile])
            # create dict with package name = version to extend manifest
            pkg, vers, extra = debfile.split('/')[-1].split('_')
            self.pkgs[arch]['extras'][pkg] = vers.replace('%3a', ':')

        # Calculate packages for each language.
        self.pkgs[arch]['langpack'] = dict()
        if 'lang' not in self.conf['packages']:
            return

        lang_list = self.__lines2list(self.conf['packages']['lang'])
        if len(lang_list) == 0:
            return
        lang_full = pkgs_want
        i18n = os.path.join(self.temp, 'staging', 'i18n')
        for lang in lang_list:
            lang_pkgs = self._detectLocalePkgs([ lang ], pkgs_dict, cache)
            i18n_arch = os.path.join(i18n, arch)
            if not os.path.isdir(i18n_arch):
                os.makedirs(i18n_arch)
            i18n_lang = os.path.join(i18n, arch, lang)
            i18nlist = None
            try:
                i18nlist = open(i18n_lang, "w")
                for pkg in lang_pkgs:
                    i18nlist.write('%s ' % (pkg))
            except IOError:
                    self.log.exception('error writing i18n file for lang: %s' %
                                       lang)
                    raise FllError
            finally:
                if i18nlist:
                    i18nlist.close()
            lang_full.extend(lang_pkgs)

        # Fetch all extra lang packages and reprepro them.
        if lang_pkgs:
            self._execInChroot(arch, ['apt-get', 'clean'])
            self._aptGetInstall(arch, self.__filterList(lang_full),
                                download_only = True)
            # Generate a basic reprepro conf/distributions.
            i18n_conf = os.path.join(i18n, 'conf')
            if not os.path.isdir(i18n_conf):
                os.mkdir(i18n_conf)
                i18n_dist = os.path.join(i18n, 'conf', 'distributions')
                rconf = None
                try:
                    rconf = open(i18n_dist, "w")
                    rconf.write('Codename: %s\n' % codename)
                    rconf.write('Architectures: ')
                    for a in list(self.conf['archs'].keys()):
                        rconf.write(''.join([a,' ']))
                    rconf.write('\n')
                    rconf.write('Components: main\n')
                    rconf.write('Description: i18n packages\n')
                except IOError:
                    self.log.exception('error preparing reprepro')
                    raise FllError
                finally:
                    if rconf:
                        rconf.close()

            # Find all the debs and includedeb them.
            chroot = os.path.join(self.temp, arch)
            aptcache = os.path.join(chroot, 'var/cache/apt/archives/*.deb')
            for debfile in glob.glob(aptcache):
                if not self.opts.D:
                    self._execCmd(['reprepro', '-Vb', i18n, 'includedeb', codename,
                                  debfile])
                # create dict with package name = version to extend manifest
                pkg, vers, extra = debfile.split('/')[-1].split('_')
                self.pkgs[arch]['langpack'][pkg] = vers.replace('%3a', ':')


    def _postInst(self, arch):
        '''Run package module postinst scripts in a chroot.'''
        if self.opts.D:
            return
        chroot = os.path.join(self.temp, arch)

        self.log.info('performing post-install tasks in %s chroot...' % arch)

        for script in self._getPostinstList(arch):
            sname = os.path.basename(script)
            try:
                shutil.copy(script, os.path.join(chroot, 'tmp'))
                os.chmod(os.path.join(chroot, 'tmp', sname), 0o755)
            except:
                self.log.exception('error preparing postinst script: %s' %
                                   sname)
                raise FllError

            cmd = '/tmp/%s postinst' % sname
            self._execInChroot(arch, cmd.split())
            os.unlink(os.path.join(chroot, 'tmp', sname))


    def _zerologs(self, arch, dir, fnames):
        '''Truncate all log files.'''
        chroot = os.path.join(self.temp, arch)
        chrootdir = dir.partition(chroot)[2]

        for f in fnames:
            if not os.path.isfile(os.path.join(dir, f)):
                continue
            self._writeFile(arch, os.path.join(chrootdir, f))


    def _cleanChroot(self, arch):
        '''Remove unwanted content from a chroot.'''
        self.log.info('purging unwanted content from %s chroot...' % arch)
        chroot = os.path.join(self.temp, arch)

        cmd = 'dpkg --purge fll-live-initramfs'
        self._execInChroot(arch, cmd.split())
        self._execInChroot(arch, 'apt-get clean'.split())
        self._execInChroot(arch, 'dpkg --clear-avail'.split())

        for dirpath, dirnames, files in os.walk(os.path.join(chroot, 'var/log')):
            self._zerologs(arch, dirpath, files)


    def _chrootSquashfs(self, arch):
        '''Make squashfs filesystem image of chroot.'''
        self.log.info('creating squashfs filesystem of %s chroot...' % arch)
        chroot = os.path.join(self.temp, arch)

        image_file = self._getDistroImageFile(arch)
        if self.opts.D:
            cmd = ['touch', image_file]
            self._execInChroot(arch, cmd)
            return

        cmd = ['mksquashfs', '.', image_file, '-noappend']

        exclude_file = os.path.join(self.opts.s, 'data', 'fll_sqfs_exclusion')
        shutil.copy(exclude_file, os.path.join(chroot, 'tmp'))
        cmd.extend(['-wildcards', '-ef', '/tmp/fll_sqfs_exclusion'])

        # set compression algorithm for squashfs-tools >= 4.1
        squashfs_comp = self.conf['options'].get('squashfs_comp')
        if squashfs_comp in ['gzip', 'lz4', 'lzo', 'xz', 'zstd']:
            self.log.info('using squashfs(%s)...' % squashfs_comp)
            cmd.extend(['-comp', '%s' % squashfs_comp])
            if squashfs_comp == 'xz':
                if arch == 'amd64' or arch == 'i386':
                    cmd.extend(['-Xbcj', 'x86'])
        
        if self.opts.l or self.opts.q:
            cmd.append('-no-progress')

        # can only be last argument
        cmd.extend(['-e', image_file])

        self._execInChroot(arch, cmd)


    def secondSquashfs(self):
        '''Make squashfs filesystem image of non chroot other material.'''
        if self.opts.D:
            return
        self.log.info('creating secondary squashfs filesystem')
        stage = os.path.join(self.temp, 'staging')
        fll_image_dir = self.conf['distro'].get('FLL_IMAGE_DIR')
        fll_image_file = self.conf['distro'].get('FLL_IMAGE_FILE')
        sqfs_file = os.path.join(stage, fll_image_dir,
                                 '%s.2' % fll_image_file)
        excl_file = os.path.join(stage, fll_image_dir,
                                 '%s.2.excl' % fll_image_file)
        excl = open(excl_file, 'w')
        excl.write('autorun.inf\n')
        excl.write('boot\n')
        excl.write('boot/*\n')
        excl.write('boot.catalog\n')
        excl.write('cdrom.ico\n')
        excl.write('efi\n')
        excl.write('efi/*\n')
        excl.write('efi.img\n')
        excl.write('iso_uuid\n')
        excl.write('%s\n' % fll_image_dir)
        excl.write('%s/*\n' % fll_image_dir)
        excl.close()
        cmd = ['mksquashfs', stage, sqfs_file, '-noappend']
        cmd.extend(['-wildcards', '-ef', excl_file])

        # set compression algorithm for squashfs-tools >= 4.1
        squashfs_comp = self.conf['options'].get('squashfs_comp')
        if squashfs_comp in ['gzip', 'lzo', 'xz']:
            self.log.info('using squashfs(%s)...' % squashfs_comp)
            cmd.extend(['-comp', '%s' % squashfs_comp])
            if squashfs_comp == 'xz':
                arch = list(self.conf['archs'].keys())[0]
                if arch == 'amd64' or arch == 'i386':
                    cmd.extend(['-Xbcj', 'x86'])
        
        if self.opts.l or self.opts.q:
            cmd.append('-no-progress')

        self._execCmd(cmd)
        self._nuke(os.path.join(stage,'extras'))
        self._nuke(os.path.join(stage,'i18n'))
        os.unlink(excl_file)


    def _stageArch(self, arch):
        '''Stage files for an arch for final genisofs.'''
        self.log.info('staging live %s media...' % arch)
        chroot = os.path.join(self.temp, arch)
        boot_dir = os.path.join(self.temp, 'staging', 'boot')

        image_file = os.path.join(chroot, self._getDistroImageFile(arch))
        image_dir = os.path.join(self.temp, 'staging',
                                 self.conf['distro']['FLL_IMAGE_DIR'])
        try:
            os.chmod(image_file, 0o644)
            shutil.move(image_file, image_dir)
        except IOError:
            self.log.exception('failed to move squashfs image to staging dir')
            raise FllError

        if self.opts.D:
            return

        kvers = self._detectLinuxVersion(chroot)
        for k in kvers:
            initrd = os.path.join(chroot, 'boot', 'initrd.img-' + k)
            if os.path.isfile(initrd):
                self.log.debug('copying %s to staging dir' % initrd)
                shutil.copy(initrd, boot_dir)
            else:
                self.log.critical('could not find initramfs image to ' +
                                  'copy to staging dir.')
                raise FllError
            
            images = glob.glob(os.path.join(chroot, 'boot', 'vmlinu*-' + k))
            if len(images) == 1:
                self.log.debug('copying %s to staging dir' % images[0])
                shutil.copy(images[0], boot_dir)
            else:
                self.log.critical('could not find linux kernel image to ' +
                                  'copy to staging dir.')
                raise FllError

        if os.path.isdir(os.path.join(chroot, 'usr/lib/grub')):
            data_dir = os.path.join(self.opts.s, 'data')
            grub_dir = os.path.join(boot_dir, 'grub')
            if not os.path.isdir(grub_dir):
                os.makedirs(grub_dir, 0o755)
            if not os.path.isfile(os.path.join(grub_dir, 'grub.cfg')):
              shutil.copy(os.path.join(self.opts.s, 'data/grub.cfg'), grub_dir)
              shutil.copy(os.path.join(chroot, 'usr/share/grub/unicode.pf2'), grub_dir)
              shutil.copytree(os.path.join(self.opts.s, 'data/locales'), os.path.join(grub_dir, 'locales'))
              shutil.copytree(os.path.join(self.opts.s, 'data/tz'), os.path.join(grub_dir, 'tz'))
              theme_dir = 'themes/%s' % self.conf['distro']['FLL_GFXBOOT_THEME']
              if os.path.isfile(os.path.join(chroot, 'usr/share/grub/%s/theme.txt' % theme_dir)):
                  shutil.copytree(os.path.join(chroot, 'usr/share/grub/%s' % theme_dir), os.path.join(grub_dir, theme_dir))

            gfile_dir = glob.glob(os.path.join(chroot, 'usr/lib/grub/*-pc'))[0]

            grub2_modules = glob.glob(os.path.join(gfile_dir, '*.mod'))
            if len(grub2_modules) > 0:
                gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                          if f.endswith('.mod') or f.endswith('.img')
                          or f.endswith('.lst')]
                gfiles.append(os.path.join(chroot, 'tmp/grub_eltorito'))
            else:
                gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                          if f.startswith('stage2') or f.startswith('iso9660')]

            if len(gfiles) > 0:
                self.log.debug('copying grub stage files to boot dir')
                grub_dir = os.path.join(boot_dir, 'grub', 'i386-pc')
                if not os.path.isdir(grub_dir):
                    os.makedirs(grub_dir, 0o755)
            else:
                self.log.exception('grub stage files not found')
                raise FllError

            for file in gfiles:
                try:
                    shutil.copy(file, grub_dir)
                except IOError:
                    self.log.exception('failed to copy grub file to staging dir')
                    raise FllError

            # efi
            efitypes = { 'x86_64-efi':'bootx64','i386-efi':'bootia32' }
            have_efi = ""
            for efitype in (list(efitypes.keys())):
                gfile_dir = os.path.join(chroot, 'usr/lib/grub/%s' % efitype)
                if os.path.isdir(gfile_dir):
                    have_efi = "true"
                    gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                            if f.endswith('.mod') or f.endswith('.lst')]
                    gfiles.append(os.path.join(chroot,'/usr/share/grub/unicode.pf2'))
                    if len(gfiles) > 0:
                        self.log.debug('copying grub %s stage files to boot dir' % efitype)
                        grub_dir = os.path.join(boot_dir, 'grub', efitype)
                        if not os.path.isdir(grub_dir):
                            os.makedirs(grub_dir, 0o755)
                    for file in gfiles:
                        try:
                            shutil.copy(file, grub_dir)
                        except IOError:
                            self.log.exception('failed to copy grub efi file to staging dir')
                            raise FllError
                    efi_dir = os.path.join(self.temp, 'staging/efi/boot')
                    if not os.path.isdir(efi_dir):
                        os.makedirs(efi_dir, 0o755)
                    try:
                        shutil.copy(os.path.join(chroot, 'tmp/efi/boot/%s.efi' % efitypes[efitype]), efi_dir)
                    except IOError:
                        self.log.exception('failed to copy efi %s boot files to staging dir' % efitype)
                        raise FllError
            if have_efi != "" and not os.path.isfile(os.path.join(self.temp, 'staging', 'efi.img')):
                try:
                    cmd = [ 'mformat', '-C', '-f', '2880', '-L', '16', '-i', '/tmp/efi.img', '::' ]
                    self._execInChroot(arch, cmd)
                    cmd = [ 'mcopy', '-s', '-i', '/tmp/efi.img', '/tmp/efi_img/efi', '::/' ]
                    self._execInChroot(arch, cmd)
                    shutil.copy(os.path.join(chroot, 'tmp/efi.img'), os.path.join(self.temp, 'staging'))
                    shutil.copy(os.path.join(chroot, 'tmp/iso_uuid'), os.path.join(self.temp, 'staging'))
                    uuid_dir = os.path.join(chroot, 'tmp/uuid')
                    ufiles = [os.path.join(uuid_dir, f) for f in os.listdir(uuid_dir)]
                    for file in ufiles:
                        shutil.copy(file, os.path.join(boot_dir, 'grub'))
                except IOError:
                    self.log.exception('failed to create efi.img')
                    raise FllError

        memtest = os.path.join(chroot, 'boot', 'memtest86+.bin')
        memtest_out = os.path.join(boot_dir, 'memtest')
        if os.path.isfile(memtest):
            self.log.debug('copying memtest86+ to boot dir')
            try:
                shutil.copy(memtest, memtest_out)
            except IOError:
                self.log.exception('failed to copy memtest86+ to staging dir')
                raise FllError


    def _writeGrubCfg(self, stage_dir, boot_dir, grub_dir, kvers,
                      timeout, cmdline):
        '''Write grub.cfg for live media.'''
        self.log.info('writing grub.cfg for live media')

        grubcfg = open(os.path.join(grub_dir, 'kernels.cfg'), 'w')

        distro = self.conf['distro']['FLL_DISTRO_NAME']
        
        kcount = { '686': 0, 'amd': 0, 'pae': 0, '486': 0, 'ppc': 0 }
        for k in kvers:
            cpu = k[k.rfind('-') + 1:]
            vmlinuz = 'vmlinuz-%s' % k
            initrd = 'initrd.img-%s' % k

            for f in [vmlinuz, initrd]:
                if not os.path.isfile(os.path.join(boot_dir, f)):
                    self.log.critical('%s was not found in %s' % (f, boot_dir))
                    raise FllError

            if cpu[0:3] == 'amd':
              grubcfg.write('if cpuid -l; then\n')
            grubcfg.write('havekernel="Y"\n')
            grubcfg.write('title=""\n')
            grubcfg.write('for kopt in %s $kopts %s boot=fll quiet systemd.show_status=1 splash; do\n' % (vmlinuz[8:], cmdline))
            grubcfg.write(' if [ -n "$title" ] ; then\n')
            grubcfg.write('  title="$title $kopt";\n')
            grubcfg.write(' else\n')
            grubcfg.write('  title="$kopt";\n')
            grubcfg.write(' fi;\n')
            grubcfg.write('done\n')
            grubcfg.write('menuentry --class=%s.%s \"$title\" {' % (distro, cpu))
            grubcfg.write('# set arguments above with the editor\n')
            grubcfg.write('linux /boot/vmlinuz-$@\n')
            grubcfg.write('initrd /boot/%s\n' % initrd)
            grubcfg.write('}\n')
            if cpu[0:3] == 'amd':
              grubcfg.write('fi\n')
            kcount[cpu[0:3]] = kcount[cpu[0:3]] + 1
        grubcfg.write('if [ "${havekernel}" != "Y" ]; then\n')
        grubcfg.write('  menuentry --class=find.none "NO SUITABLE KERNELS AVAILABLE" {echo $@')
        grubcfg.write('  echo "There are no kernels suitable for this machine available."\n')
        grubcfg.write('  echo ""\n')
        grubcfg.write('  if ! cpuid -l; then\n')
        grubcfg.write('    echo "This machine is NOT 64bit capable."\n')
        grubcfg.write('    for kk in /boot/vmlinu*.*86; do\n')
        grubcfg.write('      if [ "$kk" != "/boot/vmlinu*.*86" ]; then\n')
        grubcfg.write('        have32="true"\n')
        grubcfg.write('      fi\n')
        grubcfg.write('    done\n')
        grubcfg.write('    if [ "${have32}" != "true" ]; then\n')
        grubcfg.write('      echo "There are no 32bit kernels available"\n')
        grubcfg.write('      echo "It appears you are trying to boot a 64bit release on a 32bit machine"\n')
        grubcfg.write('      echo "This cannot work!"\n')
        grubcfg.write('    fi\n')
        grubcfg.write('  fi\n')
        grubcfg.write('  echo "Press Escape to return to the main menu"\n')
        grubcfg.write('  sleep --interruptible 9999\n')
        grubcfg.write('  menu_reload\n')
        grubcfg.write('  }\n')
        grubcfg.write('fi\n')

        grubcfg.close()
        
        self.log.debug('writing loopback.cfg for live media')
        grubcfg = open(os.path.join(grub_dir, 'loopback.cfg'), 'w')
        grubcfg.write('source /boot/grub/grub.cfg\n')
        grubcfg.close()
        
        self.log.debug('writing variable.cfg for live media')
        grubcfg = open(os.path.join(grub_dir, 'variable.cfg'), 'w')
        grub_theme = 'grub/themes/%s/theme.txt' % self.conf['distro']['FLL_GFXBOOT_THEME']
        if os.path.isfile(os.path.join(boot_dir, grub_theme)):
            grubcfg.write('grub_theme=/boot/%s\n' % grub_theme)
        grubcfg.write('timeout=%s\n' % timeout)
        grubcfg.close()


    def _configBootKvers(self,stage_dir):
        kvers = self._detectLinuxVersion(stage_dir)
        if len(kvers) < 1:
            self.log.critical('failed to find linux kernel image to include in boot conf')
            raise FllError
        return kvers

    def _configBootTimeout(self):
        timeout = self.conf['options'].get('boot_timeout')
        if not timeout:
            timeout = '-1'
        return timeout

    def _configBootCmdline(self):
        cmdline =  self.conf['options'].get('boot_cmdline')
        if not cmdline:
            cmdline = ''
        return cmdline

    def configureGrub(self):
        '''Write final GRUB configuration for live media.'''
        stage_dir = os.path.join(self.temp, 'staging')
        boot_dir = os.path.join(stage_dir, 'boot')
        grub_dir = os.path.join(boot_dir, 'grub')

        if not os.path.isdir(grub_dir):
            return
        self.log.debug('writing grub config for live media')

        kvers = self._configBootKvers(stage_dir)
        timeout = self._configBootTimeout()
        cmdline =  self._configBootCmdline()

        self._writeGrubCfg(stage_dir, boot_dir, grub_dir, kvers,
                           timeout, cmdline)


    def __md5sum(self, filename):
        '''Calculate md5sum of a file and return it.'''
        return apt_pkg.Hashes(open(filename, 'rb')).hashes.find('MD5Sum').hashvalue

    def __hashsums(self, filename):
        '''Calculate hashsums of a file and return it.'''
        hashsums = apt_pkg.Hashes(open(filename, 'rb')).hashes
        return hashsums.find('MD5Sum').hashvalue, hashsums.find('SHA256').hashvalue, \
            hashsums.find('SHA512').hashvalue


    def _md5sums(self, base, dirpath, fnames):
        '''Function given to os.path.walk of self.writeMd5Sums().'''
        for f in fnames:
            filepath = os.path.join(dirpath, f)
            filename = filepath.partition(base)[2].lstrip('/')

            if not os.path.isfile(filepath) or f == 'md5sums':
                continue
            if dirpath.endswith('grub') and f.find('stage') >= 0:
                continue
            if f.find('grub_eltorito') >= 0:
                continue
            if f.find('iso_uuid') >= 0:
                continue

            md5sums = None
            try:
                md5sums = open(os.path.join(base, 'md5sums'), 'a')
                md5sums.write("%s *%s\n" % (self.__md5sum(filepath), filename))
            except IOError:
                self.log.exception('failed to write md5sums file')
                raise FllError
            finally:
                if md5sums:
                    md5sums.close()


    def writeMd5Sums(self):
        '''Calculate md5sums of major release contents.'''
        self.log.info('calculating md5sums of live media...')
        stage = os.path.join(self.temp, 'staging')
        for dirpath, dirnames, files in os.walk(stage):
            self._md5sums(stage, dirpath, files)

    def _signFile(self, file):
        '''Sign a file with hashkey if available.'''
        if self.opts.k:
            self.log.info('Signing file %s...' % file)
            cmd = ['gpg', '-s', '--default-key']
            cmd.append(self.opts.k)
            cmd.append(file)
            self._execCmd(cmd)
        else:
            self.log.info('Not signing file %s: No key given.' % file)

    def __archManifest(self, arch):
        '''Write manifest information to file.'''
        pkgs = list(self.pkgs[arch]['manifest'].keys())
        pkgs.sort(key=len)
        l = len(pkgs[-1])
        pkgs.sort()

        return ["%s %s\n" % (p.ljust(l), self.pkgs[arch]['manifest'][p])
                for p in pkgs]


    def _writeManifests(self, file):
        '''Write package manifest lists.'''
        archs = list(self.conf['archs'].keys())
        for arch in archs:
            manifest_name = '%s.%s.manifest' % (file, arch)

            manifest_file = os.path.join(self.opts.o, manifest_name)

            manifest = None
            try:
                manifest = open(manifest_file, 'w')
                manifest.writelines(self.__archManifest(arch))
            except IOError:
                self.log.exception('failed to write file: %s' % manifest_file)
                raise FllError
            finally:
                if manifest:
                    manifest.close()
                    os.chown(manifest_file, self.opts.u, self.opts.g)


    def _writeSources(self, file):
        '''Write source URI lists.'''
        sources_list = []
        archs = list(self.conf['archs'].keys())
        for arch in archs:
            sources_list.extend(self.pkgs[arch]['source'])
        sources_list = self.__filterList(sources_list, dup_warn = False)

        sources_name = file + '.sources'
        sources_file = os.path.join(self.opts.o, sources_name)

        sources = None
        try:
            sources = open(sources_file, 'w')
            sources.writelines(["%s\n" % s for s in sources_list])
        except IOError:
            self.log.exception('failed to write file: %s' % sources_file)
            raise FllError
        finally:
            if sources:
                sources.close()
                os.chown(sources_file, self.opts.u, self.opts.g)

        cached = dict()
        for r in self.conf['repos']:
            if self.conf['repos'][r].get('cached'):
                cached_uri = self.conf['repos'][r]['cached']
                uri = self.conf['repos'][r]['uri']
                cached[cached_uri.rstrip('/')] = uri.rstrip('/')

        if len(list(cached.keys())) > 0:
            os.rename(sources_file, sources_file + '-cached')
        else:
            return

        sources = None
        try:
            sources = open(sources_file, 'w')
            for s in sources_list:
                for c in list(cached.keys()):
                    if s.startswith(c):
                        s = s.replace(c, cached[c], 1)
                        break
                sources.write('%s\n' % s)
        except IOError:
            self.log.exception('failed to write file: %s' % sources_file)
            raise FllError
        finally:
            if sources:
                sources.close()
                os.chown(sources_file, self.opts.u, self.opts.g)


    def genLiveMedia(self):
        '''Generate live media iso image.'''
        stage = os.path.join(self.temp, 'staging')

        distro_name = self.conf['distro']['FLL_DISTRO_NAME']
        fll_image_dir = self.conf['distro']['FLL_IMAGE_DIR']
        fll_image_file = self.conf['distro']['FLL_IMAGE_FILE']

        iso_name = self._getDistroMediaName() + '.iso'

        iso_file = os.path.join(self.opts.o, iso_name)
        md5_file = iso_file + '.md5'
        sha256_file = iso_file + '.sha256'
        sha512_file = iso_file + '.sha512'

        xorriso_cmd = 'xorriso -report_about HINT -as mkisofs -graft-points  -pad -l'
        gpthybrid_cmd = os.path.join(self.opts.s, 'gpthybrid')

        if self.opts.v:
            xorriso_cmd += ' -v'
            gpthybrid_cmd += ' --verbose'

        if os.path.isdir(os.path.join(stage, 'boot/grub')):
            xorriso_cmd += ' -no-emul-boot -boot-load-size 4 -boot-info-table'
            gpthybrid_cmd += ' --label %s --iso %s' % (self.uuid, iso_file)
            if os.path.isfile(os.path.join(stage,
                                           'boot/grub/i386-pc/grub_eltorito')):
                xorriso_cmd += ' -b boot/grub/i386-pc/grub_eltorito --grub2-boot-info'
                xorriso_cmd += ' --grub2-mbr %s' % \
                    os.path.join(stage, 'boot/grub/i386-pc/boot_hybrid.img')
                for arch in list(self.conf['archs'].keys()):
                    if os.path.isfile(os.path.join(stage, fll_image_dir,
                                                   self._getDistroImageFile(arch))):
                        gpthybrid_cmd += ' %s' % os.path.join(fll_image_dir,
                                                              self._getDistroImageFile(arch))
                if os.path.isfile(os.path.join(stage, fll_image_dir,
                                               '%s.2' % fll_image_file)):
                    gpthybrid_cmd += " %s" % os.path.join(fll_image_dir,
                                                          '%s.2' % fll_image_file)
            else:
                self.log.critical('failed to find grub El Torito image file')
                raise FllError
        else:
            self.log.critical('grub is required to boot live media')
            raise FllError

        xorriso_cmd += ' --modification-date=%s' % self.uuid.replace("-","")
        if os.path.isfile(os.path.join(stage, 'efi.img')):
            xorriso_cmd += ' --efi-boot efi.img -efi-boot-part --efi-boot-image'
            gpthybrid_cmd += ' efi.img'

        xorriso_cmd += ' --protective-msdos-label -V %s' % distro_name[:32]
        if os.path.isdir(os.path.join(stage, 'boot')):
            xorriso_cmd += ' --sort-weight 0 / --sort-weight 1 /boot'
            if os.path.isdir(os.path.join(stage, 'boot/grub')):
                xorriso_cmd += ' --sort-weight 2 /boot/grub'
        xorriso_cmd += ' -x iso_uuid -x genisoimage.sort'
        xorriso_cmd += ' -o %s %s' % (iso_file, stage)

        self.log.info('generating iso image of live media...')
        self._execCmd(xorriso_cmd.split())

        self.log.info('converting to hybrid iso...')
        self._execCmd(gpthybrid_cmd.split())

        os.chown(iso_file, self.opts.u, self.opts.g)

        self.log.info('calculating hashsums of live media iso image...')
        md5 = None
        sha256 = None
        sha512 = None
        try:
            md5 = open(md5_file, 'w')
            sha256 = open(sha256_file, 'w')
            sha512 = open(sha512_file, 'w')
            md5sum, sha256sum, sha512sum = self.__hashsums(iso_file)
            md5.write("%s *%s\n" % (md5sum, os.path.basename(iso_file)))
            sha256.write("%s *%s\n" % (sha256sum, os.path.basename(iso_file)))
            sha512.write("%s *%s\n" % (sha512sum, os.path.basename(iso_file)))
        except IOError:
            self.log.exception('failed to write hashsums files')
            raise FllError
        finally:
            if md5:
                md5.close()
                os.chown(md5_file, self.opts.u, self.opts.g)
                if self.opts.k:
                    self.log.info('signing md5 hash...')
                    self._signFile(md5_file)
                    os.chown(md5_file + '.gpg', self.opts.u, self.opts.g)
            if sha256:
                sha256.close()
                os.chown(sha256_file, self.opts.u, self.opts.g)
                if self.opts.k:
                    self.log.info('signing sha256 hash...')
                    self._signFile(sha256_file)
                    os.chown(sha256_file + '.gpg', self.opts.u, self.opts.g)
            if sha512:
                sha512.close()
                os.chown(sha512_file, self.opts.u, self.opts.g)
                if self.opts.k:
                    self.log.info('signing sha512 hash...')
                    self._signFile(sha512_file)
                    os.chown(sha512_file + '.gpg', self.opts.u, self.opts.g)

        self._writeManifests(os.path.splitext(iso_file)[0])
        if not self.opts.B:
            self._writeSources(os.path.splitext(iso_file)[0])

        for f in glob.glob('%s*' % os.path.splitext(iso_file)[0]):
            self.log.info(f)

        if self.opts.U:
            self._execCmd("update-grub")


    def buildChroots(self):
        '''Main loop to call all chroot building functions.'''
        archs = list(self.conf['archs'].keys())
        codename = self.opts.C
        for arch in archs:
            self._bootStrap(arch)
            self._dpkgAddDivert(arch)
            self._defaultEtc(arch)
            self._distroDefaultEtc(arch)
            self._preseedDebconf(arch)
            self._primeApt(arch)
            self._installPkgs(arch, codename)
            self._postInst(arch)
            self._collectManifest(arch)
            self._finalEtc(arch)
            self._dpkgUnDivert(arch)
            self._makeInitramfs(arch)
            self._cleanChroot(arch)
            self._chrootSquashfs(arch)
            self._stageArch(arch)
            self._nukeChroot(arch)


    def main(self):
        '''Main loop.'''
        self.checkOpts()
        self.parseConf()
        self.parsePkgProfile()
        self.stageBuildArea()

        if self.opts.n:
            sys.exit(0)

        self.buildChroots()
        self.secondSquashfs()
        self.configureGrub()
        self.writeMd5Sums()
        self.genLiveMedia()

        duration = datetime.datetime.now(datetime.UTC) - self.time
        self.log.info('build duration was %d minutes and %d seconds' %
                      divmod(duration.seconds, 60))


if __name__ == '__main__':
    p = optparse.OptionParser(usage = 'fll -c <config file> [-b <directory> ' +
                              '-o <directory> -l <file>] [-BdDpqv]')

    p.add_option('-a', '--arch', dest = 'a', action = 'store',
                 type = 'string', metavar = '<arch>',
                 help = 'Build architecture, overrides config file.')

    p.add_option('-b', '--build', dest = 'b', action = 'store',
                 type = 'string', metavar = '<directory>',
                 help = 'Build directory. A large amount of free space ' +
                 'is required.')

    p.add_option('-B', '--binary', dest = 'B', action = 'store_true',
                 help = 'Do binary build only. Disable generation of ' +
                 'URI lists. Default: %default')

    p.add_option('-c', '--config', dest = 'c', action = 'store',
                 type = 'string', metavar = '<config file>',
                 help = 'Configuration file. This option may be used ' +
                 'more than once to process multiple configurations. ' +
                 'A configuration file must be specified.')

    p.add_option('-d', '--debug', dest = 'd', action = 'store_true',
                 help = 'Enable debug mode. Extra output will be ' +
                 'to assist in development. Default: %default')

    p.add_option('-D', '--dummy', dest = 'D', action = 'store_true',
                 help = 'Enable dummy mode. Download only ' +
                 'and no squashfs. Default: %default')

    p.add_option('-g', '--gid', dest = 'g', action = 'store',
                 type = 'int', metavar = '<group id>',
                 help = optparse.SUPPRESS_HELP)

    p.add_option('-k', '--hashkey', dest = 'k', action = 'store',
                 type = 'string', metavar = '<key id>', help = 'Set key ' +
                 'to sign MD5 and SHA256 hashes of the generated ISOs.')

    p.add_option('-l', '--log', dest = 'l', action = 'store',
                 type = 'string', metavar = '<file>',
                 help = 'Log debug output to file. Note that when ' +
                 'logging is enabled, output to the console is buffered.')

    p.add_option('-n', '--non-root', dest = 'n', action = 'store_true',
                 help = optparse.SUPPRESS_HELP)

    p.add_option('-o', '--output', dest = 'o', action = 'store',
                 type = 'string', metavar = '<directory>',
                 help = 'Output directory, where the product of this ' +
                 'program will be generated.')

    p.add_option('-p', '--profile', dest = 'p', action = 'store',
                 type = 'string', metavar = '<profile>',
                 help = 'Package profile, overrides config file.')

    p.add_option('-P', '--preserve', dest = 'P', action = 'store_true',
                 help = 'Preserve build directory. Disable automatic ' +
                 'cleanup of the build area at exit.')

    p.add_option('-q', '--quiet', dest = 'q', action = 'store_true',
                 help = 'Enable quiet mode. Only high priority messages ' +
                 'will be generated.')

    p.add_option('-s', '--share', dest = 's', action = 'store',
                 type = 'string', metavar = '<directory>',
                 help = optparse.SUPPRESS_HELP)

    p.add_option('-u', '--uid', dest = 'u', action = 'store',
                 type = 'int', metavar = '<user id>',
                 help = optparse.SUPPRESS_HELP)

    p.add_option('-U', '--update-grub', dest = 'U', action = 'store_true',
                 help = 'Execute update-grub after generating iso media.')

    p.add_option('-v', '--verbose', dest = 'v', action = 'store_true',
                 help = 'Enable verbose mode. All messages will be ' +
                 'generated, such as announcing current operation.')

    p.set_defaults(b = None, B = False, d = False, D = False, g = os.getgid(),
                   k = None, l = None, n = False, o = None, p = None,
                   P = False, q = False, s = None, u = os.getuid(), v = False)

    options = p.parse_args()[0]

    try:
        fll = FLLBuilder(options)
        fll.main()
    except KeyboardInterrupt:
        pass
    except FllError:
        sys.exit(1)
