#!/usr/bin/python3 -tt
# -*- coding: utf-8 -*-

__author__    = 'Kel Modderman'
__copyright__ = '(C) 2008-2024 Kel Modderman <kelvmod@gmail.com>'
__license__   = 'GPLv2 or any later version'

from configobj import ConfigObj
from io import open
import apt_pkg
import apt
import argparse
import atexit
import datetime
import fileinput
import functools
import glob
import logging
import os
import sys
import shutil
import signal
import stat
import subprocess
import tempfile
import time

def restore_sigpipe():
    """Convenience function so that subprocess may be executed with
    SIGPIPE restored to default (http://bugs.python.org/issue1652)."""
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)

def deduplicate_list(original_list: list) -> list:
    '''Return a list containing no duplicate items given a list that
    may have duplicate items.'''
    deduplicated_list = list(set(original_list))
    deduplicated_list.sort()
    return deduplicated_list

def multiline_to_list(lines: str) -> list:
    '''Return a list of stripped strings given a multiline string. Filter
    commented strings.'''
    return [s.strip() for s in lines.splitlines()
            if s.strip() and not s.lstrip().startswith('#')]

class FllLocalesError(Exception):
    """
    An FllError class for use by FllLocales.
    """
    pass


class FllLocales(object):
    """
    A class which provides the ability to determine lists of locale specific
    Debian packages using it's detect_locale_packages method.

    Arguments:
    cache    - an apt_pkg cache object
    packages - a list or dict of package names which are installed, or are
               going to be installed. Locale specific packages are selected
               for packages in this data structure.
    map      - a dict which maps package names with a list of package prefixes
               from which the locale string pattern matching can be used
               to match locale support packages. The prefered input for map is:
               ConfigObj('data/fll-locales-pkg-map').
    """
    def __init__(self, cache: apt_pkg.Cache, packages: list, locale_map: dict) -> None:
        self.loc_pkgs_set = set()
        for pkg in cache.packages:
            if not pkg.version_list:
                continue
            if pkg.name not in packages:
                continue
            for loc_pkg in list(locale_map.keys()):
                if pkg.name == loc_pkg:
                    loc_pkg_prefix_list = locale_map.get(loc_pkg)
                    for loc_pkg_prefix in loc_pkg_prefix_list:
                        self.loc_pkgs_set.add(loc_pkg_prefix)
                    break

        self.loc_pkgs_list_dict = dict()
        for loc_pkg in self.loc_pkgs_set:
            self.loc_pkgs_list_dict[loc_pkg] = list()
        for pkg in cache.packages:
            if not pkg.version_list:
                continue
            for loc_pkg in self.loc_pkgs_set:
                if pkg.name.startswith(loc_pkg + '-'):
                    self.loc_pkgs_list_dict[loc_pkg].append(pkg.name)

    def compute_locale_loc_suf_list(self, locale: str) -> list:
        """
        Compute a list of locale package name suffixes. The sequence of
        suffixes are in preferential order, the lowest index being most
        preferential.

        This is a very private method, used by detect_locale_packages.

        Arguments:
        locale - a locale string (eg. en_AU, pt_PT etc.)
        """
        loc_suf_list = list()
        try:
            ll, cc = locale.lower().split('_')
        except ValueError as e:
            raise FllLocalesError(e)
        loc_suf_list.append(f'{ll}-{cc}')
        loc_suf_list.append(f'{ll}{cc}')
        loc_suf_list.append(ll)

        if ll != 'en':
            loc_suf_list.append('i18n')

        return loc_suf_list

    def detect_locale_packages(self, locale: str) -> list:
        """
        Process the data structures created at FllLocales instantiation and
        return a list of package names which are the likely best candidates
        for the locale string given as argument.

        Arguments:
        locale - a locale string (eg. en_AU, pt_PT etc.)
        """
        suffixes = self.compute_locale_loc_suf_list(locale)

        loc_pkg_dict = dict()
        for pkg in self.loc_pkgs_set:
            loc_pkgs_list = self.loc_pkgs_list_dict.get(pkg)
            if not loc_pkgs_list:
                continue
            if pkg not in loc_pkg_dict:
                loc_pkg_dict[pkg] = dict()
            for loc_pkg in loc_pkgs_list:
                for idx, suf in enumerate(suffixes):
                    if loc_pkg == '-'.join([pkg, suf]):
                       loc_pkg_dict[pkg][idx] = loc_pkg

        packages = list()
        for pkg in self.loc_pkgs_set:
            pkg_candidates = loc_pkg_dict.get(pkg)
            if not pkg_candidates:
                continue
            best = min(pkg_candidates)
            packages.append(pkg_candidates[best])

        return packages


class FllError(Exception):
    '''A generic error handler that does nothing.'''
    pass


class FLLBuilder(object):
    env = {'LANGUAGE': 'C', 'LC_ALL': 'C', 'LANG' : 'C', 'HOME': '/root',
           'PATH': '/usr/sbin:/usr/bin:/sbin:/bin', 'SHELL': '/bin/bash',
           'DEBIAN_FRONTEND': 'noninteractive', 'DEBIAN_PRIORITY': 'critical',
           'DEBCONF_NOWARNINGS': 'yes'}

    diverts = ['/usr/sbin/policy-rc.d',
               '/usr/sbin/modprobe',
               '/usr/sbin/insmod',
               '/usr/sbin/update-grub',
               '/usr/sbin/update-initramfs']


    def __init__(self, options):
        '''Accept options dict, setup logging.'''
        self.opts = options
        self.conf = None
        self.temp = None

        self.log = logging.getLogger('log')
        self.log.setLevel(logging.DEBUG)

        self.time = time.perf_counter()
        self.date = datetime.datetime.now(datetime.UTC)
        self.uuid = self.date.strftime('%Y-%m-%d-%H-%M-%S-00')
        self.timestamp = self.date.strftime('%Y%m%d%H%M')


    def prep_dir(self, dirname: str) -> str:
        '''Set up working directories.'''
        if not os.path.isdir(dirname):
            try:
                os.makedirs(dirname)
                os.chown(dirname, self.opts.uid, self.opts.gid)
            except:
                self.log.exception(f'failed to create directory: {dirname}')
                raise FllError

        return os.path.realpath(dirname)


    def init_logger(self, lvl: str) -> None:
        '''Set up the logger.'''
        fmt = logging.Formatter('%(asctime)s %(levelname)-5s - %(message)s')
        out = logging.StreamHandler()
        out.setFormatter(fmt)
        out.setLevel(lvl)
        self.log.addHandler(out)


    def init_logfile(self, log_filename: str) -> None:
        '''Set up a log file.'''
        log_filename = os.path.realpath(log_filename)
        dirname = os.path.dirname(log_filename)
        self.prep_dir(dirname)

        try:
            fmt = logging.Formatter('%(asctime)s %(levelname)-5s ' +
                                     '%(message)s')
            logfile = logging.FileHandler(filename = log_filename, mode = 'w')
            logfile.setFormatter(fmt)
            logfile.setLevel(logging.DEBUG)
            self.log.addHandler(logfile)
            os.chown(log_filename, self.opts.uid, self.opts.gid)
        except:
            self.log.exception(f'failed to setup logfile: {log_filename}')
            raise FllError


    def check_options(self) -> None:
        '''Check and provide default class options.'''
        if self.opts.debug:
            self.init_logger(logging.DEBUG)
        else:
            self.init_logger(logging.INFO)

        if self.opts.log_file:
            self.init_logfile(self.opts.log_file)

        if self.opts.config:
            if os.path.isfile(self.opts.config):
                self.opts.config = os.path.realpath(self.opts.config)
            else:
                self.log.critical(f'configuration file does not exist: {self.opts.config}')
                raise FllError
        else:
            self.log.critical('no config file specified on command line')
            raise FllError

        if self.opts.share:
            if not os.path.isdir(self.opts.share):
                self.log.critical(f'share directory not exist: {self.opts.share}')
                raise FllError

        self.opts.share = os.path.realpath(self.opts.share)

        if self.opts.output_dir:
            self.opts.output_dir = self.prep_dir(self.opts.output_dir)

        if self.opts.build:
            self.opts.build = self.prep_dir(self.opts.build)



    def process_defaults(self, defaults: dict) -> None:
        '''Form a distro-defaults data structure to be written to
        /etc/default/distro of each chroot, and used for release name.'''
        for key in ['FLL_DISTRO_NAME', 'FLL_IMAGE_DIR', 'FLL_IMAGE_FILE',
                    'FLL_MEDIA_NAME', 'FLL_LIVE_USER',
                    'FLL_LIVE_USER_GROUPS', 'FLL_GFXBOOT_THEME']:
            if not defaults.get(key):
                self.log.critical(f'{key} is required in "distro" section of config file')
                raise FllError

        for key in ['FLL_DISTRO_NAME', 'FLL_IMAGE_DIR', 'FLL_IMAGE_FILE',
                    'FLL_LIVE_USER', 'FLL_DISTRO_CODENAME_SAFE',
                    'FLL_DISTRO_CODENAME_REV_SAFE']:
            if not defaults.get(key):
                continue
            if not defaults[key].isalnum():
                self.log.critical(f'{key} must be alphanumeric: {defaults[key]}')
                raise FllError
            elif defaults[key].find(' ') >= 0:
                self.log.critical(f'{key} must not contain whitespace: {defaults[key]}')
                raise FllError

        version = defaults.get('FLL_DISTRO_VERSION')
        if version and version != 'snapshot':
            if not defaults.get('FLL_DISTRO_CODENAME_SAFE'):
                self.log.critical("'FLL_DISTRO_VERSION' is set, but " +
                                  "'FLL_DISTRO_CODENAME_SAFE' is not")
                raise FllError

            for key in ['FLL_DISTRO_CODENAME', 'FLL_DISTRO_CODENAME_REV']:
                safe = key + '_SAFE'
                if defaults.get(safe) and not defaults.get(key):
                    defaults[key] = defaults[safe]
        else:
            defaults['FLL_DISTRO_VERSION'] = 'snapshot'


    def get_distro_imagefile(self, arch: str) -> str:
        '''Return image file that compressed chroot will be archived to.'''
        image_file = self.conf['distro']['FLL_IMAGE_FILE']
        if arch == 'i386':
            image_file += '.686'
        else:
            image_file += '.%s' % arch

        return image_file


    def get_distro_stamp(self) -> str:
        '''Return a string suitable for the distro stamp file.'''
        defaults = self.conf['distro']
        stamp = ' '.join([defaults['FLL_DISTRO_NAME'], defaults['FLL_DISTRO_VERSION']])
        if defaults.get('FLL_DISTRO_VERSION') == 'snapshot':
            stamp += ' - %s' % self.conf['packages']['profile']
            try:
                stamp += ' %s' % self.conf['sourcedistro']['codename']
            except KeyError:
                pass
        else:
            if defaults.get('FLL_DISTRO_CODENAME_REV'):
                stamp += ' - %s' % defaults['FLL_DISTRO_CODENAME']
                stamp += ' %s -' % defaults['FLL_DISTRO_CODENAME_REV']
            else:
                stamp += ' %s -' % defaults['FLL_DISTRO_CODENAME']

            stamp += ' %s' % self.conf['packages']['profile']

        stamp += ' - (%s)' % self.timestamp

        self.log.debug('stamp: %s' % stamp)
        return stamp


    def get_distro_stamp_safe(self) -> str:
        '''Return a string suitable for the distro stamp file.'''
        defaults = self.conf['distro']
        name = '-'.join([defaults['FLL_DISTRO_NAME'], defaults['FLL_DISTRO_VERSION']])
        if defaults.get('FLL_DISTRO_VERSION') == 'snapshot':
            name += '-%s' % self.conf['packages']['profile']
            try:
                name += '-%s' % self.conf['sourcedistro']['codename']
            except KeyError:
                pass
        else:
            if defaults.get('FLL_DISTRO_CODENAME_REV'):
                name += '-%s-%s' % (defaults['FLL_DISTRO_CODENAME_SAFE'],
                                    defaults['FLL_DISTRO_CODENAME_REV_SAFE'])
            else:
                name += '-%s' % defaults['FLL_DISTRO_CODENAME_SAFE']

            name += '-%s' % self.conf['packages']['profile']

        name += '-' + '-'.join(list(self.conf['archs'].keys()))
        name += '-%s' % self.timestamp

        self.log.debug(f'name: {name}')
        return name


    def validate_conf(self) -> None:
        '''Process configuration options.'''
        arch = ''
        if self.opts.arch:
            arch = self.opts.arch
        elif not self.conf.get('archs'):
            arch = subprocess.Popen(['dpkg', '--print-architecture'],
                                    preexec_fn=restore_sigpipe,
                                    stdout=subprocess.PIPE).communicate()[0].decode().rstrip()

        if len(arch):
            self.log.debug(f'arch: {arch}')
            if arch not in list(self.conf['archs'].keys()):
                self.conf['archs'] = {arch: dict()}
            else:
                for arch2 in list(self.conf['archs'].keys()):
                    if arch != arch2:
                        del self.conf['archs'][arch2]

        for arch in list(self.conf['archs'].keys()):
            if 'linux' not in self.conf['archs'][arch]:
                if arch == 'i386':
                    cpu = '486'
                else:
                    cpu = arch

                linux = cpu

                self.conf['archs'][arch].setdefault('linux', [ linux ])
            else:
                linux = self.conf['archs'][arch]['linux']
                if isinstance(linux, str):
                    self.conf['archs'][arch]['linux'] = [ linux ]
                elif not isinstance(linux, list):
                    self.log.critical(f'invalid linux for arch {arch} in config')
                    raise FllError

        if len(list(self.conf['repos'].keys())) < 1:
            self.log.critical('no apt repos were specified in build config')
            raise FllError

        if 'sourcedistro' in self.conf:
            if 'name' in self.conf['sourcedistro']:
                self.opts.source_distro_name = self.conf['sourcedistro']['name']
            if 'codename' in self.conf['sourcedistro']:
                self.opts.source_distro_codename = self.conf['sourcedistro']['codename']

        if self.opts.source_distro_name in self.conf['repos']:
            # trump suite definition in 'repos' section - alternatively we
            # could bail out in error of the codename <-> suite mismatch
            self.conf['repos'][self.opts.source_distro_name]['suite'] = self.opts.source_distro_codename
        else:
            self.log.critical(f'{self.opts.source_distro_name} repo not configured in build config')
            raise FllError

        for repo in list(self.conf['repos'].keys()):
            if self.conf['repos'][repo].get('trivial'):
                words = ['label', 'uri']
            elif self.conf['repos'][repo].get('sources_uri'):
                words = []
            else:
                words = ['label', 'uri', 'suite', 'components']

            for word in words:
                if word not in self.conf['repos'][repo]:
                    self.log.critical(f'"{word}" must be defined for apt repo "{repo}"')
                    raise FllError

        if self.opts.profile:
            self.conf['packages']['profile'] = self.opts.profile
        elif 'profile' not in self.conf['packages']:
            self.conf['packages']['profile'] = 'kde-lite'
        self.log.debug('profile: %s' % self.conf['packages']['profile'])

        if 'i18n' not in self.conf['packages'] or \
           not multiline_to_list(self.conf['packages']['i18n']):
            self.conf['packages']['i18n'] = 'en_US'
        i18n = multiline_to_list(self.conf['packages']['i18n'])
        self.log.debug('i18n: %s' % ' '.join(i18n))

        if 'hashkey' not in self.conf['options']:
            self.log.debug('no key for signing ISO hashes!')
            self.opts.hashkey = None
        else:
            self.opts.hashkey = self.conf['options'].get('hashkey')
            self.log.debug(f'using key {self.opts.hashkey} for signing')

        if not 'options' in self.conf:
            self.conf['options'] = dict()

        if self.conf['options'].get('build_dir'):
            if not self.opts.build:
                dirname = self.conf['options']['build_dir']
                self.opts.build = self.prep_dir(dirname)
        else:
            if not self.opts.build:
                self.opts.build = self.prep_dir(os.getcwd())

        if self.conf['options'].get('output_dir'):
            if not self.opts.output_dir:
                dirname = self.conf['options']['output_dir']
                self.opts.output_dir = self.prep_dir(dirname)
        else:
            if not self.opts.output_dir:
                self.opts.output_dir = self.prep_dir(os.getcwd())

        if self.conf['options'].get('build_log'):
            if not self.opts.log_file:
                self.opts.log_file = self.conf['options']['build_log']
                self.init_logfile(self.opts.log_file)

        if self.conf['options'].get('http_proxy'):
            self.env['http_proxy'] = self.conf['options']['http_proxy']

        if self.conf['options'].get('ftp_proxy'):
            self.env['ftp_proxy'] = self.conf['options']['ftp_proxy']

        self.conf['options'].setdefault('apt_preferences', None)
        self.conf['options'].setdefault('apt_recommends', 'no')
        self.conf['options'].setdefault('media_include', None)

        if 'distro' in self.conf:
                self.process_defaults(self.conf['distro'])
                self.log.debug('distro-defaults:')
                for key, value in list(self.conf['distro'].items()):
                    self.log.debug(f'{key}="{value}"')
                self.log.debug('testing stamp/name:')
                self.get_distro_stamp()
                self.get_distro_stamp_safe()
        else:
            self.log.critical('distro section not found in build config')
            raise FllError


    def parse_conf(self) -> None:
        '''Parse build configuration file and return it in a dict.'''
        self.log.info('reading configuration file...')

        self.conf = ConfigObj(self.opts.config)
        self.validate_conf()


    def expand_pkg_profile(self, arch: str, profile: str, profile_dir: str) -> dict:
        '''Return a dict, arch string as key and package, debconf and postinst
        lists.'''
        pkgs = {'debconf': [], 'packages': [], 'postinst': []}

        linux_meta = ['linux-image', 'linux-headers']
        for kvers in self.conf['archs'][arch]['linux']:
            pkgs['packages'].extend(['-'.join([l, kvers]) for l in linux_meta])

        pname = os.path.basename(profile)
        self.log.debug(f'processing package profile for {arch}: {pname}')

        pfile = ConfigObj(profile)

        if 'desc' in pfile:
            for line in multiline_to_list(pfile['desc']):
                self.log.debug(f'  {line}')

        if 'debconf' in pfile:
            self.log.debug('debconf:')
            for debconf in multiline_to_list(pfile['debconf']):
                pkgs['debconf'].append(debconf)
                self.log.debug(f'  {debconf}')

        if 'debconf' in self.conf['packages']:
            self.log.debug('debconf (config):')
            for debconf in multiline_to_list(self.conf['packages']['debconf']):
                pkgs['debconf'].append(debconf)
                self.log.debug(f'  {debconf}')

        if 'packages' in pfile:
            self.log.debug('packages:')
            for pkg in multiline_to_list(pfile['packages']):
                pkgs['packages'].append(pkg)
                self.log.debug(f'  {pkg}')

        if 'packages' in self.conf['packages']:
            self.log.debug('packages (config):')
            for pkg in multiline_to_list(self.conf['packages']['packages']):
                pkgs['packages'].append(pkg)
                self.log.debug(f'  {pkg}')

        if arch in pfile:
            self.log.debug(f'packages ({arch}):')
            for pkg in multiline_to_list(pfile[arch]):
                pkgs['packages'].append(pkg)
                self.log.debug(f'  {pkg}')

        deps = []
        if 'deps' in pfile:
            self.log.debug('deps:')
            for dep in multiline_to_list(pfile['deps']):
                deps.append(dep)
                self.log.debug(f'  {dep}')

        if 'deps' in self.conf['packages']:
            self.log.debug('deps (config):')
            for dep in multiline_to_list(self.conf['packages']['deps']):
                deps.append(dep)
                self.log.debug(f'  {dep}')

        if os.path.isfile(profile + '.postinst'):
            self.log.debug(f'registering postinst script: {profile}.postinst')
            pkgs['postinst'].append(profile + '.postinst')

        self.log.debug('---')

        for dep in deps:
            depfile = os.path.join(profile_dir, 'deps', dep)

            if not os.path.isfile(depfile):
                self.log.critical(f'no such dep file: {depfile}')
                raise FllError

            dname = os.path.basename(depfile)
            self.log.debug(f'processing dependency file: {dname}')

            dfile = ConfigObj(depfile)

            if 'desc' in dfile:
                for line in multiline_to_list(dfile['desc']):
                    self.log.debug(f'  {line}')

            if 'debconf' in dfile:
                self.log.debug('debconf:')
                for debconf in multiline_to_list(dfile['debconf']):
                    pkgs['debconf'].append(debconf)
                    self.log.debug(f'  {debconf}')

            if 'packages' in dfile:
                self.log.debug('packages:')
                for pkg in multiline_to_list(dfile['packages']):
                    pkgs['packages'].append(pkg)
                    self.log.debug(f'  {pkg}')

            if arch in dfile:
                self.log.debug(f'packages ({arch}):')
                for pkg in multiline_to_list(dfile[arch]):
                    pkgs['packages'].append(pkg)
                    self.log.debug(f'  {pkg}')

            if os.path.isfile(depfile + '.postinst'):
                self.log.debug(f'registering postinst script: {depfile}.postinst')
                pkgs['postinst'].append(depfile + '.postinst')

            self.log.debug('---')

        self.log.debug(f'package summary for {arch}:')
        pkgs['packages'].sort()
        for pkg in pkgs['packages']:
            self.log.debug(f'  {pkg}')

        self.log.debug(f'debconf summary for {arch}:')
        pkgs['debconf'].sort()
        for debconf in pkgs['debconf']:
            self.log.debug(f'  {debconf}')

        pkgs['packages'] = deduplicate_list(pkgs['packages'])

        return pkgs


    def parse_pkg_profile(self) -> None:
        '''Parse packages profile file(s).'''
        self.log.info('processing package profile: %s' %
                      self.conf['packages']['profile'])

        profiles_dir = os.path.join(self.opts.share, 'profiles')
        profile = os.path.join(profiles_dir, self.conf['packages']['profile'])

        if not os.path.isfile(profile):
            self.log.critical(f'no such package profile: {profile}')
            raise FllError

        self.pkgs = dict()
        for arch in list(self.conf['archs'].keys()):
            self.pkgs[arch] = self.expand_pkg_profile(arch, profile, profiles_dir)
            try:
                self.pkgs[arch]['packages'] += \
                    multiline_to_list(self.conf['packages'][arch])
            except KeyError:
                pass


    def get_debconf_list(self, arch: str) -> list:
        '''Return debconf list for arch. Dynamically generate locales
        debconf configuration based on i18n configuration in flk.conf.'''
        i18n_list = multiline_to_list(self.conf['packages']['i18n'])
        if len(i18n_list) == 0:
            i18n_list = 'en_US'
        i18n_debconf = 'locales locales/locales_to_be_generated multiselect '
        for i18n in i18n_list:
            i18n_debconf += f'{i18n}.UTF-8 UTF-8,'
        i18n_debconf = i18n_debconf.rstrip(',')
        self.pkgs[arch]['debconf'].append(i18n_debconf)

        return self.pkgs[arch]['debconf']


    def get_package_list(self, arch: str) -> list:
        '''Return package list for arch.'''
        return self.pkgs[arch]['packages']


    def get_postinst_list(self, arch: str) -> list:
        '''Return postinst list for arch.'''
        return self.pkgs[arch]['postinst']


    def stage_build_directory(self) -> None:
        '''Prepare temporary directory for chroots and result staging area.'''
        self.log.debug('preparing build area...')

        self.temp = tempfile.mkdtemp(prefix = 'fll_', dir = self.opts.build)
        os.chown(self.temp, self.opts.uid, self.opts.gid)

        atexit.register(self.cleanup)

        stage = os.path.join(self.temp, 'staging')
        os.mkdir(stage)
        os.mkdir(os.path.join(stage, 'boot'))
        os.mkdir(os.path.join(stage, self.conf['distro']['FLL_IMAGE_DIR']))

        media_include = self.conf['options'].get('media_include')
        if media_include and os.path.isdir(media_include):
            try:
                target_dirpath = os.path.join(stage, os.path.basename(media_include))
                shutil.copytree(media_include, target_dirpath, dirs_exist_ok=True,
                                ignore=shutil.ignore_patterns('.git*'))
            except:
                self.log.exception(f'problem copying media_include data to staging dir: {media_include}')
                raise FllError


    def mount(self, chroot: str) -> None:
        '''Mount virtual filesystems in a chroot.'''
        virtfs = {'devpts': 'dev/pts', 'proc': 'proc'}

        for v in list(virtfs.items()):
            cmd = ['mount', '-t', v[0], 'fll-' + v[0],
                   os.path.join(chroot, v[1])]

            returncode = subprocess.call(cmd, preexec_fn=restore_sigpipe)
            if returncode != 0:
                self.log.critical(f'failed to mount chroot {v[0]}')
                raise FllError


    def umount(self, chroot: str) -> None:
        '''Umount any mount points in a chroot.'''
        umount_list = []
        try:
            for line in open('/proc/mounts'):
                (dev, mnt, fs, options, d, p) = line.split()
                if mnt.startswith(chroot):
                    umount_list.append(mnt)
        except IOError:
            self.log.exception('failed to open /proc/mounts')
            raise FllError

        umount_list.sort(key=len)
        umount_list.reverse()

        for mpoint in umount_list:
            returncode = subprocess.call(['umount', mpoint], preexec_fn=restore_sigpipe)
            if returncode != 0:
                self.log.critical(f'umount failed for: {mpoint}')
                raise FllError


    def nuke_directory(self, dirname: str) -> None:
        '''Nuke directory tree.'''
        if os.path.isdir(dirname):
            self.log.debug(f'nuking directory: {dirname}')
            try:
                shutil.rmtree(dirname)
            except:
                self.log.exception(f'unable to remove {dirname}')
                raise FllError
        else:
            self.log.debug(f'directory does not exist: {dirname}')


    def nuke_chroot(self, arch: str) -> None:
        '''Convenience function to nuke chroot given by arch name.'''
        if not self.opts.preserve:
            self.log.info(f'nuking chroot: {arch}')
            chroot = os.path.join(self.temp, arch)
            self.umount(chroot)
            self.nuke_directory(chroot)


    def cleanup(self) -> None:
        '''Clean up the build area after taking care that all build chroots
        have been taken care of.'''
        self.log.info('cleaning up...')

        for arch in list(self.conf['archs'].keys()):
            dirname = os.path.join(self.temp, arch)
            if os.path.isdir(dirname):
                self.log.debug(f'cleaning up chroot: {arch}')
                self.umount(dirname)
                if not self.opts.preserve:
                    self.nuke_directory(dirname)

        if not self.opts.preserve:
            self.nuke_directory(self.temp)


    def exec_cmd(self, cmd: list, check_returncode: bool=True) -> None:
        '''Execute subprocess without buffering output in a pipe.'''
        command_line = ' '.join(cmd)
        self.log.debug(command_line)

        try:
            if self.opts.log_file:
                cmd_process = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                                               stderr=subprocess.STDOUT,
                                               env=self.env, close_fds=True,
                                               preexec_fn=restore_sigpipe)
                cmd_stdout = cmd_process.communicate()[0]
                for line in cmd_stdout.readlines():
                    self.log.debug(line)
                cmd_rc = cmd_process.returncode
            elif self.opts.quiet:
                with open(os.devnull, 'w') as pipe:
                    cmd_rc = subprocess.call(cmd, stderr=subprocess.STDOUT,
                                             stdout=pipe,
                                             env=self.env, close_fds=True,
                                             preexec_fn=restore_sigpipe)
            else:
                cmd_rc = subprocess.call(cmd, stderr=subprocess.STDOUT,
                                         env=self.env, close_fds=True,
                                         preexec_fn=restore_sigpipe)
        except KeyboardInterrupt:
            raise FllError
        except:
            self.log.exception(f'problem executing command: {command_line}')
            raise FllError

        if cmd_rc != 0 and check_returncode:
            self.log.critical(f'command failed with return value: {cmd_rc}')
            raise FllError


    def chroot_exec(self, arch: str, args: list, check_returncode: bool=True) -> None:
        '''Run command in a chroot.'''
        chroot = os.path.join(self.temp, arch)
        cmd = ['chroot', chroot]
        cmd.extend(args)

        self.mount(chroot)
        self.exec_cmd(cmd, check_returncode)
        self.umount(chroot)


    def apt_get_install(self, arch: str, pkgs: list, download_only: bool=False) -> None:
        '''An apt-get install wrapper. Automatic installation of recommended
        packages defaults to disabled.'''
        aptget = ['apt-get', '--yes']

        if download_only:
            aptget.append('--download-only')
        if self.conf['options']['apt_recommends'] == 'no':
            aptget.extend(['-o', 'APT::Install-Recommends=0'])
        if self.opts.debug:
            aptget.extend(['-o', 'APT::Get::Show-Versions=1'])

        aptget.append('install')
        aptget.extend(pkgs)

        self.chroot_exec(arch, aptget)


    def cdebbootstrap(self, arch: str, dirname: str, mirror: str, codename: str) -> None:
        '''Bootstrap a debian system with cdebootstrap.'''
        cmd = ['cdebootstrap', '--arch=%s' % arch,
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--flavour=minimal', codename, dirname, mirror]

        if self.opts.debug:
            cmd.append('--debug')
        elif self.opts.verbose:
            cmd.append('--verbose')

        self.exec_cmd(cmd)

        cmd = 'dpkg --purge cdebootstrap-helper-rc.d'
        self.chroot_exec(arch, cmd.split())


    def debbootstrap(self, arch: str, dirname: str, mirror: str, codename: str) -> None:
        '''Bootstrap a debian system with debootstrap.'''
        cmd = ['debootstrap', f'--arch={arch}',
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--variant=minbase', '--merged-usr', codename, dirname, mirror]

        if self.opts.debug or self.opts.verbose:
            cmd.insert(1, '--verbose')

        self.exec_cmd(cmd)


    def mmdebbootstrap(self, arch: str, dirname: str, mirror: str, codename: str) -> None:
        '''Bootstrap a debian system with mmdebstrap.'''
        cmd = ['mmdebstrap', '--architectures=%s' % arch,
               '--include=apt-utils,ca-certificates,gnupg,xz-utils,zstd',
               '--variant=minbase', '--mode=root', '--format=directory',
               '--hook-dir=/usr/share/mmdebstrap/hooks/merged-usr', codename,
               dirname, mirror]

        if self.opts.debug or self.opts.verbose:
            cmd.insert(1, '--verbose')

        self.exec_cmd(cmd)


    def chroot_bootstrap(self, arch: str) -> None:
        '''Bootstrap a debian system with cdebootstrap.'''
        distro = self.opts.source_distro_name
        debian = self.conf['repos'][distro]
        codename = self.opts.source_distro_codename
        if debian.get('cached'):
            mirror = debian['cached']
        else:
            mirror = debian['uri']

        dirname = os.path.join(self.temp, arch)

        self.log.info(f'bootstrapping {distro} {codename} {arch}...')

        bootstrapper = self.conf['options'].get('bootstrapper')
        if bootstrapper == 'mmdebstrap':
            self.mmdebbootstrap(arch, dirname, mirror, codename)
        elif bootstrapper == 'debootstrap':
            self.debbootstrap(arch, dirname, mirror, codename)
        else:
            self.cdebbootstrap(arch, dirname, mirror, codename)

        shutil.copy('/etc/hosts', os.path.join(dirname, 'etc'))
        shutil.copy('/etc/resolv.conf', os.path.join(dirname, 'etc'))
        os.mkdir(os.path.join(dirname, 'disks'), 0o755)


    def write_apt_lists(self, arch: str, cached: bool=False, src_uri: bool=False) -> None:
        '''Write apt source lists to /etc/apt/sources.list.d/*.'''
        chroot = os.path.join(self.temp, arch)
        for r in self.conf['repos'].keys():
            repo = self.conf['repos'][r]
            cached_uri = repo.get('cached')
            sources_uri = repo.get('sources_uri')
            if sources_uri:
                cmd = ['wget', '--quiet', sources_uri, '-O']
                cmd.append(os.path.join(chroot, 'etc/apt/sources.list.d',
                                        os.path.basename(sources_uri)))
                self.exec_cmd(cmd)

                if cached and cached_uri:
                    cmd = ['sed', '-i', f's#^URIs: .*#URIs: {cached_uri}#']
                    cmd.append(os.path.join(chroot, 'etc/apt/sources.list.d',
                                            os.path.basename(sources_uri)))
                    self.exec_cmd(cmd)
                continue

            sources_file = os.path.join(chroot, 'etc/apt/sources.list.d',
                                        repo['label'] + '.sources')

            self.log.debug("creating %s" % sources_file)
            sources_file_fh = None
            try:
                sources_file_fh = open(sources_file, 'w')
                if src_uri or not self.opts.binary:
                    sources_file_fh.write('Types: deb deb-src\n')
                else:
                    sources_file_fh.write('Types: deb\n')
                if cached and cached_uri:
                    sources_file_fh.write(f'URIs: {cached_uri}\n')
                else:
                    sources_file_fh.write(f'URIs: {repo['uri']}\n')
                sources_file_fh.write(f'Suites: {repo['suite']}\n')
                sources_file_fh.write(f'Components: {repo['components']}\n')
                if repo.get('keyring'):
                    sources_file_fh.write(f'Signed-by: /usr/share/keyrings/{repo['keyring']}.gpg\n')
                else:
                    sources_file_fh.write(f'Signed-by: /usr/share/keyrings/debian-archive-keyring.gpg\n')
            except IOError:
                self.log.exception('failed to open %s' % sources_file)
                raise FllError
            finally:
                if sources_file_fh:
                    sources_file_fh.close()


    def prime_apt(self, arch: str) -> None:
        '''Prepare apt for work in each build chroot. Fetch all required gpg
        keys and initialize apt_pkg config.'''
        self.log.info('preparing apt in %s chroot...' % arch)
        chroot = os.path.join(self.temp, arch)

        apt_preferences = self.conf['options']['apt_preferences']
        if apt_preferences:
            self.log.info(f'importing apt preferences file: {apt_preferences}')
            try:
                shutil.copy(apt_preferences, os.path.join(chroot, 'etc/apt/'))
            except IOError:
                self.log.error(f'failed to import apt preferences: {apt_preferences}')
                raise FllError

        self.log.debug(f'removing sources.list from chroot: {arch}')
        sources_list = os.path.join(chroot, 'etc/apt/sources.list')
        if os.path.isfile(sources_list):
            os.unlink(sources_list)

        self.write_apt_lists(arch, cached = True, src_uri = True)

        keyrings = list()
        for r in self.conf['repos'].keys():
            repo = self.conf['repos'][r]
            keyring = repo.get('keyring')
            if keyring:
                keyrings.append(keyring)

        if len(keyrings) > 0:
            self.chroot_exec(arch, 'apt-get -o Acquire::Languages=none --allow-insecure-repositories update'.split())
            cmd = 'apt-get --allow-unauthenticated --yes install'.split()
            cmd.extend(keyrings)
            self.chroot_exec(arch, cmd)

        self.chroot_exec(arch, 'apt-get -o Acquire::Languages=none update'.split())
        # Upgrade any essential packages from sources not available
        # during bootstrap phase.
        self.chroot_exec(arch, 'apt-get dist-upgrade -y'.split())

        apt_pkg.init_config()
        apt_pkg.config.set('RootDir', chroot)
        apt_pkg.config.set('APT::Architecture', arch)
        apt_pkg.init_system()


    def dpkg_divert(self, arch: str) -> None:
        '''Divert some facilities and replace temporaily with /bin/true (or
        some other more appropiate facility.'''
        chroot = os.path.join(self.temp, arch)
        for divert in self.diverts:
            self.log.debug("diverting %s" % divert)
            cmd = 'dpkg-divert --add --local --divert ' + divert + '.REAL --rename '
            cmd += divert
            self.chroot_exec(arch, cmd.split())

            if divert == '/usr/sbin/policy-rc.d':
                self.write_file(arch, divert)
                os.chmod(os.path.join(chroot, divert.lstrip('/')), 0o755)
            else:
                os.symlink('/bin/true', os.path.join(chroot, divert.lstrip('/')))


    def dpkg_undo_divert(self, arch: str) -> None:
        '''Undivert facilities diverted by self.dpkg_divert().'''
        chroot = os.path.join(self.temp, arch)
        for divert in self.diverts:
            self.log.debug(f'undoing diversion: {divert}')
            os.unlink(os.path.join(chroot, divert.lstrip('/')))
            cmd = 'dpkg-divert --remove --rename ' + divert
            self.chroot_exec(arch, cmd.split())


    def write_file(self, arch: str, filename: str) -> None:
        '''Write a file in a chroot. Templates for common files included
        below.'''
        chroot = os.path.join(self.temp, arch)

        f = None
        fn = None
        mode = 0o644
        try:
            fn = os.path.join(chroot, filename.lstrip('/'))
            if os.path.isfile(fn):
                mode = None
            if not os.path.exists(os.path.dirname(fn)):
                try:
                    os.makedirs(os.path.dirname(fn), 0o755)
                except OSError as exc:
                    if exc.errno != errno.EEXIST:
                        raise
            f = open(fn, 'w')
            self.log.debug(f'writing file: {filename}')
            if filename == '/etc/default/distro':
                defaults = list(self.conf['distro'].keys())
                defaults.sort()
                for key in defaults:
                    if key.startswith('FLL_DISTRO_CODENAME'):
                        continue
                    elif key == 'FLL_IMAGE_FILE':
                        image_file = self.get_distro_imagefile(arch)
                        f.write('%s="%s"\n' % (key, image_file))
                        f.write('%s="$%s/$%s"\n' % ('FLL_IMAGE_LOCATION',
                                                    'FLL_IMAGE_DIR', key))
                    else:
                        f.write('%s="%s"\n' % (key, self.conf['distro'][key]))
            elif filename == '/etc/fstab':
                f.write('# /etc/fstab: static file system information\n')
            elif filename == '/etc/hostname':
                hostname = self.conf['distro']['FLL_DISTRO_NAME']
                f.write(hostname + '\n')
            elif filename == '/etc/hosts':
                hostname = self.conf['distro']['FLL_DISTRO_NAME']
                f.write('127.0.0.1\tlocalhost\n')
                f.write('127.0.0.1\t' + hostname + '\n\n')
                f.write('# Below lines are for IPv6 capable hosts\n')
                f.write('::1     ip6-localhost ip6-loopback\n')
                f.write('fe00::0 ip6-localnet\n')
                f.write('ff00::0 ip6-mcastprefix\n')
                f.write('ff02::1 ip6-allnodes\n')
                f.write('ff02::2 ip6-allrouters\n')
                f.write('ff02::3 ip6-allhosts\n')
            elif filename == '/usr/sbin/policy-rc.d':
                f.write('#!/bin/sh\n')
                f.write('echo "$0 denied action: $1 $2" >&2\n')
                f.write('exit 101\n')
            elif filename == '/tmp/iso_uuid':
                f.write(self.uuid)
                self.conf['distro']['FLL_UUID'] = self.uuid
        except IOError:
            self.log.exception(f'failed to open file for writing: {filename}')
            raise FllError
        finally:
            if f:
                f.close()
                if mode:
                    os.chmod(fn, mode)


    def write_default_conffiles(self, arch: str) -> None:
        '''Initial creation of conffiles required in chroot.'''
        self.write_file(arch, '/etc/fstab')
        self.write_file(arch, '/etc/hostname')
        self.write_file(arch, '/tmp/iso_uuid')


    def write_distro_defaults(self, arch: str) -> None:
        '''Write the /etc/default/distro file.'''
        self.write_file(arch, '/etc/default/distro')


    def write_final_conffiles(self, arch: str) -> None:
        '''Final editing of conffiles in chroot.'''
        chroot = os.path.join(self.temp, arch)

        distro_version = '%s-version' % \
                         self.conf['distro']['FLL_DISTRO_NAME'].lower()
        distro_version = os.path.join(chroot, 'etc', distro_version)

        self.log.debug(f'stamping distro version: {distro_version}')
        f = None
        try:
            f = open(distro_version, 'w')
            f.write(self.get_distro_stamp())
        except IOError:
            self.log.exception(f'failed to open file for writing: {distro_version}')
            raise FllError
        finally:
            if f:
                f.close()
                os.chmod(distro_version, 0o444)

        self.write_file(arch, '/etc/hosts')
        self.write_file(arch, '/etc/motd.tail')

        self.log.debug('writing final apt sources.list(s)')
        self.write_apt_lists(arch)

        if os.path.isfile(os.path.join(chroot, 'etc/resolv.conf')) and \
           not os.path.islink(os.path.join(chroot, 'etc/resolv.conf')) and \
           os.path.isfile(os.path.join(chroot, 'etc/systemd/resolved.conf')):
            # networkd+resolved so setup symlink and disable fallback DNS
            try:
                os.unlink(os.path.join(chroot, 'etc/resolv.conf'))
                os.symlink('../run/systemd/resolve/stub-resolv.conf', os.path.join(chroot, 'etc/resolv.conf'))
                with open(os.path.join(chroot, 'etc/systemd/resolved.conf'), 'a') as f:
                    f.write('DNS=\n')
            except IOError:
                self.log.exception('failed to setup resolv.conf and resolved.conf')
                raise FllError

        if 'home' in self.conf:
            self.log.info('copying systemd-homed keys to %s chroot...' % arch)
            try:
                os.makedirs(os.path.join(chroot, 'var/lib/systemd/home/'))
                pubkey = self.conf['home'].get('pubkey')
                shutil.copy(pubkey, os.path.join(chroot, 'var/lib/systemd/home/'))
                privkey = self.conf['home'].get('privkey')
                if privkey:
                    shutil.copy(privkey, os.path.join(chroot, 'var/lib/systemd/home/'))
            except FileNotFoundError:
                self.log.exception('home configuration invalid')
                raise FllError

        boot_theme = self.conf['options'].get('boot_theme', 'bgrt')
        self.log.info(f'setting plymouth theme: {boot_theme}')
        self.chroot_exec(arch, ['plymouth-set-default-theme', boot_theme])


    def create_initramfs(self, arch: str) -> None:
        '''Generate the initramfs if update-initramfs was diverted'''
        if '/usr/sbin/update-initramfs' in self.diverts and not self.opts.dummy:
            chroot = os.path.join(self.temp, arch)
            kvers = self.detect_linux_version(arch)
            for kernel in kvers:
                cmd = 'update-initramfs -c -k %s' % kernel
                if self.opts.verbose or self.opts.debug:
                    cmd += ' -v'
                self.chroot_exec(arch, cmd.split())


    def preseed_debconf(self, arch: str) -> None:
        '''Preseed debconf with values read from package lists.'''
        chroot = os.path.join(self.temp, arch)
        debconf_list = self.get_debconf_list(arch)

        if debconf_list:
            self.log.info(f'preseeding debconf in chroot: {arch}')
            debconf = None
            try:
                debconf = open(os.path.join(chroot, 'tmp',
                                            'fll_debconf_selections'), 'w')
                debconf.writelines([f'{d}\n' for d in debconf_list])
            except IOError:
                self.log.exception('failed to open file for writing: %s' %
                                   '/tmp/fll_debconf_selections')
                raise FllError
            finally:
                if debconf:
                    debconf.close()

            cmd = 'debconf-set-selections '
            if self.opts.verbose:
                cmd += '--verbose '
            cmd += '/tmp/fll_debconf_selections'

            self.chroot_exec(arch, cmd.split())


    def detect_linux_version(self, arch: str) -> None:
        '''Return version string of a singularly installed linux-image.'''
        linux_images = [f[len('linux-image-'):] for f in
                        self.pkgs[arch]['manifest']
                        if f.startswith('linux-image-') and len(f.split('-')) > 4]

        if len(linux_images) > 0:
            linux_images.sort(key=functools.cmp_to_key(apt_pkg.version_compare))
            linux_images.reverse()
            return linux_images

        self.log.critical(f'failed to detect linux version installed in {arch} chroot')
        raise FllError


    def detect_locale_packages(self, i18n: list, wanted: list, cache: apt_pkg.Cache) -> list:
        '''Provide automated detection for extra i18n packages.'''
        self.log.info(f'detecting i18n packages for locales: {' '.join(i18n)}')

        locales_pkg_map_file = os.path.join(self.opts.share, 'data', 'locales-pkg-map')
        locales_pkg_map = ConfigObj(locales_pkg_map_file)
        self.log.debug('locales_pkg_map:')
        self.log.debug(locales_pkg_map)

        fll_locales = FllLocales(cache, wanted, locales_pkg_map)
        i18n_list = []
        for locale in sorted(i18n):
            try:
                loc_pkg_list = fll_locales.detect_locale_packages(locale)
            except FllLocalesError:
                print_error(f'Failed to parse locale string: {locale}')
            else:
                i18n_list.extend(loc_pkg_list)

        self.log.debug('i18n_list:')
        self.log.debug(i18n_list)
        return i18n_list


    def detect_recommended_packages(self, wanted: list, cache: apt_pkg.Cache) -> list:
        '''Provide automated detection for packages in recommends whitelist.'''
        if self.conf['options']['apt_recommends'] == 'yes':
            return []

        self.log.info('detecting whitelisted recommended packages...')
        rec_module = ConfigObj(os.path.join(self.opts.share, 'packages',
                                            'packages.d', 'recommends'))
        try:
            rec_dict = dict([(p, True) for p in
                             multiline_to_list(rec_module['packages'])])
        except KeyError:
            self.log.debug('rec_dict:')
            return []

        self.log.debug('rec_dict:')
        self.log.debug(rec_dict)

        rec_list = []
        for p in wanted.keys():
            if not p in rec_dict:
                continue
            package = cache[p]
            current = package.current_ver
            if not current:
                versions = package.version_list
                if not versions:
                    continue
                version = versions[0]
                for other_version in versions:
                    if apt_pkg.version_compare(version.ver_str,
                                               other_version.ver_str) < 0:
                        version = other_version
                current = version

            depends = current.depends_list
            list = depends.get('Recommends', [])
            for dependency in list:
                depdone = 0
                for deppart in dependency:
                    if depdone > 0:
                        continue
                    name = deppart.target_pkg.name
                    if name in wanted.keys():
                        depdone = 1
                        continue
                if depdone == 0:
                    name = dependency[0].target_pkg.name
                    dep = cache[name]
                    if dep.current_ver:
                        continue
                    rec_list.append(dep.name)

        self.log.debug('rec_list:')
        self.log.debug(rec_list)
        return rec_list


    def get_source_package(self, pkg: str, depcache: apt_pkg.DepCache,
                           records: apt_pkg.PackageRecords) -> list[str, str]:
        '''Get the source package name of a given package.'''
        version = depcache.get_candidate_ver(pkg)

        if not version:
            return None
        file, index = version.file_list.pop(0)
        records.lookup((file, index))

        srcpkg = pkg.name
        srcver = version.ver_str
        if records.source_pkg != "":
            srcpkg = records.source_pkg

        if records.source_ver != "":
            srcver = records.source_ver

        return [srcpkg, srcver]

    def collect_manifest(self, arch: str) -> None:
        '''Collect package and source package URI information from each
        chroot.'''
        chroot = os.path.join(self.temp, arch)
        self.log.info(f'collecting package manifest for {arch}...')

        cache = apt_pkg.Cache(apt.progress.base.OpProgress())
        records = apt_pkg.PackageRecords(cache)
        depcache = apt_pkg.DepCache(cache)

        manifest = dict([(p.name, p.current_ver.ver_str)
                         for p in cache.packages if p.current_ver
                         and not p.name.startswith('cdebootstrap-helper')])
        if 'i18n' in self.pkgs[arch]:
            manifest.update(self.pkgs[arch]['i18n'])
        self.pkgs[arch]['manifest'] = manifest

        if self.opts.binary:
            return

        self.log.info(f'querying source package URIs for {arch}...')

        packages = list(manifest.keys())
        packages.sort()
        srcpkg_seen = dict()
        uris = []
        for pkg in packages:
            if pkg.startswith('cdebootstrap-helper'):
                continue

            srcpv = self.__getSourcePkg(cache[pkg], depcache, records)
            srcpkg=srcpv[0]
            srcver=srcpv[1]
            if not srcpkg:
                self.log.critical(f'failed to lookup srcpkg name for {pkg}')
                raise FllError
            self.log.debug(f'{pkg} -> {srcpkg}')

            if srcpkg in srcpkg_seen:
                self.log.debug(f'already processed {srcpkg}, skipping...')
                continue
            else:
                srcpkg_seen[srcpkg] = True

            try:
                u = []
                sources = apt_pkg.SourceRecords()
                sources.restart()
                while sources.lookup(srcpkg):
                    if sources.version == srcver:
                        u.extend([sources.index.archive_uri(sources.files[f][2])
                                for f in range(len(sources.files))])
                self.log.debug(u)
                uris.extend(u)
            except (apt_pkg.Error, SystemError) as e:
                self.log.critical(f'failed to query source uris for {srcpkg}: {e}')
                raise FllError

        uris.sort()
        self.pkgs[arch]['source'] = uris


    def install_packages(self, arch: str) -> None:
        '''Install packages.'''
        cache = apt_pkg.Cache(apt.progress.base.OpProgress())
        if cache.ver_file_count < 200:
            self.log.info(f'installPkgs cache had {cache.ver_file_count}')
            cache = apt_pkg.Cache(apt.progress.base.OpProgress())
            self.log.info(f'installPkgs cache has {cache.ver_file_count}')

        pkgs_base = [pkg.name for pkg in cache.packages if pkg.current_ver]
        pkgs_want = deduplicate_list(pkgs_base + self.get_package_list(arch))
        pkgs_dict = dict([(pkg, True) for pkg in pkgs_want])
        pkgs_want = deduplicate_list(list(pkgs_dict.keys()) +
                                     self.detect_recommended_packages(pkgs_dict, cache))
        pkgs_dict = dict([(pkg, True) for pkg in pkgs_want])
        i18n_list = multiline_to_list(self.conf['packages']['i18n'])
        pkgs_want = deduplicate_list(list(pkgs_dict.keys()) +
                                     self.detect_locale_packages(i18n_list, pkgs_dict, cache))
        pkgs_dict = dict([(pkg, True) for pkg in pkgs_want])
        pkgs_had = list()

        if not self.opts.dummy:
            self.log.info(f'installing packages in chroot: {arch}')
            self.apt_get_install(arch, pkgs_want)


    def post_installation(self, arch: str) -> None:
        '''Run package module postinst scripts in a chroot.'''
        if self.opts.dummy:
            return
        chroot = os.path.join(self.temp, arch)

        self.log.info(f'performing post-install tasks in chroot: {arch}')

        # reset /etc/resolv.conf (systemd-resolved clobbered our settings)
        os.unlink(os.path.join(chroot, 'etc/resolv.conf'))
        shutil.copy('/etc/resolv.conf', os.path.join(chroot, 'etc'))

        for script in self.get_postinst_list(arch):
            sname = os.path.basename(script)
            try:
                shutil.copy(script, os.path.join(chroot, 'tmp'))
                os.chmod(os.path.join(chroot, 'tmp', sname), 0o755)
            except:
                self.log.exception(f'error preparing postinst script: {sname}')
                raise FllError

            cmd = f'/tmp/{sname} postinst'
            self.chroot_exec(arch, cmd.split())
            os.unlink(os.path.join(chroot, 'tmp', sname))


    def zero_logs(self, arch: str, dirname: str, filenames: list) -> None:
        '''Truncate all log files.'''
        chroot = os.path.join(self.temp, arch)
        chrootdir = dirname.partition(chroot)[2]

        for f in filenames:
            if not os.path.isfile(os.path.join(dirname, f)):
                continue
            self.write_file(arch, os.path.join(chrootdir, f))


    def clean_chroot(self, arch: str) -> None:
        '''Remove unwanted content from a chroot.'''
        self.log.info(f'purging unwanted content from chroot: {arch}')
        chroot = os.path.join(self.temp, arch)

        cmd = 'dpkg --purge fll-live-initramfs'
        self.chroot_exec(arch, cmd.split())
        self.chroot_exec(arch, 'apt-get clean'.split())
        self.chroot_exec(arch, 'dpkg --clear-avail'.split())

        for dirpath, dirnames, files in os.walk(os.path.join(chroot, 'var/log')):
            self.zero_logs(arch, dirpath, files)


    def mksquashfs_chroot(self, arch: str) -> None:
        '''Make squashfs filesystem image of chroot.'''
        self.log.info(f'creating squashfs filesystem of chroot: {arch}')
        chroot = os.path.join(self.temp, arch)

        image_file = self.get_distro_imagefile(arch)
        if self.opts.dummy:
            cmd = ['touch', image_file]
            self.chroot_exec(arch, cmd)
            return

        cmd = ['mksquashfs', '.', image_file, '-noappend']

        exclude_file = os.path.join(self.opts.share, 'data', 'fll_sqfs_exclusion')
        shutil.copy(exclude_file, os.path.join(chroot, 'tmp'))
        cmd.extend(['-wildcards', '-ef', '/tmp/fll_sqfs_exclusion'])

        # set compression algorithm for squashfs-tools >= 4.1
        squashfs_comp = self.conf['options'].get('squashfs_comp')
        if squashfs_comp in ['gzip', 'lz4', 'lzo', 'xz', 'zstd']:
            self.log.info(f'using squashfs compression: {squashfs_comp}')
            cmd.extend(['-comp', squashfs_comp])
            if squashfs_comp == 'xz':
                if arch == 'amd64' or arch == 'i386':
                    cmd.extend(['-Xbcj', 'x86'])
        
        if self.opts.log_file or self.opts.quiet:
            cmd.append('-no-progress')

        # can only be last argument
        cmd.extend(['-e', image_file])

        self.chroot_exec(arch, cmd)


    def stage_chroot(self, arch: str) -> None:
        '''Stage files for an arch for final genisofs.'''
        self.log.info('staging live %s media...' % arch)
        chroot = os.path.join(self.temp, arch)
        boot_dir = os.path.join(self.temp, 'staging', 'boot')

        image_file = os.path.join(chroot, self.get_distro_imagefile(arch))
        image_dir = os.path.join(self.temp, 'staging',
                                 self.conf['distro']['FLL_IMAGE_DIR'])
        try:
            os.chmod(image_file, 0o644)
            shutil.move(image_file, image_dir)
        except IOError:
            self.log.exception('failed to move squashfs image to staging dir')
            raise FllError

        if self.opts.dummy:
            return

        kvers = self.detect_linux_version(arch)
        for kernel in kvers:
            initrd = os.path.join(chroot, 'boot', f'initrd.img-{kernel}')
            if os.path.isfile(initrd):
                self.log.debug(f'copying {initrd} to staging dir')
                shutil.copy(initrd, boot_dir)
            else:
                self.log.critical('could not find initramfs image to ' +
                                  'copy to staging dir.')
                raise FllError
            
            images = glob.glob(os.path.join(chroot, 'boot', f'vmlinu*-{kernel}'))
            if len(images) == 1:
                self.log.debug(f'copying {images[0]} to staging dir')
                shutil.copy(images[0], boot_dir)
            else:
                self.log.critical('could not find linux kernel image to ' +
                                  'copy to staging dir.')
                raise FllError

        if os.path.isdir(os.path.join(chroot, 'usr/lib/grub')):
            data_dir = os.path.join(self.opts.share, 'data')
            grub_dir = os.path.join(boot_dir, 'grub')
            if not os.path.isdir(grub_dir):
                os.makedirs(grub_dir, 0o755)
            if not os.path.isfile(os.path.join(grub_dir, 'grub.cfg')):
              shutil.copy(os.path.join(self.opts.share, 'data/grub.cfg'), grub_dir)
              shutil.copy(os.path.join(chroot, 'usr/share/grub/unicode.pf2'), grub_dir)
              shutil.copytree(os.path.join(self.opts.share, 'data/locales'), os.path.join(grub_dir, 'locales'))
              shutil.copytree(os.path.join(self.opts.share, 'data/tz'), os.path.join(grub_dir, 'tz'))
              theme_dir = f'themes/{self.conf['distro']['FLL_GFXBOOT_THEME']}'
              if os.path.isfile(os.path.join(chroot, f'usr/share/grub/{theme_dir}/theme.txt')):
                  shutil.copytree(os.path.join(chroot, f'usr/share/grub/{theme_dir}'), os.path.join(grub_dir, theme_dir))

            gfile_dir = glob.glob(os.path.join(chroot, 'usr/lib/grub/*-pc'))[0]

            grub2_modules = glob.glob(os.path.join(gfile_dir, '*.mod'))
            if len(grub2_modules) > 0:
                gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                          if f.endswith('.mod') or f.endswith('.img')
                          or f.endswith('.lst')]
                gfiles.append(os.path.join(chroot, 'tmp/grub_eltorito'))
            else:
                gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                          if f.startswith('stage2') or f.startswith('iso9660')]

            if len(gfiles) > 0:
                self.log.debug('copying grub stage files to boot dir')
                grub_dir = os.path.join(boot_dir, 'grub', 'i386-pc')
                if not os.path.isdir(grub_dir):
                    os.makedirs(grub_dir, 0o755)
            else:
                self.log.exception('grub stage files not found')
                raise FllError

            for file in gfiles:
                try:
                    shutil.copy(file, grub_dir)
                except IOError:
                    self.log.exception('failed to copy grub file to staging dir')
                    raise FllError

            # efi
            efitypes = { 'x86_64-efi':'bootx64','i386-efi':'bootia32' }
            have_efi = False
            for efitype in (list(efitypes.keys())):
                gfile_dir = os.path.join(chroot, f'usr/lib/grub/{efitype}')
                if os.path.isdir(gfile_dir):
                    have_efi = True
                    gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                            if f.endswith('.mod') or f.endswith('.lst')]
                    gfiles.append(os.path.join(chroot,'/usr/share/grub/unicode.pf2'))
                    if len(gfiles) > 0:
                        self.log.debug(f'copying grub {efitype} stage files to boot dir')
                        grub_dir = os.path.join(boot_dir, 'grub', efitype)
                        if not os.path.isdir(grub_dir):
                            os.makedirs(grub_dir, 0o755)
                    for file in gfiles:
                        try:
                            shutil.copy(file, grub_dir)
                        except IOError:
                            self.log.exception('failed to copy grub efi file to staging dir')
                            raise FllError
                    efi_dir = os.path.join(self.temp, 'staging/efi/boot')
                    if not os.path.isdir(efi_dir):
                        os.makedirs(efi_dir, 0o755)
                    try:
                        shutil.copy(os.path.join(chroot, f'tmp/efi/boot/{efitypes[efitype]}.efi'), efi_dir)
                    except IOError:
                        self.log.exception(f'failed to copy efi {efitype} boot files to staging dir')
                        raise FllError
            if have_efi and not os.path.isfile(os.path.join(self.temp, 'staging', 'efi.img')):
                try:
                    cmd = [ 'mformat', '-C', '-f', '2880', '-L', '16', '-i', '/tmp/efi.img', '::' ]
                    self.chroot_exec(arch, cmd)
                    cmd = [ 'mcopy', '-s', '-i', '/tmp/efi.img', '/tmp/efi_img/efi', '::/' ]
                    self.chroot_exec(arch, cmd)
                    shutil.copy(os.path.join(chroot, 'tmp/efi.img'), os.path.join(self.temp, 'staging'))
                    shutil.copy(os.path.join(chroot, 'tmp/iso_uuid'), os.path.join(self.temp, 'staging'))
                    uuid_dir = os.path.join(chroot, 'tmp/uuid')
                    ufiles = [os.path.join(uuid_dir, f) for f in os.listdir(uuid_dir)]
                    for file in ufiles:
                        shutil.copy(file, os.path.join(boot_dir, 'grub'))
                except IOError:
                    self.log.exception('failed to create efi.img')
                    raise FllError

        memtest = os.path.join(chroot, 'boot', 'memtest86+.bin')
        memtest_out = os.path.join(boot_dir, 'memtest')
        if os.path.isfile(memtest):
            self.log.debug('copying memtest86+ to boot dir')
            try:
                shutil.copy(memtest, memtest_out)
            except IOError:
                self.log.exception('failed to copy memtest86+ to staging dir')
                raise FllError


    def write_grub_cfg(self, stage_dir: str, boot_dir: str, grub_dir: str, linux_images: list[list],
                       timeout: str, cmdline: str) -> None:
        '''Write grub.cfg for live media.'''
        self.log.info('writing grub.cfg for live media')

        grubcfg = open(os.path.join(grub_dir, 'kernels.cfg'), 'w')
        distro = self.conf['distro']['FLL_DISTRO_NAME']
        
        kcount = { '686': 0, 'amd': 0, 'pae': 0, '486': 0, 'ppc': 0 }
        for linux_images_arch in linux_images:
            for linux_image in linux_images_arch:
                cpu = linux_image.split('-')[-1]
                vmlinuz = f'vmlinuz-{linux_image}'
                initrd = f'initrd.img-{linux_image}'

                for filename in [vmlinuz, initrd]:
                    if not os.path.isfile(os.path.join(boot_dir, filename)):
                        self.log.critical(f'{filename} was not found in {boot_dir}')
                        raise FllError

                if cpu[0:3] == 'amd':
                    grubcfg.write('if cpuid -l; then\n')
                grubcfg.write('havekernel="Y"\n')
                grubcfg.write('title=""\n')
                grubcfg.write('for kopt in %s $kopts boot=fll %s; do\n' % (vmlinuz[8:], cmdline))
                grubcfg.write(' if [ -n "$title" ] ; then\n')
                grubcfg.write('  title="$title $kopt";\n')
                grubcfg.write(' else\n')
                grubcfg.write('  title="$kopt";\n')
                grubcfg.write(' fi;\n')
                grubcfg.write('done\n')
                grubcfg.write('menuentry --class=%s.%s \"$title\" {' % (distro, cpu))
                grubcfg.write('# set arguments above with the editor\n')
                grubcfg.write('linux /boot/vmlinuz-$@\n')
                grubcfg.write('initrd /boot/%s\n' % initrd)
                grubcfg.write('}\n')
                if cpu[0:3] == 'amd':
                    grubcfg.write('fi\n')
                kcount[cpu[0:3]] = kcount[cpu[0:3]] + 1
        grubcfg.write('if [ "${havekernel}" != "Y" ]; then\n')
        grubcfg.write('  menuentry --class=find.none "NO SUITABLE KERNELS AVAILABLE" {echo $@')
        grubcfg.write('  echo "There are no kernels suitable for this machine available."\n')
        grubcfg.write('  echo ""\n')
        grubcfg.write('  if ! cpuid -l; then\n')
        grubcfg.write('    echo "This machine is NOT 64bit capable."\n')
        grubcfg.write('    for kk in /boot/vmlinu*.*86; do\n')
        grubcfg.write('      if [ "$kk" != "/boot/vmlinu*.*86" ]; then\n')
        grubcfg.write('        have32="true"\n')
        grubcfg.write('      fi\n')
        grubcfg.write('    done\n')
        grubcfg.write('    if [ "${have32}" != "true" ]; then\n')
        grubcfg.write('      echo "There are no 32bit kernels available"\n')
        grubcfg.write('      echo "It appears you are trying to boot a 64bit release on a 32bit machine"\n')
        grubcfg.write('      echo "This cannot work!"\n')
        grubcfg.write('    fi\n')
        grubcfg.write('  fi\n')
        grubcfg.write('  echo "Press Escape to return to the main menu"\n')
        grubcfg.write('  sleep --interruptible 9999\n')
        grubcfg.write('  menu_reload\n')
        grubcfg.write('  }\n')
        grubcfg.write('fi\n')

        grubcfg.close()
        
        self.log.debug('writing loopback.cfg for live media')
        grubcfg = open(os.path.join(grub_dir, 'loopback.cfg'), 'w')
        grubcfg.write('source /boot/grub/grub.cfg\n')
        grubcfg.close()
        
        self.log.debug('writing variable.cfg for live media')
        grubcfg = open(os.path.join(grub_dir, 'variable.cfg'), 'w')
        grub_theme = f'grub/themes/{self.conf['distro']['FLL_GFXBOOT_THEME']}/theme.txt'
        if os.path.isfile(os.path.join(boot_dir, grub_theme)):
            grubcfg.write(f'grub_theme=/boot/{grub_theme}\n')
        grubcfg.write(f'timeout={timeout}\n')
        grubcfg.close()

    def config_boot_timeout(self) -> str:
        timeout = self.conf['options'].get('boot_timeout')
        if not timeout:
            timeout = '-1'
        return timeout

    def config_boot_cmdline(self) -> str:
        cmdline = self.conf['options'].get('boot_cmdline')
        if not cmdline:
            cmdline = 'fsck.mode=skip systemd.show_status=1 quiet splash'
        cmdline += f' uuid={self.uuid}'
        return cmdline

    def configure_grub(self, archs: list) -> None:
        '''Write final GRUB configuration for live media.'''
        stage_dir = os.path.join(self.temp, 'staging')
        boot_dir = os.path.join(stage_dir, 'boot')
        grub_dir = os.path.join(boot_dir, 'grub')

        if not os.path.isdir(grub_dir):
            return
        self.log.debug('writing grub config for live media')

        linux_images = list()
        linux_images.extend([self.detect_linux_version(arch) for arch in archs])
        timeout = self.config_boot_timeout()
        cmdline = self.config_boot_cmdline()

        self.write_grub_cfg(stage_dir, boot_dir, grub_dir, linux_images,
                           timeout, cmdline)


    def hash_md5sum(self, filename: str):
        '''Calculate md5sum of a file and return it.'''
        return apt_pkg.Hashes(open(filename, 'rb')).hashes.find('MD5Sum').hashvalue

    def hash_hashsums(self, filename: str):
        '''Calculate hashsums of a file and return it.'''
        hashsums = apt_pkg.Hashes(open(filename, 'rb')).hashes
        return hashsums.find('MD5Sum').hashvalue, hashsums.find('SHA256').hashvalue, \
            hashsums.find('SHA512').hashvalue


    def hash_md5sums(self, base: str, dirpath: str, filenames: list):
        '''Function given to os.path.walk of self.write_md5sums().'''
        for f in filenames:
            filepath = os.path.join(dirpath, f)
            filename = filepath.partition(base)[2].lstrip('/')

            if not os.path.isfile(filepath) or f == 'md5sums':
                continue
            if dirpath.endswith('grub') and f.find('stage') >= 0:
                continue
            if f.find('grub_eltorito') >= 0:
                continue
            if f.find('iso_uuid') >= 0:
                continue

            md5sums = None
            try:
                md5sums = open(os.path.join(base, 'md5sums'), 'a')
                md5sums.write(f'{self.hash_md5sum(filepath)} *{filename}\n')
            except IOError:
                self.log.exception('failed to write md5sums file')
                raise FllError
            finally:
                if md5sums:
                    md5sums.close()


    def write_md5sums(self) -> None:
        '''Calculate md5sums of major release contents.'''
        self.log.info('calculating md5sums of live media...')
        stage = os.path.join(self.temp, 'staging')
        for dirpath, dirnames, filenames in os.walk(stage):
            self.hash_md5sums(stage, dirpath, filenames)

    def sign_file(self, filename) -> None:
        '''Sign a file with hashkey if available.'''
        if self.opts.hashkey:
            self.log.info(f'signing file: {filename}')
            cmd = ['gpg', '-s', '--default-key']
            cmd.append(self.opts.hashkey)
            cmd.append(filename)
            self.exec_cmd(cmd)
        else:
            self.log.info(f'not signing file (no key given): {filename}')

    def arch_write_manifest(self, arch: str) -> None:
        '''Write manifest information to file.'''
        pkgs = list(self.pkgs[arch]['manifest'].keys())
        pkgs.sort(key=len)
        maxlen = len(pkgs[-1])
        pkgs.sort()

        return [f'{pkg.ljust(maxlen)} {self.pkgs[arch]['manifest'][pkg]}\n'
                for pkg in pkgs]


    def write_manifests(self, filename: str) -> None:
        '''Write package manifest lists.'''
        archs = list(self.conf['archs'].keys())
        for arch in archs:
            manifest_name = f'{filename}.{arch}.manifest'

            manifest_file = os.path.join(self.opts.output_dir, manifest_name)

            manifest = None
            try:
                manifest = open(manifest_file, 'w')
                manifest.writelines(self.arch_write_manifest(arch))
            except IOError:
                self.log.exception(f'failed to write file: {manifest_file}')
                raise FllError
            finally:
                if manifest:
                    manifest.close()
                    os.chown(manifest_file, self.opts.uid, self.opts.gid)


    def write_src_uris(self, filename: str) -> None:
        '''Write source URI lists.'''
        sources_list = []
        archs = list(self.conf['archs'].keys())
        for arch in archs:
            sources_list.extend(self.pkgs[arch]['source'])
        sources_list = deduplicate_list(sources_list)

        sources_name = filename + '.sources'
        sources_file = os.path.join(self.opts.output_dir, sources_name)

        sources = None
        try:
            sources = open(sources_file, 'w')
            sources.writelines([f'{s}\n' for s in sources_list])
        except IOError:
            self.log.exception(f'failed to write filename: {sources_file}')
            raise FllError
        finally:
            if sources:
                sources.close()
                os.chown(sources_file, self.opts.uid, self.opts.gid)

        cached = dict()
        for r in self.conf['repos']:
            if self.conf['repos'][r].get('cached'):
                cached_uri = self.conf['repos'][r]['cached']
                uri = self.conf['repos'][r]['uri']
                cached[cached_uri.rstrip('/')] = uri.rstrip('/')

        if len(list(cached.keys())) > 0:
            os.rename(sources_file, sources_file + '-cached')
        else:
            return

        sources = None
        try:
            sources = open(sources_file, 'w')
            for s in sources_list:
                for c in list(cached.keys()):
                    if s.startswith(c):
                        s = s.replace(c, cached[c], 1)
                        break
                sources.write('%s\n' % s)
        except IOError:
            self.log.exception('failed to write filename: %s' % sources_file)
            raise FllError
        finally:
            if sources:
                sources.close()
                os.chown(sources_file, self.opts.uid, self.opts.gid)


    def gen_live_media(self) -> None:
        '''Generate live media iso image.'''
        stage = os.path.join(self.temp, 'staging')

        distro_name = self.conf['distro']['FLL_DISTRO_NAME']
        fll_image_dir = self.conf['distro']['FLL_IMAGE_DIR']
        fll_image_file = self.conf['distro']['FLL_IMAGE_FILE']

        iso_name = self.get_distro_stamp_safe() + '.iso'

        iso_file = os.path.join(self.opts.output_dir, iso_name)
        md5_file = iso_file + '.md5'
        sha256_file = iso_file + '.sha256'
        sha512_file = iso_file + '.sha512'

        xorriso_cmd = 'xorriso -report_about HINT -as mkisofs -graft-points  -pad -l'
        gpthybrid_cmd = os.path.join(self.opts.bin, 'gpthybrid')

        if self.opts.verbose:
            xorriso_cmd += ' -v'
            gpthybrid_cmd += ' --verbose'

        if os.path.isdir(os.path.join(stage, 'boot/grub')):
            xorriso_cmd += ' -no-emul-boot -boot-load-size 4 -boot-info-table'
            gpthybrid_cmd += f' --label {self.uuid} --iso {iso_file}'
            if os.path.isfile(os.path.join(stage,
                                           'boot/grub/i386-pc/grub_eltorito')):
                xorriso_cmd += ' -b boot/grub/i386-pc/grub_eltorito --grub2-boot-info'
                xorriso_cmd += f' --grub2-mbr {os.path.join(stage, 'boot/grub/i386-pc/boot_hybrid.img')}'
                for arch in list(self.conf['archs'].keys()):
                    if os.path.isfile(os.path.join(stage, fll_image_dir,
                                                   self.get_distro_imagefile(arch))):
                        gpthybrid_cmd += f' {os.path.join(fll_image_dir, self.get_distro_imagefile(arch))}'
            else:
                self.log.critical('failed to find grub El Torito image file')
                raise FllError
        else:
            self.log.critical('grub is required to boot live media')
            raise FllError

        xorriso_cmd += f' --modification-date={self.uuid.replace("-","")}'
        if os.path.isfile(os.path.join(stage, 'efi.img')):
            xorriso_cmd += ' --efi-boot efi.img -efi-boot-part --efi-boot-image'
            gpthybrid_cmd += ' efi.img'

        xorriso_cmd += f' --protective-msdos-label -V {distro_name[:32]}'
        if os.path.isdir(os.path.join(stage, 'boot')):
            xorriso_cmd += ' --sort-weight 0 / --sort-weight 1 /boot'
            if os.path.isdir(os.path.join(stage, 'boot/grub')):
                xorriso_cmd += ' --sort-weight 2 /boot/grub'
        xorriso_cmd += ' -x iso_uuid -x genisoimage.sort'
        xorriso_cmd += f' -o {iso_file} {stage}'

        self.log.info('generating iso image of live media...')
        self.exec_cmd(xorriso_cmd.split())

        self.log.info('converting to hybrid iso...')
        self.exec_cmd(gpthybrid_cmd.split())

        os.chown(iso_file, self.opts.uid, self.opts.gid)

        self.log.info('calculating hashsums of live media iso image...')
        md5 = None
        sha256 = None
        sha512 = None
        try:
            md5 = open(md5_file, 'w')
            sha256 = open(sha256_file, 'w')
            sha512 = open(sha512_file, 'w')
            md5sum, sha256sum, sha512sum = self.hash_hashsums(iso_file)
            md5.write("%s *%s\n" % (md5sum, os.path.basename(iso_file)))
            sha256.write("%s *%s\n" % (sha256sum, os.path.basename(iso_file)))
            sha512.write("%s *%s\n" % (sha512sum, os.path.basename(iso_file)))
        except IOError:
            self.log.exception('failed to write hashsums files')
            raise FllError
        finally:
            if md5:
                md5.close()
                os.chown(md5_file, self.opts.uid, self.opts.gid)
                if self.opts.hashkey:
                    self.log.info('signing md5 hash...')
                    self.sign_file(md5_file)
                    os.chown(md5_file + '.gpg', self.opts.uid, self.opts.gid)
            if sha256:
                sha256.close()
                os.chown(sha256_file, self.opts.uid, self.opts.gid)
                if self.opts.hashkey:
                    self.log.info('signing sha256 hash...')
                    self.sign_file(sha256_file)
                    os.chown(sha256_file + '.gpg', self.opts.uid, self.opts.gid)
            if sha512:
                sha512.close()
                os.chown(sha512_file, self.opts.uid, self.opts.gid)
                if self.opts.hashkey:
                    self.log.info('signing sha512 hash...')
                    self.sign_file(sha512_file)
                    os.chown(sha512_file + '.gpg', self.opts.uid, self.opts.gid)

        self.write_manifests(os.path.splitext(iso_file)[0])
        if not self.opts.binary:
            self.write_src_uris(os.path.splitext(iso_file)[0])

        for f in glob.glob('%s*' % os.path.splitext(iso_file)[0]):
            self.log.info(f)

        if self.opts.update_grub:
            self.exec_cmd(["update-grub"])


    def buildChroots(self, archs: list) -> None:
        '''Main loop to call all chroot building functions.'''
        for arch in archs:
            self.chroot_bootstrap(arch)
            self.dpkg_divert(arch)
            self.write_default_conffiles(arch)
            self.write_distro_defaults(arch)
            self.preseed_debconf(arch)
            self.prime_apt(arch)
            self.install_packages(arch)
            self.post_installation(arch)
            self.collect_manifest(arch)
            self.write_final_conffiles(arch)
            self.dpkg_undo_divert(arch)
            self.create_initramfs(arch)
            self.clean_chroot(arch)
            self.mksquashfs_chroot(arch)
            self.stage_chroot(arch)
            self.nuke_chroot(arch)


    def main(self) -> None:
        '''Main loop.'''
        self.check_options()
        self.parse_conf()
        self.parse_pkg_profile()
        self.stage_build_directory()

        if self.opts.non_root:
            sys.exit(0)

        archs = list(self.conf['archs'].keys())
        self.buildChroots(archs)
        self.configure_grub(archs)
        self.write_md5sums()
        self.gen_live_media()

        duration = int(time.perf_counter() - self.time)
        m, s = divmod(duration, 60)
        self.log.info(f'build duration was {m:d} minutes and {s:02d} seconds')


if __name__ == '__main__':
    pyfll_path = os.path.abspath(sys.argv[0])
    share_path = os.path.join(os.path.dirname(pyfll_path), '../share')

    cli = argparse.ArgumentParser(description='F*** Live Linux builder.',
                                  prog='fll', usage='%(prog)s -c <config file> ' +
                                  '[-b <directory> -o <directory> -l <file>]' +
                                  ' [-BCdDNpqUv]')

    cli.add_argument('-a', '--arch', action='store',
                     type=str, metavar='<arch>', default=None,
                     help='Build architecture, overrides config file.')

    cli.add_argument('-b', '--build', action='store',
                     type=str, metavar='<directory>', default=None,
                     help='Build directory. A large amount of free space ' +
                     'is required.')

    cli.add_argument('-B', '--binary', action='store_true', default=False,
                     help='Do binary build only. Disable generation of ' +
                     'URI lists. Default: %(default)s')

    cli.add_argument('-c', '--config', action='store',
                     type=str, metavar='<config file>', required=True,
                     help='Configuration file. This option may be used ' +
                     'more than once to process multiple configurations. ' +
                     'A configuration file must be specified.')

    cli.add_argument('-d', '--debug', action='store_true', default=False,
                     help='Enable debug mode. Extra output will be ' +
                     'to assist in development. Default: %(default)s')

    cli.add_argument('-D', '--dummy', action='store_true', default=False,
                     help='Enable dummy mode. Download only ' +
                     'and no squashfs. Default: %(default)s')

    cli.add_argument('-k', '--hashkey', action='store', default=None,
                     type=str, metavar='<key id>', help='Set key ' +
                     'to sign MD5 and SHA256 hashes of the generated ISOs.')

    cli.add_argument('-l', '--log-file', action='store', default=None,
                     type=str, metavar='<file>',
                     help='Log debug output to file. Note that when ' +
                     'logging is enabled, output to the console is buffered.')

    cli.add_argument('-o', '--output-dir', action='store', default=None,
                     type=str, metavar='<directory>',
                     help='Output directory, where the product of this ' +
                     'program will be generated.')

    cli.add_argument('-p', '--profile', action='store', default=None,
                     type=str, metavar='<profile>',
                     help='Package profile, overrides config file.')

    cli.add_argument('-P', '--preserve', action='store_true', default=False,
                     help='Preserve build directory. Disable automatic ' +
                     'cleanup of the build area at exit.')

    cli.add_argument('-q', '--quiet', action='store_true', default=False,
                     help='Enable quiet mode. Only high priority messages ' +
                     'will be generated.')

    cli.add_argument('-U', '--update-grub', action='store_true', default=False,
                     help='Execute update-grub after generating iso media.')

    cli.add_argument('-v', '--verbose', action='store_true', default=False,
                     help='Enable verbose mode. All messages will be ' +
                     'generated, such as announcing current operation.')

    # These options are managed by the fll shell snippet non-interactively
    cli.add_argument('--bin', action='store', type=str,
                     help=argparse.SUPPRESS,
                     default=os.path.dirname(pyfll_path))

    cli.add_argument('--share', action='store', type=str,
                     help=argparse.SUPPRESS, default=share_path)

    cli.add_argument('--gid', action='store', type=int,
                     help=argparse.SUPPRESS, default=os.getgid())

    cli.add_argument('--uid', action='store', type=int,
                     help=argparse.SUPPRESS, default=os.getuid())

    cli.add_argument('--non-root', action='store_true',
                     help=argparse.SUPPRESS, default=False)

    cli.add_argument('-N', '--source-distro-name', action='store', type=str,
                     default='debian',
                     help='Source distribution name. Default: %(default)s')

    cli.add_argument('-C', '--source-distro-codename', action='store', type=str,
                     default='sid',
                     help='Source distribution codename. Default: %(default)s')

    arguments = cli.parse_args()

    try:
        fll = FLLBuilder(arguments)
        fll.main()
    except KeyboardInterrupt:
        pass
    except FllError:
        sys.exit(1)
