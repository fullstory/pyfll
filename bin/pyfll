#!/usr/bin/python3 -tt
# -*- coding: utf-8 -*-

__author__    = 'Kel Modderman'
__copyright__ = '(C) 2008-2025 Kel Modderman <kelvmod@gmail.com>'
__license__   = 'GPLv2 or any later version'

from configobj import ConfigObj, flatten_errors
from validate import Validator
from io import open
import apt_pkg
import apt
import argparse
import atexit
import datetime
import fileinput
import functools
import glob
import logging
import os
import sys
import shlex
import shutil
import signal
import stat
import subprocess
import tempfile
import time

def deduplicate_list(original_list: list) -> list:
    '''Return a list containing no duplicate items given a list that
    may have duplicate items.'''
    deduplicated_list = list(set(original_list))
    deduplicated_list.sort()
    return deduplicated_list

def multiline_to_list(lines: str) -> list:
    '''Return a list of stripped strings given a multiline string. Filter
    commented strings.'''
    return [s.strip() for s in lines.splitlines()
            if s.strip() and not s.lstrip().startswith('#')]

class FllLocalesError(Exception):
    """
    An FllError class for use by FllLocales.
    """
    pass

class FllLocales(object):
    """
    A class which provides the ability to determine lists of locale specific
    Debian packages using it's detect_locale_packages method.

    Arguments:
    cache    - an apt_pkg cache object
    packages - a list or dict of package names which are installed, or are
               going to be installed. Locale specific packages are selected
               for packages in this data structure.
    map      - a dict which maps package names with a list of package prefixes
               from which the locale string pattern matching can be used
               to match locale support packages. The prefered input for map is:
               ConfigObj('data/fll-locales-pkg-map').
    """
    def __init__(self, cache: apt_pkg.Cache, packages: list, locale_map: dict) -> None:
        self.loc_pkgs_set = set()
        for pkg in cache.packages:
            if not pkg.version_list:
                continue
            if pkg.name not in packages:
                continue
            for loc_pkg in list(locale_map.keys()):
                if pkg.name == loc_pkg:
                    loc_pkg_prefix_list = locale_map.get(loc_pkg)
                    for loc_pkg_prefix in loc_pkg_prefix_list:
                        self.loc_pkgs_set.add(loc_pkg_prefix)
                    break

        self.loc_pkgs_list_dict = dict()
        for loc_pkg in self.loc_pkgs_set:
            self.loc_pkgs_list_dict[loc_pkg] = list()
        for pkg in cache.packages:
            if not pkg.version_list:
                continue
            for loc_pkg in self.loc_pkgs_set:
                if pkg.name.startswith(loc_pkg + '-'):
                    self.loc_pkgs_list_dict[loc_pkg].append(pkg.name)

    def compute_locale_loc_suf_list(self, locale: str) -> list:
        """
        Compute a list of locale package name suffixes. The sequence of
        suffixes are in preferential order, the lowest index being most
        preferential.

        This is a very private method, used by detect_locale_packages.

        Arguments:
        locale - a locale string (eg. en_AU, pt_PT etc.)
        """
        loc_suf_list = list()
        try:
            ll, cc = locale.lower().split('_')
        except ValueError as e:
            raise FllLocalesError(e)
        loc_suf_list.append(f'{ll}-{cc}')
        loc_suf_list.append(f'{ll}{cc}')
        loc_suf_list.append(ll)

        if ll != 'en':
            loc_suf_list.append('i18n')

        return loc_suf_list

    def detect_locale_packages(self, locale: str) -> list:
        """
        Process the data structures created at FllLocales instantiation and
        return a list of package names which are the likely best candidates
        for the locale string given as argument.

        Arguments:
        locale - a locale string (eg. en_AU, pt_PT etc.)
        """
        suffixes = self.compute_locale_loc_suf_list(locale)

        loc_pkg_dict = dict()
        for pkg in self.loc_pkgs_set:
            loc_pkgs_list = self.loc_pkgs_list_dict.get(pkg)
            if not loc_pkgs_list:
                continue
            if pkg not in loc_pkg_dict:
                loc_pkg_dict[pkg] = dict()
            for loc_pkg in loc_pkgs_list:
                for idx, suf in enumerate(suffixes):
                    if loc_pkg == '-'.join([pkg, suf]):
                       loc_pkg_dict[pkg][idx] = loc_pkg

        packages = list()
        for pkg in self.loc_pkgs_set:
            pkg_candidates = loc_pkg_dict.get(pkg)
            if not pkg_candidates:
                continue
            best = min(pkg_candidates)
            packages.append(pkg_candidates[best])

        return packages

class FllError(Exception):
    '''A generic error handler that does nothing.'''
    pass

class FLLBuilder(object):
    env = {'LANGUAGE': 'C', 'LC_ALL': 'C', 'LANG' : 'C', 'HOME': '/root',
           'PATH': '/usr/sbin:/usr/bin:/sbin:/bin', 'SHELL': '/bin/bash',
           'DEBIAN_FRONTEND': 'noninteractive', 'DEBIAN_PRIORITY': 'critical',
           'DEBCONF_NOWARNINGS': 'yes'}

    diverts = ['/usr/sbin/policy-rc.d',
               '/usr/sbin/modprobe',
               '/usr/sbin/insmod',
               '/usr/sbin/update-grub',
               '/usr/sbin/update-initramfs']

    def __init__(self, options):
        '''Accept options dict, setup logging.'''
        self.opts = options
        self.conf = None
        self.temp = None

        self.log = logging.getLogger('log')
        self.log.setLevel(logging.DEBUG)

        self.time = time.perf_counter()
        self.date = datetime.datetime.now(datetime.UTC)
        self.uuid = self.date.strftime('%Y-%m-%d-%H-%M-%S-00')
        self.timestamp = self.date.strftime('%Y%m%d%H%M')

    def prep_dir(self, dirname: str) -> str:
        '''Set up working directories.'''
        if not os.path.isdir(dirname):
            try:
                os.makedirs(dirname)
                os.chown(dirname, self.opts.uid, self.opts.gid)
            except:
                self.log.exception(f'failed to create directory: {dirname}')
                raise FllError

        return os.path.realpath(dirname)

    def init_logger(self, lvl: str) -> None:
        '''Set up the logger.'''
        fmt = logging.Formatter('%(asctime)s %(levelname)-5s - %(message)s')
        out = logging.StreamHandler()
        out.setFormatter(fmt)
        out.setLevel(lvl)
        self.log.addHandler(out)

    def init_logfile(self) -> None:
        '''Set up a log file.'''
        distro_name = self.conf['distro']['FLL_DISTRO_NAME']
        log_filename = os.path.join(self.opts.output_dir,
                                    f'{distro_name}-{self.timestamp}.iso.fll.log')
        log_filename = os.path.realpath(log_filename)
        dirname = os.path.dirname(log_filename)
        self.prep_dir(dirname)

        try:
            fmt = logging.Formatter('%(asctime)s %(levelname)-5s ' +
                                     '%(message)s')
            logfile = logging.FileHandler(filename = log_filename, mode = 'w')
            logfile.setFormatter(fmt)
            logfile.setLevel(logging.DEBUG)
            self.log.addHandler(logfile)
            os.chown(log_filename, self.opts.uid, self.opts.gid)
            self.log.debug(' '.join(sys.argv))
        except:
            self.log.exception(f'failed to setup logfile: {log_filename}')
            raise FllError

    def init_cli_options(self) -> None:
        '''Check and provide default class options.'''
        if os.path.isfile(self.opts.config):
            self.opts.config = os.path.realpath(self.opts.config)
        else:
            self.log.critical(f'configuration file does not exist: {self.opts.config}')
            raise FllError

        if not os.path.isdir(self.opts.share):
            self.log.critical(f'share directory not exist: {self.opts.share}')
            raise FllError

        if self.opts.build:
            self.opts.build = self.prep_dir(self.opts.build)

        if self.opts.output_dir:
            self.opts.output_dir = self.prep_dir(self.opts.output_dir)
        else:
            self.opts.output_dir = self.opts.build

        if self.opts.debug:
            self.init_logger(logging.DEBUG)
        else:
            self.init_logger(logging.INFO)

    def get_distro_imagefile(self, chroot: str) -> str:
        '''Return image file that compressed chroot will be archived to.'''
        image_file = self.conf['distro']['FLL_IMAGE_FILE']
        return image_file + f'.{chroot}'

    def get_distro_stamp(self, chroot: str) -> str:
        '''Return a string suitable for the distro stamp file.'''
        profile = self.conf['chroots'][chroot]['packages']['profile']
        codename = self.conf['chroots'][chroot]['packages']['codename']
        arch = self.conf['chroots'][chroot]['packages']['arch']
        defaults = self.conf['distro']
        stamp = defaults['FLL_DISTRO_NAME']
        if defaults.get('FLL_DISTRO_VERSION') == 'snapshot':
            stamp += ' - %s' % profile
            try:
                stamp += ' %s' % codename
            except KeyError:
                pass
        else:
            if defaults.get('FLL_DISTRO_CODENAME_REV'):
                stamp += ' - %s' % defaults['FLL_DISTRO_CODENAME']
                stamp += ' %s -' % defaults['FLL_DISTRO_CODENAME_REV']
            elif defaults.get('FLL_DISTRO_CODENAME'):
                stamp += ' %s -' % defaults['FLL_DISTRO_CODENAME']

            stamp += f' {profile}'

        stamp += f' - ({self.timestamp})'

        self.log.debug('stamp: %s' % stamp)
        return stamp

    def init_configuration(self) -> None:
        '''Parse build configuration file and return it in a dict.'''
        self.log.info(f'reading configuration file: {self.opts.config}')

        fll_configspec = os.path.join(self.opts.share, 'fll.conf.spec')
        self.conf = ConfigObj(self.opts.config, configspec=fll_configspec)

        validator = Validator()
        result = self.conf.validate(validator, preserve_errors=True)
        fatal_error = False
        for entry in flatten_errors(self.conf, result):
            # each entry is a tuple
            section_list, key, error = entry
            if key is not None:
                section_list.append(key)
            else:
                section_list.append('[missing section]')
            section_string = ' => '.join(section_list)
            if error == False:
                error = 'missing value or section'
            self.log.critical(f'{error}: {section_string}')
            fatal_error = True
        else:
            if fatal_error == True:
                raise FllError

    def write_configuration(self) -> None:
        '''Save build configuration with live media. Use only at end.'''
        distro_name = self.conf['distro']['FLL_DISTRO_NAME']
        conf_name = f'{distro_name}-{self.timestamp}.iso.fll.conf'
        self.conf.filename = os.path.join(self.opts.output_dir, conf_name)
        self.conf.write()
        os.chown(self.conf.filename, self.opts.uid, self.opts.gid)

    def expand_pkg_profile(self, chroot: str, profile: str, modules_dir: str) -> dict:
        '''Return a dict, chroot string as key and package, debconf and postinst
        lists.'''
        debconf = set()
        packages = set()
        postinst = set()
        arch = self.conf['chroots'][chroot]['packages']['arch']
        linux = self.conf['chroots'][chroot]['packages']['linux']
        browsers = self.conf['chroots'][chroot]['packages'].get('browser')
        for browser in browsers:
            packages.add(browser)

        ro_fs = self.conf['options']['readonly_filesystem']
        if ro_fs == 'squashfs':
            packages.add('squashfs-tools')
        elif ro_fs == 'erofs':
            packages.add('erofs-utils')

        linux_meta = ['linux-image', 'linux-headers']
        packages.update(['-'.join([l, linux]) for l in linux_meta])

        profile_conf = ConfigObj(profile)

        if 'desc' in profile_conf:
            for line in multiline_to_list(profile_conf['desc']):
                self.log.debug(f'  {line}')

        if 'debconf' in profile_conf:
            self.log.debug('debconf:')
            for line in multiline_to_list(profile_conf['debconf']):
                debconf.add(line)
                self.log.debug(f'  {line}')

        if 'packages' in profile_conf:
            self.log.debug('packages:')
            for line in multiline_to_list(profile_conf['packages']):
                packages.add(line)
                self.log.debug(f'  {line}')

        if arch in profile_conf:
            self.log.debug(f'packages ({arch}):')
            for line in multiline_to_list(profile_conf[arch]):
                packages.add(line)
                self.log.debug(f'  {line}')

        modules = set()
        if 'modules' in profile_conf:
            self.log.debug('modules:')
            for module in multiline_to_list(profile_conf['modules']):
                modules.add(module)
                self.log.debug(f'  {module}')

        if 'modules' in self.conf['chroots'][chroot]['packages']:
            self.log.debug('modules (config):')
            for module in self.conf['chroots'][chroot]['packages']['modules']:
                modules.add(module)
                self.log.debug(f'  {module}')

        if os.path.isfile(profile + '.postinst'):
            self.log.debug(f'registering postinst script: {profile}.postinst')
            postinst.add(profile + '.postinst')

        self.log.debug('---')

        for module in modules:
            module_file = os.path.join(modules_dir, module)

            if not os.path.isfile(module_file):
                self.log.critical(f'no such module file: {module_file}')
                raise FllError

            self.log.debug(f'processing module file: {module}')

            module_conf = ConfigObj(module_file)

            if 'desc' in module_conf:
                for line in multiline_to_list(module_conf['desc']):
                    self.log.debug(f'  {line}')

            if 'debconf' in module_conf:
                self.log.debug('debconf:')
                for line in multiline_to_list(module_conf['debconf']):
                    debconf.add(line)
                    self.log.debug(f'  {line}')

            if 'packages' in module_conf:
                self.log.debug('packages:')
                for line in multiline_to_list(module_conf['packages']):
                    packages.add(line)
                    self.log.debug(f'  {line}')

            if arch in module_conf:
                self.log.debug(f'packages ({arch}):')
                for line in multiline_to_list(module_conf[arch]):
                    packages.add(line)
                    self.log.debug(f'  {line}')

            if os.path.isfile(module_file + '.postinst'):
                self.log.debug(f'registering postinst script: {module_file}.postinst')
                postinst.add(module_file + '.postinst')

            self.log.debug('---')

        return debconf, packages, postinst

    def parse_package_profile(self, chroot: str) -> None:
        '''Parse packages profile for each chroot.'''
        profiles = self.conf['chroots'][chroot]['packages']['profile']
        profile_dir = os.path.join(self.opts.share, 'profiles')
        modules_dir = os.path.join(self.opts.share, 'modules')

        self.pkgs = {chroot: {'debconf': set(), 'packages': set(), 'postinst': set()}}
        for profile in profiles:
            self.log.info(f'{chroot} - processing package profile: {profile}')
            profile = os.path.join(profile_dir, profile)
            if not os.path.isfile(profile):
                self.log.critical(f'no such package profile: {profile}')
                raise FllError
            debconf, packages, postinst = self.expand_pkg_profile(chroot, profile, modules_dir)
            self.pkgs[chroot]['debconf'].update(debconf)
            self.pkgs[chroot]['packages'].update(packages)
            self.pkgs[chroot]['postinst'].update(postinst)

        self.log.debug(f'debconf summary for {chroot}:')
        for item in sorted(self.pkgs[chroot]['debconf']):
            self.log.debug(f'  {item}')

        self.log.debug(f'package summary for {chroot}:')
        for item in sorted(self.pkgs[chroot]['packages']):
            self.log.debug(f'  {item}')

        self.log.debug(f'postinst summary for {chroot}:')
        for item in sorted(self.pkgs[chroot]['postinst']):
            self.log.debug(f'  {item}')

    def get_debconf_list(self, chroot: str) -> list:
        '''Return debconf list for chroot. Dynamically generate locales
        debconf configuration based on i18n configuration in flk.conf.'''
        i18n_list = self.conf['chroots'][chroot]['packages']['locales']
        i18n_debconf = 'locales locales/locales_to_be_generated multiselect '
        for i18n in i18n_list:
            i18n_debconf += f'{i18n}.UTF-8 UTF-8,'
        i18n_debconf = i18n_debconf.rstrip(',')
        self.pkgs[chroot]['debconf'].add(i18n_debconf)

        return self.pkgs[chroot]['debconf']

    def stage_build_directory(self) -> None:
        '''Prepare temporary directory for chroots and result staging area.'''
        self.log.debug('preparing build area...')

        self.temp = tempfile.mkdtemp(prefix = 'fll_', dir = self.opts.build)
        os.chown(self.temp, self.opts.uid, self.opts.gid)

        atexit.register(self.cleanup)

        stage = os.path.join(self.temp, 'staging')
        os.mkdir(stage)
        os.mkdir(os.path.join(stage, 'boot'))
        os.mkdir(os.path.join(stage, self.conf['distro']['FLL_IMAGE_DIR']))

        media_include = self.conf['options'].get('media_include')
        if media_include and os.path.isdir(media_include):
            try:
                target_dirpath = os.path.join(stage, os.path.basename(media_include))
                shutil.copytree(media_include, target_dirpath, dirs_exist_ok=True,
                                ignore=shutil.ignore_patterns('.git*'))
            except:
                self.log.exception(f'problem copying media_include data to staging dir: {media_include}')
                raise FllError

    def mount_virtfs(self, chroot: str) -> None:
        '''Mount virtual filesystems in a chroot.'''
        chroot_dir = os.path.join(self.temp, chroot)
        virtfs = {'devpts': 'dev/pts', 'proc': 'proc'}

        for v in list(virtfs.items()):
            cmd = ['mount', '-t', v[0], 'fll-' + v[0],
                   os.path.join(chroot_dir, v[1])]

            self.exec_cmd(cmd)

    def umount_virtfs(self, chroot: str) -> None:
        '''Umount any mount points in a chroot.'''
        chroot_dir = os.path.join(self.temp, chroot)
        umount_list = []
        try:
            for line in open('/proc/mounts'):
                (dev, mnt, fs, options, d, p) = line.split()
                if mnt.startswith(chroot_dir):
                    umount_list.append(mnt)
        except IOError:
            self.log.exception('failed to open /proc/mounts')
            raise FllError

        umount_list.sort(key=len)
        umount_list.reverse()

        for mpoint in umount_list:
            self.exec_cmd(['umount', mpoint])

    def nuke_directory(self, dirname: str) -> None:
        '''Nuke directory tree.'''
        if os.path.isdir(dirname):
            self.log.debug(f'nuking directory: {dirname}')
            try:
                shutil.rmtree(dirname)
            except:
                self.log.exception(f'unable to remove {dirname}')
                raise FllError
        else:
            self.log.debug(f'directory does not exist: {dirname}')

    def nuke_chroot(self, chroot: str) -> None:
        '''Convenience function to nuke chroot given by chroot name.'''
        if not self.opts.preserve:
            self.log.info(f'{chroot} - nuking chroot...')
            self.umount_virtfs(chroot)
            self.nuke_directory(os.path.join(self.temp, chroot))

    def cleanup(self) -> None:
        '''Clean up the build area after taking care that all build chroots
        have been taken care of.'''
        self.log.info('cleaning up...')
        chroots = [chroot for chroot in self.opts.chroots] \
            if self.opts.chroots else self.conf['chroots'].keys()
        for chroot in chroots:
            dirname = os.path.join(self.temp, chroot)
            if os.path.isdir(dirname):
                self.log.debug(f'cleaning up chroot: {chroot}')
                self.umount_virtfs(dirname)
                if not self.opts.preserve:
                    self.nuke_directory(dirname)

        if not self.opts.preserve:
            self.nuke_directory(self.temp)

    def exec_cmd(self, cmd: list) -> None:
        '''Execute subprocess with support for logging to a file.'''
        self.log.debug(shlex.join(cmd))

        try:
            if self.opts.debug:
                proc = subprocess.Popen(cmd, env=self.env,
                                        stdout=subprocess.PIPE,
                                        stderr=subprocess.STDOUT,
                                        universal_newlines=True)
                for stdout_line in iter(proc.stdout.readline, ""):
                    self.log.debug(stdout_line.strip())
                proc.stdout.close()
                return_code = proc.wait()
                if return_code:
                    raise subprocess.CalledProcessError(return_code, shlex.join(cmd))
            else:
                if self.opts.quiet:
                    subprocess.run(cmd, env=self.env, check=True,
                                   stdout=subprocess.DEVNULL,
                                   stderr=subprocess.STDOUT)
                else:
                    subprocess.run(cmd, env=self.env, check=True)
        except KeyboardInterrupt:
            raise FllError
        except subprocess.CalledProcessError:
            self.log.exception(f'problem executing command: {shlex.join(cmd)}')
            raise FllError

    def chroot_exec(self, chroot: str, args: list) -> None:
        '''Run command in a chroot.'''
        chroot_dir = os.path.join(self.temp, chroot)
        cmd = ['chroot', chroot_dir]
        cmd.extend(args)
        self.exec_cmd(cmd)

    def apt_get(self, chroot: str, command: str, args: list=[], insecure: bool=False) -> None:
        '''An apt-get install wrapper. Automatic installation of recommended
        packages defaults to disabled.'''
        aptget = ['apt-get', '--yes', '-qq']
        if insecure:
            aptget.extend(['-o', 'Acquire::AllowInsecureRepositories=1'])
        aptget.extend(['-o', 'Acquire::Languages=none'])
        aptget.extend(['-o', 'Dpkg::Use-Pty=0'])
        aptget.extend(['-o', 'Dpkg::Progress-Fancy=0'])
        aptget.extend(['-o', 'APT::Color=0'])

        apt_recommends = self.conf['options'].get('apt_recommends', 'no')
        if apt_recommends == 'no':
            aptget.extend(['-o', 'APT::Install-Recommends=0'])
        if self.opts.debug:
            aptget.extend(['-o', 'APT::Get::Show-Versions=1'])

        aptget.append(command)
        if args:
            aptget.extend(args)

        self.chroot_exec(chroot, aptget)

    def debbootstrap(self, chroot: str, arch: str, target: str, mirror: str, codename: str) -> None:
        '''Bootstrap a distro root filesystem with debootstrap.'''
        bootstrapper = self.conf['options'].get('bootstrapper')
        bootstrap_includes='apt-utils,ca-certificates,gnupg,xz-utils,zstd'
        if bootstrapper == 'mmdebstrap':
            cmd = ['mmdebstrap', f'--architectures={arch}',
                   f'--include={bootstrap_includes}',
                   '--variant=minbase', '--mode=root', '--format=directory',
                   '--hook-dir=/usr/share/mmdebstrap/hooks/merged-usr']
        elif bootstrapper == 'debootstrap':
            cmd = ['debootstrap', f'--arch={arch}',
                   f'--include={bootstrap_includes}',
                   '--variant=minbase', '--merged-usr']
        else:
            cmd = ['cdebootstrap', f'--arch={arch}',
                   f'--include={bootstrap_includes}',
                   '--flavour=minimal']

        cmd.extend([codename, target, mirror])

        if self.opts.debug or self.opts.verbose:
            cmd.insert(1, '--verbose')

        self.exec_cmd(cmd)

        if bootstrapper == 'cdebootstrap':
            self.chroot_exec(chroot, ['dpkg', '--purge',
                                      'cdebootstrap-helper-rc.d'])

    def chroot_bootstrap(self, chroot: str) -> None:
        '''Bootstrap a distro root filesystem with cdebootstrap.'''
        distro = self.conf['chroots'][chroot]['packages']['distro']
        codename = self.conf['chroots'][chroot]['packages']['codename']
        arch = self.conf['chroots'][chroot]['packages']['arch']

        dist_repo = self.conf['chroots'][chroot]['repos'][distro]
        if dist_repo.get('cached'):
            mirror = dist_repo['cached']
        else:
            mirror = dist_repo['uri']
            # auto-apt-proxy support
            auto_apt_proxy = shutil.which('auto-apt-proxy')
            if auto_apt_proxy:
                apt_proxy = subprocess.run([auto_apt_proxy],
                                           stdout=subprocess.PIPE).stdout.decode('utf-8')
                if apt_proxy:
                    mirror = apt_proxy.rstrip() + '/' + mirror.split('//')[1]

        target = os.path.join(self.temp, chroot)

        self.log.info(f'{chroot} - bootstrapping {distro} {codename} {arch}...')
        self.debbootstrap(chroot, arch, target, mirror, codename)
        self.mount_virtfs(chroot)
        shutil.copy('/etc/hosts', os.path.join(target, 'etc'))
        shutil.copy('/etc/resolv.conf', os.path.join(target, 'etc'))
        os.mkdir(os.path.join(target, 'disks'), 0o755)

    def write_apt_lists(self, chroot: str, cached: bool=False, src_uri: bool=False) -> None:
        '''Write apt source lists to /etc/apt/sources.list.d/*.'''
        distro = self.conf['chroots'][chroot]['packages']['distro']
        chroot_dir = os.path.join(self.temp, chroot)
        auto_apt_proxy = shutil.which('auto-apt-proxy')
        apt_proxy = None
        if auto_apt_proxy:
            apt_proxy = subprocess.run([auto_apt_proxy],
                                       stdout=subprocess.PIPE).stdout.decode('utf-8')
        for dist_repo in self.conf['chroots'][chroot]['repos'].keys():
            repo = self.conf['chroots'][chroot]['repos'][dist_repo]
            repo_uri = repo.get('uri')
            cached_uri = repo.get('cached')
            if not cached_uri and apt_proxy and repo_uri:
                cached_uri = apt_proxy.rstrip() + '/' + repo_uri.split('//')[1]
            sources_uri = repo.get('sources_uri')
            if sources_uri:
                cmd = ['wget', '--quiet', sources_uri, '-O']
                cmd.append(os.path.join(chroot_dir, 'etc/apt/sources.list.d',
                                        os.path.basename(sources_uri)))
                self.exec_cmd(cmd)

                if cached and cached_uri:
                    cmd = ['sed', '-i', f's#^URIs: .*#URIs: {cached_uri}#']
                    cmd.append(os.path.join(chroot_dir, 'etc/apt/sources.list.d',
                                            os.path.basename(sources_uri)))
                    self.exec_cmd(cmd)
                continue

            sources_file = os.path.join(chroot_dir, 'etc/apt/sources.list.d',
                                        dist_repo + '.sources')

            self.log.debug("creating %s" % sources_file)
            sources_file_fh = None
            try:
                sources_file_fh = open(sources_file, 'w')
                if src_uri:
                    sources_file_fh.write('Types: deb deb-src\n')
                else:
                    sources_file_fh.write('Types: deb\n')
                if cached and cached_uri:
                    sources_file_fh.write(f'URIs: {cached_uri}\n')
                else:
                    sources_file_fh.write(f'URIs: {repo_uri}\n')
                sources_file_fh.write(f'Suites: {repo['suite']}\n')
                sources_file_fh.write(f'Components: {repo['components']}\n')
                if repo.get('keyring'):
                    sources_file_fh.write(f'Signed-by: /usr/share/keyrings/{repo['keyring']}.gpg\n')
                else:
                    sources_file_fh.write(f'Signed-by: /usr/share/keyrings/{distro}-archive-keyring.gpg\n')
            except IOError:
                self.log.exception('failed to open %s' % sources_file)
                raise FllError
            finally:
                if sources_file_fh:
                    sources_file_fh.close()

    def prime_apt(self, chroot: str) -> None:
        '''Prepare apt for work in each build chroot. Fetch all required gpg
        keys and initialize apt_pkg config.'''
        self.log.info(f'{chroot} - preparing apt...')
        chroot_dir = os.path.join(self.temp, chroot)
        arch = self.conf['chroots'][chroot]['packages']['arch']

        apt_preferences = self.conf['options'].get('apt_preferences')
        if apt_preferences:
            self.log.info(f'{chroot} - importing apt preferences file: {apt_preferences}')
            try:
                shutil.copy(apt_preferences, os.path.join(chroot_dir, 'etc/apt/'))
            except IOError:
                self.log.error(f'failed to import apt preferences: {apt_preferences}')
                raise FllError

        sources_list = os.path.join(chroot_dir, 'etc/apt/sources.list')
        if os.path.isfile(sources_list):
            os.unlink(sources_list)

        src_uri = not self.opts.binary
        self.write_apt_lists(chroot, cached=True, src_uri=src_uri)

        keyrings = list()
        for dist_repo in self.conf['chroots'][chroot]['repos'].keys():
            repo = self.conf['chroots'][chroot]['repos'][dist_repo]
            keyring = repo.get('keyring')
            if keyring:
                keyrings.append(keyring)

        if keyrings:
            self.apt_get(chroot, 'update', insecure=True)
            self.apt_get(chroot, 'install', args=keyrings, insecure=True)

        self.apt_get(chroot, 'update')
        self.apt_get(chroot, 'dist-upgrade')

        apt_pkg.config.set('RootDir', chroot_dir)
        apt_pkg.config.set('APT::Architecture', arch)
        apt_pkg.init()
        self.log.debug(f'apt_pkg architecture: {apt_pkg.config["RootDir"]}')
        self.log.debug(f'apt_pkg architecture: {apt_pkg.config["APT::Architecture"]}')

    def dpkg_divert(self, chroot: str) -> None:
        '''Divert some facilities and replace temporaily with /bin/true (or
        some other more appropiate facility.'''
        chroot_dir = os.path.join(self.temp, chroot)
        for divert in self.diverts:
            self.log.debug(f'diverting {divert}')
            cmd = 'dpkg-divert --add --local --divert ' + divert + '.REAL --rename '
            cmd += divert
            self.chroot_exec(chroot, cmd.split())

            if divert == '/usr/sbin/policy-rc.d':
                self.write_file(chroot_dir, divert)
                os.chmod(os.path.join(chroot_dir, divert.lstrip('/')), 0o755)
            else:
                os.symlink('/bin/true', os.path.join(chroot_dir, divert.lstrip('/')))

    def dpkg_undo_divert(self, chroot: str) -> None:
        '''Undivert facilities diverted by self.dpkg_divert().'''
        chroot_dir = os.path.join(self.temp, chroot)
        for divert in self.diverts:
            self.log.debug(f'undoing diversion: {divert}')
            os.unlink(os.path.join(chroot_dir, divert.lstrip('/')))
            cmd = 'dpkg-divert --remove --rename ' + divert
            self.chroot_exec(chroot, cmd.split())

    def write_file(self, chroot: str, filename: str) -> None:
        '''Write a file in a chroot. Templates for common files included
        below.'''
        chroot_dir = os.path.join(self.temp, chroot)

        f = None
        fn = None
        mode = 0o644
        try:
            fn = os.path.join(chroot_dir, filename.lstrip('/'))
            if os.path.isfile(fn):
                mode = None
            if not os.path.exists(os.path.dirname(fn)):
                try:
                    os.makedirs(os.path.dirname(fn), 0o755)
                except OSError as exc:
                    if exc.errno != errno.EEXIST:
                        raise
            f = open(fn, 'w')
            self.log.debug(f'writing file: {filename}')
            if filename == '/etc/default/distro':
                defaults = list(self.conf['distro'].keys())
                defaults.sort()
                for key in defaults:
                    if key.startswith('FLL_DISTRO_CODENAME'):
                        continue
                    elif key == 'FLL_IMAGE_FILE':
                        image_file = self.get_distro_imagefile(chroot)
                        f.write('%s="%s"\n' % (key, image_file))
                        f.write('%s="$%s/$%s"\n' % ('FLL_IMAGE_LOCATION',
                                                    'FLL_IMAGE_DIR', key))
                    else:
                        f.write('%s="%s"\n' % (key, self.conf['distro'][key]))
            elif filename == '/etc/fstab':
                f.write('# /etc/fstab: static file system information\n')
            elif filename == '/etc/hostname':
                hostname = self.conf['distro']['FLL_DISTRO_NAME']
                f.write(hostname + '\n')
            elif filename == '/etc/hosts':
                hostname = self.conf['distro']['FLL_DISTRO_NAME']
                f.write('127.0.0.1\tlocalhost\n')
                f.write('127.0.0.1\t' + hostname + '\n\n')
                f.write('# Below lines are for IPv6 capable hosts\n')
                f.write('::1     ip6-localhost ip6-loopback\n')
                f.write('fe00::0 ip6-localnet\n')
                f.write('ff00::0 ip6-mcastprefix\n')
                f.write('ff02::1 ip6-allnodes\n')
                f.write('ff02::2 ip6-allrouters\n')
                f.write('ff02::3 ip6-allhosts\n')
            elif filename == '/usr/sbin/policy-rc.d':
                f.write('#!/bin/sh\n')
                f.write('echo "$0 denied action: $1 $2" >&2\n')
                f.write('exit 101\n')
            elif filename == '/tmp/iso_uuid':
                f.write(self.uuid)
                self.conf['distro']['FLL_UUID'] = self.uuid
        except IOError:
            self.log.exception(f'failed to open file for writing: {filename}')
            raise FllError
        finally:
            if f:
                f.close()
                if mode:
                    os.chmod(fn, mode)

    def write_default_conffiles(self, chroot: str) -> None:
        '''Initial creation of conffiles required in chroot.'''
        self.write_file(chroot, '/etc/fstab')
        self.write_file(chroot, '/etc/hostname')
        self.write_file(chroot, '/tmp/iso_uuid')

    def write_distro_defaults(self, chroot: str) -> None:
        '''Write the /etc/default/distro file.'''
        self.write_file(chroot, '/etc/default/distro')

    def write_final_conffiles(self, chroot: str) -> None:
        '''Final editing of conffiles in chroot.'''
        chroot_dir = os.path.join(self.temp, chroot)

        distro_version = '%s-version' % \
                         self.conf['distro']['FLL_DISTRO_NAME'].lower()
        distro_version = os.path.join(chroot_dir, 'etc', distro_version)

        self.log.debug(f'stamping distro version: {distro_version}')
        f = None
        try:
            f = open(distro_version, 'w')
            f.write(self.get_distro_stamp(chroot))
        except IOError:
            self.log.exception(f'failed to open file for writing: {distro_version}')
            raise FllError
        finally:
            if f:
                f.close()
                os.chmod(distro_version, 0o444)

        self.write_file(chroot, '/etc/hosts')
        self.write_file(chroot, '/etc/motd.tail')

        self.log.debug('writing final apt sources.list(s)')
        self.write_apt_lists(chroot, cached=self.opts.apt_cache)

        if os.path.isfile(os.path.join(chroot_dir, 'etc/resolv.conf')) and \
           not os.path.islink(os.path.join(chroot_dir, 'etc/resolv.conf')) and \
           os.path.isfile(os.path.join(chroot_dir, 'etc/systemd/resolved.conf')):
            # networkd+resolved so setup symlink and disable fallback DNS
            try:
                os.unlink(os.path.join(chroot_dir, 'etc/resolv.conf'))
                os.symlink('../run/systemd/resolve/stub-resolv.conf', os.path.join(chroot_dir, 'etc/resolv.conf'))
                with open(os.path.join(chroot_dir, 'etc/systemd/resolved.conf'), 'a') as f:
                    f.write('DNS=\n')
            except IOError:
                self.log.exception('failed to setup resolv.conf and resolved.conf')
                raise FllError

        homed_privkey = self.conf['options'].get('homed_privkey')
        homed_pubkey  = self.conf['options'].get('homed_pubkey')
        if homed_privkey and homed_pubkey:
            self.log.info(f'{chroot} - copying systemd-homed keys to chroot...')
            try:
                os.makedirs(os.path.join(chroot_dir, 'var/lib/systemd/home/'))
                shutil.copy(homed_privkey, os.path.join(chroot_dir, 'var/lib/systemd/home/'))
                shutil.copy(homed_pubkey, os.path.join(chroot_dir, 'var/lib/systemd/home/'))
            except FileNotFoundError:
                self.log.exception('homed configuration failed')
                raise FllError

        boot_theme = self.conf['options'].get('boot_theme', 'bgrt')
        self.log.info(f'{chroot} - setting {boot_theme} plymouth theme...')
        self.chroot_exec(chroot, ['plymouth-set-default-theme', boot_theme])

    def create_initramfs(self, chroot: str) -> None:
        '''Generate the initramfs if update-initramfs was diverted'''
        if '/usr/sbin/update-initramfs' in self.diverts:
            chroot_dir = os.path.join(self.temp, chroot)
            kvers = self.detect_linux_version(chroot)
            for kernel in kvers:
                cmd = f'update-initramfs -c -k {kernel}'
                if self.opts.verbose or self.opts.debug:
                    cmd += ' -v'
                self.chroot_exec(chroot, shlex.split(cmd))

    def preseed_debconf(self, chroot: str) -> None:
        '''Preseed debconf with values read from package lists.'''
        chroot_dir = os.path.join(self.temp, chroot)
        debconf_list = self.get_debconf_list(chroot)

        if debconf_list:
            self.log.debug(f'{chroot} - preseeding debconf...')
            debconf = None
            try:
                debconf = open(os.path.join(chroot_dir, 'tmp',
                                            'fll_debconf_selections'), 'w')
                debconf.writelines([f'{d}\n' for d in debconf_list])
            except IOError:
                self.log.exception('failed to open file for writing: %s' %
                                   '/tmp/fll_debconf_selections')
                raise FllError
            finally:
                if debconf:
                    debconf.close()

            cmd = 'debconf-set-selections '
            if self.opts.verbose:
                cmd += '--verbose '
            cmd += '/tmp/fll_debconf_selections'

            self.chroot_exec(chroot, cmd.split())

    def detect_linux_version(self, chroot: str) -> list:
        '''Return version string of a singularly installed linux-image.'''
        linux = self.conf['chroots'][chroot]['packages']['linux']
        linux_meta = f'linux-image-{linux}'
        linux_images = [f[len('linux-image-'):] for f in
                        self.pkgs[chroot]['manifest']
                        if f.startswith('linux-image-') and not f == linux_meta]

        if len(linux_images) > 0:
            linux_images.sort(key=functools.cmp_to_key(apt_pkg.version_compare))
            linux_images.reverse()
            return linux_images

        self.log.critical(f'{chroot} - failed to detect linux version')
        raise FllError

    def detect_locale_packages(self, i18n: list, wanted: list, cache: apt_pkg.Cache) -> list:
        '''Provide automated detection for extra i18n packages.'''
        self.log.debug(f'detecting i18n packages for locales: {' '.join(i18n)}')

        locales_pkg_map_file = os.path.join(self.opts.share, 'data', 'locales-pkg-map')
        locales_pkg_map = ConfigObj(locales_pkg_map_file)
        self.log.debug('locales_pkg_map:')
        self.log.debug(locales_pkg_map)

        fll_locales = FllLocales(cache, wanted, locales_pkg_map)
        i18n_list = []
        for locale in sorted(i18n):
            try:
                loc_pkg_list = fll_locales.detect_locale_packages(locale)
            except FllLocalesError:
                print_error(f'Failed to parse locale string: {locale}')
            else:
                i18n_list.extend(loc_pkg_list)

        self.log.debug('i18n_list:')
        self.log.debug(i18n_list)
        return i18n_list

    def detect_recommended_packages(self, wanted: list, cache: apt_pkg.Cache) -> list:
        '''Provide automated detection for packages in recommends whitelist.'''
        apt_recommends = self.conf['options'].get('apt_recommends')
        if apt_recommends == 'yes':
            return []

        self.log.debug('detecting whitelisted recommended packages...')
        rec_module = ConfigObj(os.path.join(self.opts.share, 'packages',
                                            'packages.d', 'recommends'))
        try:
            rec_dict = dict([(p, True) for p in
                             multiline_to_list(rec_module['packages'])])
        except KeyError:
            self.log.debug('rec_dict:')
            return []

        self.log.debug('rec_dict:')
        self.log.debug(rec_dict)

        rec_list = []
        for p in wanted.keys():
            if not p in rec_dict:
                continue
            package = cache[p]
            current = package.current_ver
            if not current:
                versions = package.version_list
                if not versions:
                    continue
                version = versions[0]
                for other_version in versions:
                    if apt_pkg.version_compare(version.ver_str,
                                               other_version.ver_str) < 0:
                        version = other_version
                current = version

            depends = current.depends_list
            list = depends.get('Recommends', [])
            for dependency in list:
                depdone = 0
                for deppart in dependency:
                    if depdone > 0:
                        continue
                    name = deppart.target_pkg.name
                    if name in wanted.keys():
                        depdone = 1
                        continue
                if depdone == 0:
                    name = dependency[0].target_pkg.name
                    dep = cache[name]
                    if dep.current_ver:
                        continue
                    rec_list.append(dep.name)

        self.log.debug('rec_list:')
        self.log.debug(rec_list)
        return rec_list

    def get_source_package(self, pkg: str, depcache: apt_pkg.DepCache,
                           records: apt_pkg.PackageRecords) -> list[str, str]:
        '''Get the source package name of a given package.'''
        version = depcache.get_candidate_ver(pkg)

        if not version:
            return None
        file, index = version.file_list.pop(0)
        records.lookup((file, index))

        srcpkg = pkg.name
        srcver = version.ver_str
        if records.source_pkg != "":
            srcpkg = records.source_pkg

        if records.source_ver != "":
            srcver = records.source_ver

        return [srcpkg, srcver]

    def write_manifest(self, chroot: str) -> None:
        '''Collect package and source package URI information from each
        chroot.'''
        chroot_dir = os.path.join(self.temp, chroot)
        image_dir = os.path.join(self.temp, 'staging',
                                 self.conf['distro']['FLL_IMAGE_DIR'])
        self.log.info(f'{chroot} - writing package manifest...')

        cache = apt_pkg.Cache(apt.progress.base.OpProgress())
        records = apt_pkg.PackageRecords(cache)
        depcache = apt_pkg.DepCache(cache)

        manifest = dict([(p.name, p.current_ver.ver_str)
                         for p in cache.packages if p.current_ver
                         and not p.name.startswith('cdebootstrap-helper')])
        # Needed to detect installed linux-image
        self.pkgs[chroot]['manifest'] = manifest

        packages = list(manifest.keys())
        packages.sort(key=len)
        pkg_maxlen = len(packages[-1])
        packages.sort()

        manifest_name = self.get_distro_imagefile(chroot) + '.manifest'
        manifest_file = os.path.join(image_dir, manifest_name)

        try:
            with open(manifest_file, 'w') as manifest_fh:
                manifest_fh.writelines([f'{pkg.ljust(pkg_maxlen)} ' +
                                        f'{manifest[pkg]}\n'
                                        for pkg in packages])
        except IOError:
            self.log.exception(f'failed to write file: {manifest_file}')
            raise FllError
        finally:
            os.chown(manifest_file, self.opts.uid, self.opts.gid)

        if self.opts.binary:
            return

        self.log.info(f'{chroot} - writing source package URIs...')
        srcpkg_seen = dict()
        uris = []
        for pkg in packages:
            if pkg.startswith('cdebootstrap-helper'):
                continue

            srcpv = self.get_source_package(cache[pkg], depcache, records)
            srcpkg=srcpv[0]
            srcver=srcpv[1]
            if not srcpkg:
                self.log.critical(f'failed to lookup srcpkg name for {pkg}')
                raise FllError
            self.log.debug(f'{pkg} -> {srcpkg}')

            if srcpkg in srcpkg_seen:
                self.log.debug(f'already processed {srcpkg}, skipping...')
                continue
            else:
                srcpkg_seen[srcpkg] = True

            try:
                u = []
                sources = apt_pkg.SourceRecords()
                sources.restart()
                while sources.lookup(srcpkg):
                    if sources.version == srcver:
                        u.extend([sources.index.archive_uri(sources.files[f][2])
                                  for f in range(len(sources.files))])
                self.log.debug(u)
                uris.extend(u)
            except (apt_pkg.Error, SystemError) as e:
                self.log.critical(f'failed to query source uris for {srcpkg}: {e}')
                raise FllError

        uris.sort()

        sources_list = deduplicate_list(uris)

        sources_name = self.get_distro_imagefile(chroot) + '.sources'
        sources_file = os.path.join(image_dir, sources_name)

        sources = None
        try:
            with open(sources_file, 'w') as sources_fh:
                sources_fh.writelines([f'{s}\n' for s in sources_list])
        except IOError:
            self.log.exception(f'failed to write filename: {sources_file}')
            raise FllError
        finally:
            os.chown(sources_file, self.opts.uid, self.opts.gid)

    def install_packages(self, chroot: str) -> None:
        '''Install packages.'''
        cache = apt_pkg.Cache(apt.progress.base.OpProgress())
        if cache.ver_file_count < 200:
            cache = apt_pkg.Cache(apt.progress.base.OpProgress())

        pkgs_base = [pkg.name for pkg in cache.packages if pkg.current_ver]
        pkgs_want = deduplicate_list(pkgs_base + list(self.pkgs[chroot]['packages']))
        pkgs_dict = dict([(pkg, True) for pkg in pkgs_want])
        rec_pkgs = self.detect_recommended_packages(pkgs_dict, cache)
        pkgs_want = deduplicate_list(list(pkgs_dict.keys()) + rec_pkgs)
        pkgs_dict = dict([(pkg, True) for pkg in pkgs_want])
        loc_list = self.conf['chroots'][chroot]['packages']['locales']
        loc_pkgs = self.detect_locale_packages(loc_list, pkgs_dict, cache)
        pkgs_want = deduplicate_list(list(pkgs_dict.keys()) + loc_pkgs)

        self.log.info(f'{chroot} - installing packages...')
        self.apt_get(chroot, 'install', args=pkgs_want)

    def post_installation(self, chroot: str) -> None:
        '''Run package module postinst scripts in a chroot.'''
        chroot_dir = os.path.join(self.temp, chroot)

        self.log.info(f'{chroot} - executing postinst scripts...')

        # reset /etc/resolv.conf (systemd-resolved clobbered our settings)
        os.unlink(os.path.join(chroot_dir, 'etc/resolv.conf'))
        shutil.copy('/etc/resolv.conf', os.path.join(chroot_dir, 'etc'))

        for script in self.pkgs[chroot]['postinst']:
            sname = os.path.basename(script)
            try:
                shutil.copy(script, os.path.join(chroot_dir, 'tmp'))
                os.chmod(os.path.join(chroot_dir, 'tmp', sname), 0o755)
            except:
                self.log.exception(f'error preparing postinst script: {sname}')
                raise FllError

            cmd = f'/tmp/{sname} postinst'
            self.chroot_exec(chroot, cmd.split())
            os.unlink(os.path.join(chroot_dir, 'tmp', sname))

    def zero_logs(self, chroot: str, dirname: str, filenames: list) -> None:
        '''Truncate all log files.'''
        chroot_dir = os.path.join(self.temp, chroot)
        chrootdir = dirname.partition(chroot)[2]

        for f in filenames:
            if not os.path.isfile(os.path.join(dirname, f)):
                continue
            self.write_file(chroot, os.path.join(chrootdir, f))

    def clean_chroot(self, chroot: str) -> None:
        '''Remove unwanted content from a chroot.'''
        self.log.debug(f'{chroot} - purging unwanted content...')
        chroot_dir = os.path.join(self.temp, chroot)
        arch = self.conf['chroots'][chroot]['packages']['arch']

        cmd = 'dpkg --purge fll-live-initramfs'
        self.chroot_exec(chroot, cmd.split())
        self.chroot_exec(chroot, 'apt-get clean'.split())
        self.chroot_exec(chroot, 'dpkg --clear-avail'.split())

        for dirpath, dirnames, files in os.walk(os.path.join(chroot_dir, 'var/log')):
            self.zero_logs(chroot, dirpath, files)

    def mkreadonlyfs_chroot(self, chroot: str) -> None:
        '''Make readonly filesystem image of chroot.'''
        chroot_dir = os.path.join(self.temp, chroot)
        cmd = list()
        exclude_file = os.path.join(self.opts.share, 'data', 'fll_rootfs_exclusions')
        image_file = self.get_distro_imagefile(chroot)
        if self.conf['options']['readonly_filesystem'] == 'squashfs':
            cmd = ['mksquashfs', '.', image_file, '-noappend']

            shutil.copy(exclude_file, os.path.join(chroot_dir, 'tmp'))
            cmd.extend(['-wildcards', '-ef', '/tmp/fll_rootfs_exclusions'])

            # set compression algorithm for squashfs-tools >= 4.1
            squashfs_comp = self.conf['options'].get('squashfs_comp')
            if squashfs_comp in ['gzip', 'lz4', 'lzo', 'xz', 'zstd']:
                cmd.extend(['-comp', squashfs_comp])
                if squashfs_comp == 'xz':
                    if arch == 'amd64' or arch == 'i386':
                        cmd.extend(['-Xbcj', 'x86'])

            # Set number of processors and I/O throttle value
            squashfs_processors = self.conf['options'].get('squashfs_processors')
            if squashfs_processors:
                cmd.extend(['-processors', f'{squashfs_processors}'])
            squashfs_throttle = self.conf['options'].get('squashfs_throttle')
            if squashfs_throttle:
                cmd.extend(['-throttle', f'{squashfs_throttle}'])

            if self.opts.debug or self.opts.quiet:
                cmd.append('-no-progress')

            # can only be last argument
            cmd.extend(['-e', image_file])

            self.log.info(f'{chroot} - creating squashfs ({squashfs_comp}) filesystem...')
            self.chroot_exec(chroot, cmd)
            self.umount_virtfs(chroot)
        elif self.conf['options']['readonly_filesystem'] == 'erofs':
            self.umount_virtfs(chroot)
            image_file = os.path.join(self.temp, image_file)
            erofs_compression = self.conf['options'].get('erofs_compression')
            erofs_comp_level = self.conf['options'].get('erofs_comp_level')
            erofs_uuid = self.conf['options'].get('erofs_uuid')
            cmd = ['mkfs.erofs', f'-U{erofs_uuid}', image_file, chroot_dir]
            if erofs_compression != 'none':
                if erofs_comp_level:
                    erofs_compression += f',{erofs_comp_level}'
                cmd.insert(1, f'-z{erofs_compression}')
            erofs_options = self.conf['options'].get('erofs_options')
            if erofs_options:
                cmd.insert(1, f'{erofs_options}')
            with open(exclude_file) as ef:
                for exclude in ef.readlines():
                    exclude = exclude.rstrip()
                    if exclude.find('*') > 0:
                        excludes = glob.glob(os.path.join(chroot_dir, exclude))
                        for ex in excludes:
                            if os.path.exists(ex):
                                cmd.insert(1, f'--exclude-path={ex.replace(chroot_dir + '/', '')}')
                    else:
                        if os.path.exists(os.path.join(chroot_dir, exclude)):
                            cmd.insert(1, f'--exclude-path={exclude}')
            if self.opts.debug or self.opts.quiet:
                cmd.insert(1, '--quiet')
            elif self.opts.debug:
                cmd.insert(1, '-d9')
            self.log.info(f'{chroot} - creating erofs ({erofs_compression}) filesystem...')
            self.exec_cmd(cmd)
            # move into chroot to avoid having to modify stage_chroot() for now
            shutil.move(image_file, chroot_dir)

    def stage_chroot(self, chroot: str) -> None:
        '''Stage files for an chroot for final genisofs.'''
        self.log.info(f'{chroot} - staging live media for chroot...')
        chroot_dir = os.path.join(self.temp, chroot)
        boot_dir = os.path.join(self.temp, 'staging', 'boot')

        image_file = os.path.join(chroot_dir, self.get_distro_imagefile(chroot))
        image_dir = os.path.join(self.temp, 'staging',
                                 self.conf['distro']['FLL_IMAGE_DIR'])
        try:
            os.chmod(image_file, 0o644)
            shutil.move(image_file, image_dir)
        except IOError:
            self.log.exception('failed to move readonly rootfs image to staging dir')
            raise FllError

        initrds = glob.glob(os.path.join(chroot_dir, 'boot', 'initrd.img-*'))
        if len(initrds) == 1:
            self.log.debug(f'copying {initrds[0]} to staging dir')
            shutil.copy(initrds[0], os.path.join(boot_dir, f'initrd.img-{chroot}'))
        else:
            self.log.critical('could not find initramfs image to ' +
                                'copy to staging dir.')
            raise FllError

        images = glob.glob(os.path.join(chroot_dir, 'boot', 'vmlinuz-*'))
        if len(images) == 1:
            self.log.debug(f'copying {images[0]} to staging dir')
            shutil.copy(images[0], os.path.join(boot_dir, f'vmlinuz-{chroot}'))
        else:
            self.log.critical('could not find linux kernel image to ' +
                                'copy to staging dir.')
            raise FllError

        if os.path.isdir(os.path.join(chroot_dir, 'usr/lib/grub')):
            data_dir = os.path.join(self.opts.share, 'data')
            grub_dir = os.path.join(boot_dir, 'grub')
            if not os.path.isdir(grub_dir):
                os.makedirs(grub_dir, 0o755)
            if not os.path.isfile(os.path.join(grub_dir, 'grub.cfg')):
              shutil.copy(os.path.join(self.opts.share, 'data/grub.cfg'), grub_dir)
              shutil.copy(os.path.join(chroot_dir, 'usr/share/grub/unicode.pf2'), grub_dir)
              shutil.copytree(os.path.join(self.opts.share, 'data/locales'), os.path.join(grub_dir, 'locales'))
              shutil.copytree(os.path.join(self.opts.share, 'data/tz'), os.path.join(grub_dir, 'tz'))
              theme_dir = f'themes/{self.conf['distro']['FLL_GFXBOOT_THEME']}'
              if os.path.isfile(os.path.join(chroot_dir, f'usr/share/grub/{theme_dir}/theme.txt')):
                  shutil.copytree(os.path.join(chroot_dir, f'usr/share/grub/{theme_dir}'), os.path.join(grub_dir, theme_dir))

            gfile_dir = glob.glob(os.path.join(chroot_dir, 'usr/lib/grub/*-pc'))[0]

            grub2_modules = glob.glob(os.path.join(gfile_dir, '*.mod'))
            if len(grub2_modules) > 0:
                gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                          if f.endswith('.mod') or f.endswith('.img')
                          or f.endswith('.lst')]
                gfiles.append(os.path.join(chroot_dir, 'tmp/grub_eltorito'))
            else:
                gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                          if f.startswith('stage2') or f.startswith('iso9660')]

            if len(gfiles) > 0:
                self.log.debug('copying grub stage files to boot dir')
                grub_dir = os.path.join(boot_dir, 'grub', 'i386-pc')
                if not os.path.isdir(grub_dir):
                    os.makedirs(grub_dir, 0o755)
            else:
                self.log.exception('grub stage files not found')
                raise FllError

            for file in gfiles:
                try:
                    shutil.copy(file, grub_dir)
                except IOError:
                    self.log.exception('failed to copy grub file to staging dir')
                    raise FllError

            # efi
            efitypes = { 'x86_64-efi':'bootx64','i386-efi':'bootia32' }
            have_efi = False
            for efitype in (list(efitypes.keys())):
                gfile_dir = os.path.join(chroot_dir, f'usr/lib/grub/{efitype}')
                if os.path.isdir(gfile_dir):
                    have_efi = True
                    gfiles = [os.path.join(gfile_dir, f) for f in os.listdir(gfile_dir)
                            if f.endswith('.mod') or f.endswith('.lst')]
                    gfiles.append(os.path.join(chroot_dir,'/usr/share/grub/unicode.pf2'))
                    if len(gfiles) > 0:
                        self.log.debug(f'copying grub {efitype} stage files to boot dir')
                        grub_dir = os.path.join(boot_dir, 'grub', efitype)
                        if not os.path.isdir(grub_dir):
                            os.makedirs(grub_dir, 0o755)
                    for file in gfiles:
                        try:
                            shutil.copy(file, grub_dir)
                        except IOError:
                            self.log.exception('failed to copy grub efi file to staging dir')
                            raise FllError
                    efi_dir = os.path.join(self.temp, 'staging/efi/boot')
                    if not os.path.isdir(efi_dir):
                        os.makedirs(efi_dir, 0o755)
                    try:
                        shutil.copy(os.path.join(chroot_dir, f'tmp/efi/boot/{efitypes[efitype]}.efi'), efi_dir)
                    except IOError:
                        self.log.exception(f'failed to copy efi {efitype} boot files to staging dir')
                        raise FllError
            if have_efi and not os.path.isfile(os.path.join(self.temp, 'staging', 'efi.img')):
                try:
                    cmd = [ 'mformat', '-C', '-f', '2880', '-L', '16', '-i', '/tmp/efi.img', '::' ]
                    self.chroot_exec(chroot, cmd)
                    cmd = [ 'mcopy', '-s', '-i', '/tmp/efi.img', '/tmp/efi_img/efi', '::/' ]
                    self.chroot_exec(chroot, cmd)
                    shutil.copy(os.path.join(chroot_dir, 'tmp/efi.img'), os.path.join(self.temp, 'staging'))
                    shutil.copy(os.path.join(chroot_dir, 'tmp/iso_uuid'), os.path.join(self.temp, 'staging'))
                    uuid_dir = os.path.join(chroot_dir, 'tmp/uuid')
                    ufiles = [os.path.join(uuid_dir, f) for f in os.listdir(uuid_dir)]
                    for file in ufiles:
                        shutil.copy(file, os.path.join(boot_dir, 'grub'))
                except IOError:
                    self.log.exception('failed to create efi.img')
                    raise FllError

        memtest = os.path.join(chroot_dir, 'boot', 'memtest86+.bin')
        memtest_out = os.path.join(boot_dir, 'memtest')
        if os.path.isfile(memtest):
            self.log.debug('copying memtest86+ to boot dir')
            try:
                shutil.copy(memtest, memtest_out)
            except IOError:
                self.log.exception('failed to copy memtest86+ to staging dir')
                raise FllError

    def write_grub_cfg(self, chroots: list) -> None:
        '''Write grub.cfg for live media.'''
        self.log.info('writing grub.cfg for live media...')
        stage_dir = os.path.join(self.temp, 'staging')
        boot_dir = os.path.join(stage_dir, 'boot')
        grub_dir = os.path.join(boot_dir, 'grub')
        distro = self.conf['distro']['FLL_DISTRO_NAME']
        timeout = self.conf['options'].get('boot_timeout', '-1')
        grubcfg = open(os.path.join(grub_dir, 'kernels.cfg'), 'w')
        
        for chroot in chroots:
            vmlinuz = f'vmlinuz-{chroot}'
            initrd = f'initrd.img-{chroot}'
            arch = self.conf['chroots'][chroot]['packages']['arch']
            cmdline = self.config_boot_cmdline(distro, chroot)

            for filename in [vmlinuz, initrd]:
                if not os.path.isfile(os.path.join(boot_dir, filename)):
                    self.log.critical(f'{filename} was not found in {boot_dir}')
                    raise FllError

            if arch[0:3] == 'amd':
                grubcfg.write('if cpuid -l; then\n')
            grubcfg.write('havekernel="Y"\n')
            grubcfg.write('title=""\n')
            grubcfg.write('for kopt in %s $kopts boot=fll %s; do\n' % (vmlinuz[8:], cmdline))
            grubcfg.write(' if [ -n "$title" ] ; then\n')
            grubcfg.write('  title="$title $kopt";\n')
            grubcfg.write(' else\n')
            grubcfg.write('  title="$kopt";\n')
            grubcfg.write(' fi;\n')
            grubcfg.write('done\n')
            grubcfg.write('menuentry --class=%s.%s \"$title\" {' % (distro, arch))
            grubcfg.write('# set arguments above with the editor\n')
            grubcfg.write('linux /boot/vmlinuz-$@\n')
            grubcfg.write('initrd /boot/%s\n' % initrd)
            grubcfg.write('}\n')
            if arch[0:3] == 'amd':
                grubcfg.write('fi\n')
        grubcfg.write('if [ "${havekernel}" != "Y" ]; then\n')
        grubcfg.write('  menuentry --class=find.none "NO SUITABLE KERNELS AVAILABLE" {echo $@')
        grubcfg.write('  echo "There are no kernels suitable for this machine available."\n')
        grubcfg.write('  echo ""\n')
        grubcfg.write('  if ! cpuid -l; then\n')
        grubcfg.write('    echo "This machine is NOT 64bit capable."\n')
        grubcfg.write('    for kk in /boot/vmlinu*.*86; do\n')
        grubcfg.write('      if [ "$kk" != "/boot/vmlinu*.*86" ]; then\n')
        grubcfg.write('        have32="true"\n')
        grubcfg.write('      fi\n')
        grubcfg.write('    done\n')
        grubcfg.write('    if [ "${have32}" != "true" ]; then\n')
        grubcfg.write('      echo "There are no 32bit kernels available"\n')
        grubcfg.write('      echo "It appears you are trying to boot a 64bit release on a 32bit machine"\n')
        grubcfg.write('      echo "This cannot work!"\n')
        grubcfg.write('    fi\n')
        grubcfg.write('  fi\n')
        grubcfg.write('  echo "Press Escape to return to the main menu"\n')
        grubcfg.write('  sleep --interruptible 9999\n')
        grubcfg.write('  menu_reload\n')
        grubcfg.write('  }\n')
        grubcfg.write('fi\n')

        grubcfg.close()
        
        self.log.debug('writing loopback.cfg for live media')
        grubcfg = open(os.path.join(grub_dir, 'loopback.cfg'), 'w')
        grubcfg.write('source /boot/grub/grub.cfg\n')
        grubcfg.close()
        
        self.log.debug('writing variable.cfg for live media')
        grubcfg = open(os.path.join(grub_dir, 'variable.cfg'), 'w')
        grub_theme = f'grub/themes/{self.conf['distro']['FLL_GFXBOOT_THEME']}/theme.txt'
        if os.path.isfile(os.path.join(boot_dir, grub_theme)):
            grubcfg.write(f'grub_theme=/boot/{grub_theme}\n')
        grubcfg.write(f'timeout={timeout}\n')
        grubcfg.close()

    def config_boot_cmdline(self, distro: str, chroot: str) -> str:
        image_dir = self.conf['distro']['FLL_IMAGE_DIR']
        cmdline = self.conf['options'].get('boot_cmdline')
        if not cmdline:
            cmdline = 'fsck.mode=skip systemd.show_status=1 quiet splash'
        cmdline += f' uuid={self.uuid} image_dir={image_dir} image_file={distro}.{chroot}'
        return cmdline

    def hash_sha256sum(self, filename: str):
        '''Calculate sha256sum of a file and return it.'''
        return apt_pkg.Hashes(open(filename, 'rb')).hashes.find('SHA256').hashvalue

    def hash_hashsums(self, filename: str):
        '''Calculate hashsums of a file and return it.'''
        hashsums = apt_pkg.Hashes(open(filename, 'rb')).hashes
        return hashsums.find('SHA256').hashvalue, hashsums.find('SHA512').hashvalue

    def hash_sha256sums(self, base: str, dirpath: str, filenames: list):
        '''Function given to os.path.walk of self.write_sha256sums().'''
        for f in filenames:
            filepath = os.path.join(dirpath, f)
            filename = filepath.partition(base)[2].lstrip('/')

            if not os.path.isfile(filepath) or f == 'sha256sums':
                continue
            if dirpath.endswith('grub') and f.find('stage') >= 0:
                continue
            if f.find('grub_eltorito') >= 0:
                continue
            if f.find('iso_uuid') >= 0:
                continue

            try:
                with open(os.path.join(base, 'sha256sums'), 'a') as sha256sums:
                    sha256sums.write(f'{self.hash_sha256sum(filepath)} *{filename}\n')
            except IOError:
                self.log.exception('failed to write sha256sums file')
                raise FllError

    def write_sha256sums(self) -> None:
        '''Calculate sha256sums of major release contents.'''
        self.log.info('calculating sha256sums of live media...')
        stage = os.path.join(self.temp, 'staging')
        for dirpath, dirnames, filenames in os.walk(stage):
            self.hash_sha256sums(stage, dirpath, filenames)

    def sign_file(self, filename) -> None:
        '''Sign a file with hashkey if available.'''
        if self.opts.hashkey:
            self.log.info(f'signing file: {filename}')
            cmd = ['gpg', '-s', '--default-key']
            cmd.append(self.opts.hashkey)
            cmd.append(filename)
            self.exec_cmd(cmd)
        else:
            self.log.info(f'not signing file (no key given): {filename}')

    def gen_live_media(self, chroots: list) -> None:
        '''Generate live media iso image.'''
        stage = os.path.join(self.temp, 'staging')

        distro_name = self.conf['distro']['FLL_DISTRO_NAME']
        image_dir = self.conf['distro']['FLL_IMAGE_DIR']

        iso_name = f'{distro_name}-{self.timestamp}.iso'

        iso_file = os.path.join(self.opts.output_dir, iso_name)
        md5_file = iso_file + '.md5'
        sha256_file = iso_file + '.sha256'
        sha512_file = iso_file + '.sha512'

        xorriso_cmd = 'xorriso -report_about HINT -as mkisofs -graft-points'
        # add -iso-level 3 to support multi-extent files > 4 GiB
        xorriso_cmd += ' -pad -l -iso-level 3'
        gpthybrid_cmd = os.path.join(self.opts.bin, 'gpthybrid')

        if self.opts.verbose:
            xorriso_cmd += ' -v'
            gpthybrid_cmd += ' --verbose'

        if os.path.isdir(os.path.join(stage, 'boot/grub')):
            xorriso_cmd += ' -no-emul-boot -boot-load-size 4 -boot-info-table'
            gpthybrid_cmd += f' --label {self.uuid} --iso {iso_file}'
            if os.path.isfile(os.path.join(stage,
                                           'boot/grub/i386-pc/grub_eltorito')):
                grub_mbr_img = os.path.join(stage,
                                            'boot/grub/i386-pc/boot_hybrid.img')
                xorriso_cmd += ' -b boot/grub/i386-pc/grub_eltorito'
                xorriso_cmd += f' --grub2-boot-info --grub2-mbr {grub_mbr_img} '
                for chroot in chroots:
                    image_file = self.get_distro_imagefile(chroot)
                    image_path = os.path.join(image_dir, image_file)
                    if os.path.isfile(os.path.join(stage, image_path)):
                        gpthybrid_cmd += f' {image_path}'
            else:
                self.log.critical('failed to find grub El Torito image file')
                raise FllError
        else:
            self.log.critical('grub is required to boot live media')
            raise FllError

        xorriso_cmd += f' --modification-date={self.uuid.replace("-","")}'
        if os.path.isfile(os.path.join(stage, 'efi.img')):
            xorriso_cmd += ' --efi-boot efi.img -efi-boot-part --efi-boot-image'
            gpthybrid_cmd += ' efi.img'

        xorriso_cmd += f' --protective-msdos-label -V {distro_name[:32]}'
        if os.path.isdir(os.path.join(stage, 'boot')):
            xorriso_cmd += ' --sort-weight 0 / --sort-weight 1 /boot'
            if os.path.isdir(os.path.join(stage, 'boot/grub')):
                xorriso_cmd += ' --sort-weight 2 /boot/grub'
        xorriso_cmd += ' -x iso_uuid -x genisoimage.sort'
        xorriso_cmd += f' -o {iso_file} {stage}'

        self.log.info('generating iso image of live media...')
        self.exec_cmd(xorriso_cmd.split())

        self.log.info('converting to hybrid iso...')
        self.exec_cmd(gpthybrid_cmd.split())

        os.chown(iso_file, self.opts.uid, self.opts.gid)

        self.log.info('calculating hashsums of live media iso image...')
        try:
            sha256sum, sha512sum = self.hash_hashsums(iso_file)
            with open(sha256_file, 'w') as sha256:
                sha256.write("%s *%s\n" % (sha256sum, os.path.basename(iso_file)))
            with open(sha512_file, 'w') as sha512:
                sha512.write("%s *%s\n" % (sha512sum, os.path.basename(iso_file)))
        except IOError:
            self.log.exception('failed to write hashsums files')
            raise FllError
        finally:
            for hashsum_file in [sha256_file, sha512_file]:
                os.chown(hashsum_file, self.opts.uid, self.opts.gid)
                if self.opts.hashkey:
                    self.log.info(f'signing {md5_file}...')
                    self.sign_file(hashsum_file)
                    os.chown(hashsum_file + '.gpg', self.opts.uid, self.opts.gid)

        for f in glob.glob('%s*' % os.path.splitext(iso_file)[0]):
            self.log.info(f)

        if self.opts.write_iso:
            self.log.info(f'wiping {self.opts.write_iso}...')
            self.exec_cmd(['wipefs', '--all', '--force',
                           f'{self.opts.write_iso}'])

        if self.opts.update_grub:
            self.log.info('updating grub2-fll-fromiso entries...')
            self.exec_cmd(['update-grub'])

        if self.opts.write_iso:
            self.log.info(f'writing iso to {self.opts.write_iso}...')
            self.exec_cmd(['dd', f'if={iso_file}', f'of={self.opts.write_iso}',
                           'bs=1M', 'status=progress'])
            self.log.info(f'updating GPT alt header location...')
            self.exec_cmd(['sgdisk', '--move-second-header',
                           f'{self.opts.write_iso}'])

    def log_build_stats(self) -> None:
        duration = int(time.perf_counter() - self.time)
        m, s = divmod(duration, 60)
        self.log.info(f'build duration was {m:d} minutes and {s:02d} seconds')

    def main(self) -> None:
        '''Main loop.'''
        self.init_cli_options()
        self.init_configuration()
        self.init_logfile()

        chroots = [chroot for chroot in self.opts.chroots] \
            if self.opts.chroots else self.conf['chroots'].keys()
        for chroot in chroots:
            if not self.conf['chroots'].get(chroot):
                self.log.error(f'chroot \'{chroot}\' not defined in {self.opts.config}')
                raise FllError()

        self.stage_build_directory()
        for chroot in chroots:
            self.parse_package_profile(chroot)
            self.chroot_bootstrap(chroot)
            self.dpkg_divert(chroot)
            self.write_default_conffiles(chroot)
            self.write_distro_defaults(chroot)
            self.preseed_debconf(chroot)
            self.prime_apt(chroot)
            self.install_packages(chroot)
            self.post_installation(chroot)
            self.write_manifest(chroot)
            self.write_final_conffiles(chroot)
            self.dpkg_undo_divert(chroot)
            self.create_initramfs(chroot)
            self.clean_chroot(chroot)
            self.mkreadonlyfs_chroot(chroot)
            self.stage_chroot(chroot)
            self.nuke_chroot(chroot)

        self.write_grub_cfg(chroots)
        self.write_sha256sums()
        self.gen_live_media(chroots)
        self.write_configuration()
        self.log_build_stats()

if __name__ == '__main__':
    pyfll_path = os.path.dirname(os.path.abspath(sys.argv[0]))
    share_path = os.path.join(pyfll_path, '../share')
    # Parse cli arguments
    cli = argparse.ArgumentParser(description='F*** Live Linux builder.',
                                  prog='fll', usage='%(prog)s -c <config file> ' +
                                  '[-b <directory> -o <directory> -l <file> ' +
                                  '-C <chroot> [<chroot> ...] -ABdDNpqUvw]')
    cli.add_argument('-A', '--apt-cache', action='store_true', default=False,
                     help='Keep cached apt URIs. Must be defined in config ' +
                     'file. Default: %(default)s')
    cli.add_argument('-b', '--build', action='store',
                     type=str, metavar='<directory>', required=True,
                     help='Build directory. A large amount of free space ' +
                     'is required.')
    cli.add_argument('-B', '--binary', action='store_true', default=False,
                     help='Do binary build only. Disable generation of ' +
                     'URI lists. Default: %(default)s')
    cli.add_argument('-c', '--config', action='store',
                     type=str, metavar='<config file>', required=True,
                     help='Configuration file. This option may be used ' +
                     'more than once to process multiple configurations. ' +
                     'A configuration file must be specified.')
    cli.add_argument('-C', '--chroots', nargs='+', metavar='<chroot>',
                     help='Name of chroot(s) to build. Default: all')
    cli.add_argument('-d', '--debug', action='store_true', default=False,
                     help='Enable debug mode. Extra output will be ' +
                     'to assist in development. Default: %(default)s')
    cli.add_argument('-k', '--hashkey', action='store', default=None,
                     type=str, metavar='<key id>', help='Set key ' +
                     'to sign MD5 and SHA256 hashes of the generated ISOs.')
    cli.add_argument('-o', '--output-dir', action='store', default=None,
                     type=str, metavar='<directory>',
                     help='Output directory, where the product of this ' +
                     'program will be generated.')
    cli.add_argument('-P', '--preserve', action='store_true', default=False,
                     help='Preserve build directory. Disable automatic ' +
                     'cleanup of the build area at exit.')
    cli.add_argument('-q', '--quiet', action='store_true', default=False,
                     help='Enable quiet mode. Only high priority messages ' +
                     'will be generated.')
    cli.add_argument('-U', '--update-grub', action='store_true', default=False,
                     help='Execute update-grub after generating iso media.')
    cli.add_argument('-v', '--verbose', action='store_true', default=False,
                     help='Enable verbose mode. All messages will be ' +
                     'generated, such as announcing current operation.')
    cli.add_argument('-w', '--write-iso', action='store', default=None,
                     type=str, metavar='<device>',
                     help='Write final iso media to device with dd.' +
                     'WARNING: destroys all existing data on <device>!!!')
    # These options are managed by the fll shell snippet non-interactively
    cli.add_argument('--bin', action='store', type=str,
                     help=argparse.SUPPRESS, default=pyfll_path)
    cli.add_argument('--share', action='store', type=str,
                     help=argparse.SUPPRESS, default=share_path)
    cli.add_argument('--gid', action='store', type=int,
                     help=argparse.SUPPRESS, default=os.getgid())
    cli.add_argument('--uid', action='store', type=int,
                     help=argparse.SUPPRESS, default=os.getuid())
    cli.add_argument('--non-root', action='store_true',
                     help=argparse.SUPPRESS, default=False)
    arguments = cli.parse_args()

    try:
        fll = FLLBuilder(arguments)
        fll.main()
    except KeyboardInterrupt:
        pass
    except FllError:
        sys.exit(1)
